#ifndef WIN32
#include <sys/stat.h>
#endif


#if defined(macintosh)
#include <types.h>
#else
#include <sys/types.h>
#endif
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <vector>
#include <map>
#include "merc.h"
#include "olc.h"
#include "gsn.h"
#include "recycle.h"
#include "lookup.h"
#include "global.h"


#include <math.h>

#if defined(__cplusplus)
extern "C" {
#endif


  int stat_costmod args((int basecost, int skill, CHAR_DATA *ch));
  int vampire_vassal args((CHAR_DATA * ch, int amount));
  extern void credit_show args((CHAR_DATA * ch, char *argument));
  extern void credit_show_adult args((CHAR_DATA * ch, char *argument));
  int lang_level args((CHAR_DATA * ch, char *argument));
  int train_skill_cost args((CHAR_DATA * ch, int skill, int method));
  int train_disc_cost args((CHAR_DATA * ch, int disc));
  bool is_sire args((CHAR_DATA * sire, CHAR_DATA *sireling));
  int skillpoint_by_vnum args((int num));
  bool elligible_training args((CHAR_DATA * ch, int skill, int type));
  int stat_cost_mod args((CHAR_DATA * ch, int method));

  int skilltype(int skill) {
    switch (skill) {
    case SKILL_REGEN:
    case SKILL_NIGHTVISION:
    case SKILL_TELEPATHY:
    case SKILL_ELECTROPATHIC:
    case SKILL_LIGHTUP:
    case SKILL_TELEMPATHY:
    case SKILL_HYPNOTISM:
    case SKILL_SUPERJUMP:
    case SKILL_ACUTESIGHT:
    case SKILL_ACUTEHEAR:
    case SKILL_ACUTESMELL:
    case SKILL_CLAIRVOYANCE:
    case SKILL_CLAIRAUDIENCE:
    case SKILL_KNOWVAMP:
    case SKILL_KNOWWERE:
    case SKILL_KNOWMAGE:
    case SKILL_AGELESS:
    case SKILL_OBFUSCATE:
    case SKILL_MIMIC:
    case SKILL_SHAPESHIFTING:
    case SKILL_AURASHIFTING:
    case SKILL_METASHIFTING:
    case SKILL_FACESTEALING:
    case SKILL_GHOSTWALKING:
    case SKILL_ILLUSIONS:
    case SKILL_CLOUDSUMMON:
    case SKILL_GLIDE:
    case SKILL_FLUIDSHIFT:
    case SKILL_DUALASPECT:
    case SKILL_DEMONMETABOL:
    case SKILL_VICIOUSSTRIKES:
    case SKILL_BLADEDEFENSE:
    case SKILL_QUICKRELOAD:
    case SKILL_ILLUSORYAFFINITY:
    case SKILL_NATURALAFFINITY:
    case SKILL_MAGICOVERLOAD:
    case SKILL_DUALELEMENTS:
    case SKILL_PERSUADE:
    case SKILL_BRANDING:
    case SKILL_PATHING:
    case SKILL_ELEMINIONS:
      return STYPE_SUPERNATURAL;
      break;

    case SKILL_DEMIGOD:
    case SKILL_TIMESWEPT:
    case SKILL_FAEBORN:
    case SKILL_DEMONBORN:
    case SKILL_ANGELBORN:
    case SKILL_SEDUCE:
    case SKILL_ENRAGE:
    case SKILL_RAGEFUELED:
    case SKILL_WAILING:
    case SKILL_STORMCALLING:
    case SKILL_OCEANAFFINITY:
    case SKILL_SOLARBLESS:
    case SKILL_LUNARBLESS:
    case SKILL_DEATHTOUCH:
    case SKILL_WARBLESS:
    case SKILL_FERTILITY:
    case SKILL_LUCKCHANGE:
    case SKILL_MERSHIFTER:
    case SKILL_BLOOMING:
    case SKILL_SIRENSONG:
    case SKILL_SENSEWEAKNESS:
    case SKILL_GUARDIAN:
    case SKILL_FLEETFOOT:
    case SKILL_SOOTHING:
    case SKILL_TOUCHED:
      return STYPE_ORIGIN;
      break;

    case SKILL_CHARISMA:
    case SKILL_ATTRACTIVENESS:
    case SKILL_CONDITIONING:
    case SKILL_BEAUTY:
    case SKILL_FASHION:
    case SKILL_ART:
    case SKILL_ART2:
    case SKILL_ART3:
    case SKILL_MINIONS:
    case SKILL_WEALTH:
    case SKILL_CLINICCONTRACT:
    case SKILL_COLLEGECONTRACT:
    case SKILL_DISPOSABLEMUSCLE:
    case SKILL_PROTECTIONDETAIL:
    case SKILL_MILITARYTRAINING:
    case SKILL_ENDOWMENT:
      return STYPE_SOCIAL;
      break;

    case SKILL_STRENGTH:
    case SKILL_DEXTERITY:
    case SKILL_ACROBATICS:
    case SKILL_RUNNING:
    case SKILL_STAMINA:
    case SKILL_FASTREFLEXES:
    case SKILL_GIANTSLAYER:
    case SKILL_CUSTOM:
    case SKILL_VIRGIN:
      return STYPE_PHYSICAL;
      break;

    case SKILL_LANGUAGE2:
    case SKILL_LANGUAGE3:
    case SKILL_LANGUAGE4:
    case SKILL_LANGUAGE5:
    case SKILL_EDUCATION:
    case SKILL_DEMONOLOGY:
    case SKILL_RITUALISM:
    case SKILL_INCANTATION:
    case SKILL_FORENSICS:
    case SKILL_CRYPTOMIND:
    case SKILL_FLESHFORMING:
    case SKILL_RESURRECTION:
    case SKILL_SPLITMIND:
    case SKILL_POWERARMOR:
      return STYPE_INTELLECTUAL;
      break;

    case SKILL_CPOLICE:
    case SKILL_CMILITARY:
    case SKILL_CGOVERNMENT:
    case SKILL_CMEDIA:
    case SKILL_CCRIMINAL:
    case SKILL_COCCULT:
    case SKILL_CHOMELESS:
    case SKILL_CHAND:
    case SKILL_CORDER:
    case SKILL_CTEMPLE:
    case SKILL_CSUBFACTION:
      return STYPE_CONTACTS;
      break;

    case SKILL_DEMOLITIONS:
    case SKILL_HACKING:
    case SKILL_STEALTH:
    case SKILL_PERCEPTION:
    case SKILL_MEDICINE:
    case SKILL_ENGINEERING:
    case SKILL_LARCENY:
    case SKILL_ANIMALS:
    case SKILL_GAMES:
    case SKILL_ALCHEMY:
    case SKILL_SNIPERTRAINING:
    case SKILL_RIPOSTE:
    case SKILL_PARALYTIC:
    case SKILL_POISONTOXIN:
      return STYPE_SKILLS;
      break;

    case SKILL_FLIGHT:
    case SKILL_HYPERSTRENGTH:
    case SKILL_HYPERSPEED:
    case SKILL_ARMORED:
    case SKILL_HYPERREGEN:
    case SKILL_HYPERSHIFTING:
    case SKILL_MINDREADING:
    case SKILL_MEMORYCLOAK:
    case SKILL_ENRAPTURE:
    case SKILL_IMMORTALITY:
    case SKILL_DARKSORC:
    case SKILL_FIRESORC:
    case SKILL_ICESORC:
    case SKILL_LIGHTNINGSORC:
    case SKILL_PRISSORC:
    case SKILL_WINGS:
    case SKILL_HYPERREFLEXES:
    case SKILL_SWARMSHIFTING:
    case SKILL_HYBRIDSHIFTING:
    case SKILL_MONSTERSHIFT:
    case SKILL_CALLNATURE:
    case SKILL_CALLGRAVE:
    case SKILL_FAMOUS:
    case SKILL_FINANCIALRUIN:
    case SKILL_ARRANGEHIT:
    case SKILL_VIEWSECRETS:
      return STYPE_ABOMINATION;
      break;

    case SKILL_GADGETS:
    case SKILL_MARTIAL:
    case SKILL_SOLDIER:
    case SKILL_COMMANDO:
    case SKILL_RIOT:
    case SKILL_PSYCHIC:
      return STYPE_ABILITIES;
      break;

    case SKILL_NATURE:
    case SKILL_COMBAT_ILLUSIONS:
    case SKILL_HAEMOMANCY:
    case SKILL_TELEKINESIS:
    case SKILL_WEATHER:
    case SKILL_MAGNO:
    case SKILL_BIOMANCY:
    case SKILL_CRYO:
    case SKILL_PYRO:
    case SKILL_NECRO:
    case SKILL_ANGELCOMBAT:
    case SKILL_DAYASPECT:
    case SKILL_NIGHTASPECT:
    case SKILL_PRIMALCOMBAT:
      return STYPE_SABILITIES;
      break;

    case SKILL_SUNRESIST:
    case SKILL_ICEPROOF:
    case SKILL_FIREPROOF:
    case SKILL_SILVERVULN:
    case SKILL_GOLDVULN:
    case SKILL_BONEVULN:
    case SKILL_WOODVULN:
      return STYPE_DEFENSE;
      break;

    case SKILL_MARTIALART:
    case SKILL_COMBATTRAINING:
    case SKILL_DODGING:
    case SKILL_EVADING:
    case SKILL_HOTSPEC:
    case SKILL_COLDSPEC:
      return STYPE_SPECIALIZATION;
      break;

    case SKILL_FAEKNIGHTFOCUS:
    case SKILL_DEMONWARRIORFOCUS:
    case SKILL_ANGELCHAMPIONFOCUS:
    case SKILL_DEMIWARRIORFOCUS:
    case SKILL_BLADEDISCFOCUS:
    case SKILL_GUNDISCFOCUS:
    case SKILL_PRIMALFOCUS:
    case SKILL_WARRIORFOCUS:
    case SKILL_SOLDIERFOCUS:
    case SKILL_ASSASSINFOCUS:
      return STYPE_COMBATFOCUS;
      break;

    case SKILL_ILLUSORYMAGICFOCUS:
    case SKILL_NATURALMAGICFOCUS:
    case SKILL_DARKMAGICFOCUS:
    case SKILL_ELEMAGICFOCUS:
      return STYPE_ARCANEFOCUS;
      break;

    case SKILL_BUSINESSFOCUS:
    case SKILL_GENERALFOCUS:
    case SKILL_MOGULFOCUS:
    case SKILL_SOCIALFOCUS:
    case SKILL_SCIENCEFOCUS:
    case SKILL_THIEFFOCUS:
    case SKILL_ENGINEERFOCUS:
      return STYPE_PROFFOCUS;
      break;
    }
    return -1;
  }

  // This checks tables.c for the range of a discipline and returns its category - Discordance
  int disciplinetype(int disc) {
    if (discipline_table[disc].range == -1)
    return DTYPE_DEFENSE;
    if (discipline_table[disc].range == 0)
    return DTYPE_CLOSECOMBAT;
    if (discipline_table[disc].range > 0)
    return DTYPE_RANGED;

    return DTYPE_UNKNOWN;
  }

  const char *fac_names_2[4] = {"", "Hand", "Order", "Temple"};

  int skillcount(CHAR_DATA *ch, int type) {
    int i, count = 0;
    for (i = 0; i < SKILL_USED; i++) {
      if (skilltype(skill_table[i].vnum) != type)
      continue;
      if (ch->skills[skill_table[i].vnum] == 0 && get_skill(ch, skill_table[i].vnum) == 0)
      continue;

      count++;
    }

    return count;
  }
  int raw_skillcount(CHAR_DATA *ch, int type) {
    int i, count = 0;
    for (i = 0; i < SKILL_USED; i++) {
      if (skilltype(skill_table[i].vnum) != type)
      continue;
      if (ch->skills[skill_table[i].vnum] == 0)
      continue;

      count++;
    }

    return count;
  }

  int raw_skillcount_level(CHAR_DATA *ch, int type) {
    int i, count = 0;
    for (i = 0; i < SKILL_USED; i++) {
      if (skilltype(skill_table[i].vnum) != type)
      continue;
      if (ch->skills[skill_table[i].vnum] == 0)
      continue;

      count += ch->skills[skill_table[i].vnum];
    }

    return count;
  }

  bool can_raise(int skillvnum, CHAR_DATA *target) {
    int tpoints = 0;
    int j, orig, points, i, pointer = 0;

    for (int y = 0; y < SKILL_USED; y++) {
      if (skill_table[y].vnum == skillvnum)
      i = y;
    }

    if (target->skills[skillvnum] == 0) {
      if (skill_table[i].levels[0] == -1)
      points = skill_table[i].levels[1];
      else
      points = skill_table[i].levels[0];
    }
    else if (target->skills[skillvnum] == -1) {
      points = 0;
    }
    else {
      for (j = 0; j < 6; j++) {
        if (target->skills[skillvnum] == skill_table[i].levels[j])
        pointer = j;
      }
      if (pointer == 5 || (skill_table[i].levels[pointer + 1] == 0 && skill_table[i].levels[pointer] != -1)) {
        return FALSE;
      }
      j = pointer;
      points = skill_table[i].levels[j + 1];
    }

    if (target->skills[skillvnum] == -1)
    tpoints = 1;
    else {
      orig = target->skills[skillvnum];
      for (j = points; j > orig; j--)
      tpoints += j;
    }
    if (!has_requirements(target, skillvnum, tpoints, FALSE))
    return FALSE;

    return TRUE;
  }

  // this looks through a skilltype and determines if the character meets the
  // requirements for any of the skills in it - Discordance
  bool has_requirements_skilltype(CHAR_DATA *ch, int type) {
    int i = 0;

    for (i = 0; i < SKILL_USED; i++) {
      if (skilltype(skill_table[i].vnum) != type)
      continue;

      if (can_raise(skill_table[i].vnum, ch))
      return TRUE;
    }
    return FALSE;
  }

  void skillloop(CHAR_DATA *ch, int type, int var) {
    int i;
    int wrap = 1;

    for (i = 0; i < SKILL_USED; i++) {
      if (skilltype(skill_table[i].vnum) != type) {
        continue;
      }

      if (var == 2 && get_skill(ch, skill_table[i].vnum) == 0
          && ch->skills[skill_table[i].vnum] == 0) {
        continue;
      }

      int cost = -1;
      cost = train_skill_cost(ch, skill_table[i].vnum, TRAINED_NATURAL);

      if (var == 1) {
        // keeps stats from displaying if the player doesn't qualify for them - Discordance
        if (!can_raise(skill_table[i].vnum, ch)) {
          continue;
        }

        if (cost <= 0) {
          continue;
        }

        if (wrap < 2) {
          wrap++;
          printf_to_char(ch, "`c%24.25s`g:`x%7d", skill_table[i].name, cost);
        }
        else {
          wrap = 1;
          printf_to_char(ch, "`c%24.25s`g:`x%7d\n\r", skill_table[i].name, cost);
        }
      }
      else if (var == 4 || var == 2) {
        // keeps stats that are zero from displaying - Discordance
        int skillvalue = 0;
        if (get_skill(ch, skill_table[i].vnum) == 0 && ch->skills[skill_table[i].vnum] == 0) {
          continue;
        }

        skillvalue = get_skill(ch, skill_table[i].vnum);

        if (wrap < 3) {
          wrap++;
          printf_to_char(ch, "`c%22.21s`g:`x%2d", skill_table[i].name, skillvalue);
        }
        else {
          wrap = 1;
          printf_to_char(ch, "`c%22.21s`g:`x%2d\n\r", skill_table[i].name, skillvalue);
        }
      }
      else {
        if (wrap < 3) {
          wrap++;
          printf_to_char(ch, "`c%22.21s`g:`x%2d", skill_table[i].name, ch->skills[skill_table[i].vnum]);
        }
        else {
          wrap = 1;
          printf_to_char(ch, "`c%22.21s`g:`x%2d\n\r", skill_table[i].name, ch->skills[skill_table[i].vnum]);
        }
      }
    }
    if (wrap == 1) {
      send_to_char("\n\r", ch);
    }
    else {
      send_to_char("\n\n\r", ch);
    }
  }

  // This goes through a skillgroup and totals all the points the character has invested - Discordance
  int skillgroup_total(CHAR_DATA *ch, int type) {
    int i = 0, total = 0;

    for (i = 0; i < SKILL_USED; i++) {
      if (skilltype(skill_table[i].vnum) != type)
      continue;

      total = total + ch->skills[skill_table[i].vnum];
    }

    return total;
  }

  _DOFUN(do_skills) {
    int var = 0;
    if (!IS_NPC(ch) && is_gm(ch) && (ch->pcdata->ci_editing == 7 || ch->pcdata->ci_editing == 8)) {
      char arg[MSL];
      argument = one_argument_nouncap(argument, arg);
      if (!str_cmp(arg, "add")) {
        for (int i = 0; i < 10; i++) {
          if (ch->pcdata->ci_stats[i] == 0) {
            for (int j = 0; j < SKILL_USED; j++) {
              if (!str_cmp(skill_table[j].name, argument)) {
                ch->pcdata->ci_stats[i] = skill_table[j].vnum;
                send_to_char("Stat added.\n\r", ch);
                return;
              }
            }
            for (int j = 1; j < 6; j++) {
              if (!str_cmp(argument, fac_names_2[j])) {
                ch->pcdata->ci_stats[i] = 100 + j;
                send_to_char("Society added.\n\r", ch);
                return;
              }
            }
          }
        }
        send_to_char("No such stat.\n\r", ch);
        return;
      }
      else if (!str_cmp(arg, "remove")) {
        for (int i = 0; i < 10; i++) {
          for (int j = 0; j < SKILL_USED; j++) {
            if (!str_cmp(skill_table[j].name, argument)) {
              if (skill_table[j].vnum == ch->pcdata->ci_stats[i]) {
                ch->pcdata->ci_stats[i] = 0;
                send_to_char("Stat removed.\n\r", ch);
                return;
              }
            }
          }
          for (int j = 1; j < 6; j++) {
            if (!str_cmp(argument, fac_names_2[j])) {
              ch->pcdata->ci_stats[i] = 0;
              send_to_char("Society removed.\n\r", ch);
              return;
            }
          }
        }
        send_to_char("No such stat.\n\r", ch);
        return;
      }
      else
      send_to_char("Syntax: stat add/remove (stat name)\n\r", ch);
      return;
    }

    if (!str_cmp(argument, "Cost")) {
      var = 1;
    }
    else if (!str_cmp(argument, "Modified")) {
      var = 4;
    }
    else if (!str_cmp(argument, "all") || !str_cmp(argument, "list")) {
      var = 3;
    }
    else {
      var = 2;
    }

    // Regular arguments
    if (var > 0) {

      send_to_char("`WStats`x\n\r", ch);
      printf_to_char(ch, "%s________________________________________________________________________________`x\n\n\r", "`g");

      if ((has_requirements_skilltype(ch, STYPE_COMBATFOCUS) || var != 1) && (skillcount(ch, STYPE_COMBATFOCUS) > 0 || var != 2)) {
        printf_to_char(ch, "`g[`x%3d`g] `WCombat Focus`x\n\r", skillgroup_total(ch, STYPE_COMBATFOCUS));
        skillloop(ch, STYPE_COMBATFOCUS, var);
      }
      if ((has_requirements_skilltype(ch, STYPE_ARCANEFOCUS) || var != 1) && (skillcount(ch, STYPE_ARCANEFOCUS) > 0 || var != 2)) {
        printf_to_char(ch, "`g[`x%3d`g] `WArcane Focus`x\n\r", skillgroup_total(ch, STYPE_ARCANEFOCUS));
        skillloop(ch, STYPE_ARCANEFOCUS, var);
      }
      if ((has_requirements_skilltype(ch, STYPE_PROFFOCUS) || var != 1) && (skillcount(ch, STYPE_PROFFOCUS) > 0 || var != 2)) {
        printf_to_char(ch, "`g[`x%3d`g] `WProfessional Focus`x\n\r", skillgroup_total(ch, STYPE_PROFFOCUS));
        skillloop(ch, STYPE_PROFFOCUS, var);
      }
      if ((has_requirements_skilltype(ch, STYPE_SOCIAL) || var != 1) && (skillcount(ch, STYPE_SOCIAL) > 0 || var != 2)) {
        printf_to_char(ch, "`g[`x%3d`g] `WSocial`x\n\r", skillgroup_total(ch, STYPE_SOCIAL));
        skillloop(ch, STYPE_SOCIAL, var);
      }
      if ((has_requirements_skilltype(ch, STYPE_PHYSICAL) || var != 1) && (skillcount(ch, STYPE_PHYSICAL) > 0 || var != 2)) {
        printf_to_char(ch, "`g[`x%3d`g] `WPhysical`x\n\r", skillgroup_total(ch, STYPE_PHYSICAL));
        skillloop(ch, STYPE_PHYSICAL, var);
      }
      if ((has_requirements_skilltype(ch, STYPE_SPECIALIZATION) || var != 1) && (skillcount(ch, STYPE_SPECIALIZATION) > 0 || var != 2)) {
        printf_to_char(ch, "`g[`x%3d`g] `WSpecialization`x\n\r", skillgroup_total(ch, STYPE_SPECIALIZATION));
        skillloop(ch, STYPE_SPECIALIZATION, var);
      }
      if ((has_requirements_skilltype(ch, STYPE_INTELLECTUAL) || var != 1) && (skillcount(ch, STYPE_INTELLECTUAL) > 0 || var != 2)) {
        printf_to_char(ch, "`g[`x%3d`g] `WIntellectual`x\n\r", skillgroup_total(ch, STYPE_INTELLECTUAL));
        skillloop(ch, STYPE_INTELLECTUAL, var);
      }
      if ((has_requirements_skilltype(ch, STYPE_CONTACTS) || var != 1) && (skillcount(ch, STYPE_CONTACTS) > 0 || var != 2)) {
        printf_to_char(ch, "`g[`x%3d`g] `WContacts`x\n\r", skillgroup_total(ch, STYPE_CONTACTS));
        skillloop(ch, STYPE_CONTACTS, var);
      }
      if ((has_requirements_skilltype(ch, STYPE_SKILLS) || var != 1) && (skillcount(ch, STYPE_SKILLS) > 0 || var != 2)) {
        printf_to_char(ch, "`g[`x%3d`g] `WSkills`x\n\r", skillgroup_total(ch, STYPE_SKILLS));
        skillloop(ch, STYPE_SKILLS, var);
      }
      if ((has_requirements_skilltype(ch, STYPE_ABILITIES) || var != 1) && (skillcount(ch, STYPE_ABILITIES) > 0 || var != 2)) {
        printf_to_char(ch, "`g[`x%3d`g] `WCombat Abilities`x\n\r", skillgroup_total(ch, STYPE_ABILITIES));
        skillloop(ch, STYPE_ABILITIES, var);
      }
      send_to_char("\nType 'stats all' to see a list of all stats or 'stats cost' for the cost to raise. Use the command powers to see supernatural stats\n\r", ch);
    }
    return;
  }

  _DOFUN(do_powers) {
    int var;

    if (!IS_NPC(ch) && is_gm(ch) && (ch->pcdata->ci_editing == 7 || ch->pcdata->ci_editing == 8)) {
      char arg[MSL];
      argument = one_argument_nouncap(argument, arg);
      if (!str_cmp(arg, "add")) {
        for (int i = 0; i < 10; i++) {
          if (ch->pcdata->ci_stats[i] == 0) {
            for (int j = 0; j < SKILL_USED; j++) {
              if (!str_cmp(skill_table[j].name, argument)) {
                ch->pcdata->ci_stats[i] = skill_table[j].vnum;
                send_to_char("Stat added.\n\r", ch);
                return;
              }
            }
            for (int j = 1; j < 6; j++) {
              if (!str_cmp(argument, fac_names_2[j])) {
                ch->pcdata->ci_stats[i] = 100 + j;
                send_to_char("Society added.\n\r", ch);
                return;
              }
            }
          }
        }
        send_to_char("No such stat.\n\r", ch);
        return;
      }
      else if (!str_cmp(arg, "remove")) {
        for (int i = 0; i < 10; i++) {
          for (int j = 0; j < SKILL_USED; j++) {
            if (!str_cmp(skill_table[j].name, argument)) {
              if (skill_table[j].vnum == ch->pcdata->ci_stats[i]) {
                ch->pcdata->ci_stats[i] = 0;
                send_to_char("Stat removed.\n\r", ch);
                return;
              }
            }
          }
          for (int j = 1; j < 6; j++) {
            if (!str_cmp(argument, fac_names_2[j])) {
              ch->pcdata->ci_stats[i] = 0;
              send_to_char("Society removed.\n\r", ch);
              return;
            }
          }
        }
        send_to_char("No such stat.\n\r", ch);
        return;
      }
      else
      send_to_char("Syntax: power add/remove (stat name)\n\r", ch);
      return;
    }

    else if (!str_cmp(argument, "Cost")) {
      var = 1;
    }
    else if (!str_cmp(argument, "Modified")) {
      var = 4;
    }
    else if (!str_cmp(argument, "all") || !str_cmp(argument, "list")) {
      var = 3;
    }
    else {
      var = 2;
    }

    // Regular arguments
    if (var > 0) {
      send_to_char("`WSupernatural`x\n\r", ch);
      printf_to_char(ch, "%s________________________________________________________________________________`x\n\n\r", "`g");
      if ((has_requirements_skilltype(ch, STYPE_ORIGIN) || var != 1) && (skillcount(ch, STYPE_ORIGIN) > 0 || var != 2)) {
        printf_to_char(ch, "`g[`x%3d`g] `WInnate`x\n\r", skillgroup_total(ch, STYPE_ORIGIN));
        skillloop(ch, STYPE_ORIGIN, var);
      }
      if ((has_requirements_skilltype(ch, STYPE_SUPERNATURAL) || var != 1) && (skillcount(ch, STYPE_SUPERNATURAL) > 0 || var != 2)) {
        printf_to_char(ch, "`g[`x%3d`g] `WPowers`x\n\r", skillgroup_total(ch, STYPE_SUPERNATURAL));
        skillloop(ch, STYPE_SUPERNATURAL, var);
      }
      if ((has_requirements_skilltype(ch, STYPE_DEFENSE) || var != 1) && (skillcount(ch, STYPE_DEFENSE) > 0 || var != 2)) {
        printf_to_char(ch, "`g[`x%3d`g] `WResistances`x\n\r", skillgroup_total(ch, STYPE_DEFENSE));
        skillloop(ch, STYPE_DEFENSE, var);
      }
      if ((has_requirements_skilltype(ch, STYPE_SABILITIES) || var != 1) && (skillcount(ch, STYPE_SABILITIES) > 0 || var != 2)) {
        printf_to_char(ch, "`g[`x%3d`g] `WCombat Abilities`x\n\r", skillgroup_total(ch, STYPE_SABILITIES));
        skillloop(ch, STYPE_SABILITIES, var);
      }
      if ((has_requirements_skilltype(ch, STYPE_ABOMINATION) || var != 1) && (skillcount(ch, STYPE_ABOMINATION) > 0 || var != 2)) {
        printf_to_char(ch, "`g[`x%3d`g] `WLegendary Powers`x\n\r", skillgroup_total(ch, STYPE_ABOMINATION));
        skillloop(ch, STYPE_ABOMINATION, var);
      }
    }

    return;
  }

  int maxdminions(CHAR_DATA *ch) {
    if (get_skill(ch, SKILL_MINIONS) >= 5)
    return 50;
    else if (get_skill(ch, SKILL_MINIONS) >= 3)
    return 40;
    else if (get_skill(ch, SKILL_MINIONS) >= 1)
    return 20;

    return 0;
  }
  int maxdallies(CHAR_DATA *ch) {
    if (get_skill(ch, SKILL_ALLIES) >= 5)
    return 75;
    else if (get_skill(ch, SKILL_ALLIES) >= 3)
    return 60;
    else if (get_skill(ch, SKILL_ALLIES) >= 1)
    return 30;

    return 0;
  }

  // This goes through a disciplinegroup and totals all the points the character has invested - Discordance
  int disciplinegroup_total(CHAR_DATA *ch, int type) {
    int i = 0, total = 0;

    for (i = 0; i < DIS_USED; i++) {
      if (type == DTYPE_RANGED) {
        if (discipline_table[i].range < 1)
        continue;
      }
      else if (type == DTYPE_CLOSECOMBAT) {
        if (discipline_table[i].range != 0)
        continue;
      }
      else if (type == DTYPE_DEFENSE) {
        if (discipline_table[i].range != -1)
        continue;
      }

      total = total + ch->disciplines[discipline_table[i].vnum];
    }

    return total;
  }

  _DOFUN(do_disciplines) {
    int i;
    int wrap = 1;
    int all = 0;
    char arg[MSL];

    if (ch->pcdata->ci_editing == 3) {
      ch->pcdata->ci_absorb = 1;
      for (int j = 0; j < DIS_USED; j++) {
        if (!str_cmp(argument, discipline_table[j].name)) {
          ch->pcdata->ci_discipline = discipline_table[j].vnum;
          printf_to_char(ch, "Discipline set to %s\n\r", argument);
          ch->pcdata->ci_special = 0;
          return;
        }
      }
      send_to_char("Discipline not found.\n\r", ch);
      return;
    }
    if (ch->pcdata->ci_editing == 4 || ch->pcdata->ci_editing == 5 || ch->pcdata->ci_editing == 6) {
      ch->pcdata->ci_absorb = 1;
      argument = one_argument_nouncap(argument, arg);
      if (!is_number(arg)) {
        send_to_char("Syntax: Discipline (value) (Name)\n\r", ch);
        return;
      }
      for (int j = 0; j < DIS_USED; j++) {
        if (!str_cmp(argument, discipline_table[j].name)) {
          if (ch->pcdata->ci_editing == 5 && discipline_table[j].range > 0 && discipline_table[j].vnum != DIS_CLAW && discipline_table[j].vnum != DIS_FIRE && discipline_table[j].vnum != DIS_ICE && discipline_table[j].vnum != DIS_LIGHTNING) {
            send_to_char("Minions can't take that discipline.\n\r", ch);
            return;
          }
          
          if (get_skill(ch, SKILL_ELEMINIONS) < 1 && discipline_table[j].range > 0 && discipline_table[j].vnum != DIS_CLAW && ch->pcdata->ci_editing == 5) {
            send_to_char("Minions can't take that discipline.\n\r", ch);
            return;
          }
          
          if (ch->pcdata->ci_editing == 6 && discipline_table[j].pc == 0) {
            send_to_char("Allies can't take that discipline.\n\r", ch);
            return;
          }
          ch->pcdata->ci_discipline = discipline_table[j].vnum;
          ch->pcdata->ci_disclevel = atoi(arg);
          printf_to_char(ch, "Discipline %s set to %d\n\r", argument, atoi(arg));
          return;
        }
      }
      send_to_char("Discipline not found.\n\r", ch);
      return;
    }

    argument = one_argument_nouncap(argument, arg);

    if (!str_cmp(arg, "cost")) {
      if (safe_strlen(argument) > 0 && is_number(argument)) {
        int dcost = atoi(argument);
        printf_to_char(ch, "Cost to train a discipline to %d is %d exp.\n\r", dcost, built_disc_cost(dcost));
        return;
      }
      send_to_char("`WDisciplines`x\n\r", ch);
      printf_to_char(ch, "%s________________________________________________________________________________`x\n\n\r", "`g");
      printf_to_char(ch, "`g[`x%3d`g] `WRanged`x\n\r", disciplinegroup_total(ch, DTYPE_RANGED));
      for (i = 0; i < DIS_USED; i++) {
        if (discipline_table[i].range < 1)
        continue;
      
        if (discipline_table[i].pc < 1 && !guestmonster(ch))
        continue;
      
        if (wrap < 2) {
          wrap++;
          printf_to_char(ch, "`c%-20.19s   `g(`x%7d`g)`x\t\t", discipline_table[i].name, train_disc_cost(ch, discipline_table[i].vnum));
        }
        else {
          wrap = 1;
          printf_to_char(ch, "`c%-20.19s   `g(`x%7d`g)`x\n\r", discipline_table[i].name, train_disc_cost(ch, discipline_table[i].vnum));
        }
      }
      if (wrap == 1)
      send_to_char("`x\n\r", ch);
      else
      send_to_char("`x\n\n\r", ch);

      printf_to_char(ch, "`g[`x%3d`g] `WClose Combat`x\n\r", disciplinegroup_total(ch, DTYPE_CLOSECOMBAT));
      for (i = 0; i < DIS_USED; i++) {
        if (discipline_table[i].range != 0)
        continue;
      
        if (discipline_table[i].pc < 1 && !guestmonster(ch))
        continue;

        if (wrap < 2) {
          wrap++;
          printf_to_char(ch, "`c%-20.19s   `g(`x%7d`g)`x\t\t", discipline_table[i].name, train_disc_cost(ch, discipline_table[i].vnum));
        }
        else {
          wrap = 1;
          printf_to_char(ch, "`c%-20.19s   `g(`x%7d`g)`x\n\r", discipline_table[i].name, train_disc_cost(ch, discipline_table[i].vnum));
        }
      }
      
      if (wrap == 1)
      send_to_char("`x\n\r", ch);
      else
      send_to_char("`x\n\n\r", ch);

      printf_to_char(ch, "`g[`x%3d`g] `WDefensive`x\n\r", disciplinegroup_total(ch, DTYPE_DEFENSE));
      for (i = 0; i < DIS_USED; i++) {
        if (discipline_table[i].range != -1)
        continue;
        if (discipline_table[i].pc < 1 && !guestmonster(ch))
        continue;

        if (wrap < 2) {
          wrap++;
          printf_to_char(ch, "`c%-20.19s   `g(`x%7d`g)`x\t\t", discipline_table[i].name, train_disc_cost(ch, discipline_table[i].vnum));
        }
        else {
          wrap = 1;
          printf_to_char(ch, "`c%-20.19s   `g(`x%7d`g)`x\n\r", discipline_table[i].name, train_disc_cost(ch, discipline_table[i].vnum));
        }
      }
      
      if (wrap == 1)
      send_to_char("`x\n\r", ch);
      else
      send_to_char("`x\n\n\r", ch);

      return;
    }

    if (!str_cmp(arg, "all") || !str_cmp(arg, "list"))
    all = 1;
  
    if (!str_cmp(arg, "creation")) {
      all = 1;
    }

    send_to_char("`WDisciplines`x\n\r", ch);
    printf_to_char(ch, "%s________________________________________________________________________________`x\n\n\r", "`g");
    if (disciplinegroup_total(ch, DTYPE_RANGED) > 0 || all == 1) {
      printf_to_char(ch, "`g[`x%3d`g] `WRanged Combat`x\n\r", disciplinegroup_total(ch, DTYPE_RANGED));

      for (i = 0; i < DIS_USED; i++) {
        if (discipline_table[i].range < 1)
        continue;
        if (discipline_table[i].pc < 1 && get_disc(ch, discipline_table[i].vnum, FALSE) <= 0 && !guestmonster(ch))
        continue;
        if (all == 0 && ch->disciplines[discipline_table[i].vnum] <= 0 && get_disc(ch, discipline_table[i].vnum, FALSE) <= 0)
        continue;

        if (wrap < 2) {
          wrap++;
          printf_to_char(ch, "`c%-21.20s   %3d`g(`x%3d`g)`x\t\t", discipline_table[i].name, ch->disciplines[discipline_table[i].vnum], get_disc(ch, discipline_table[i].vnum, FALSE));
        }
        else {
          wrap = 1;
          printf_to_char(ch, "`c%-21.20s   %3d`g(`x%3d`g)`x\n\r", discipline_table[i].name, ch->disciplines[discipline_table[i].vnum], get_disc(ch, discipline_table[i].vnum, FALSE));
        }
      }
      if (wrap == 1)
      send_to_char("`x\n\r", ch);
      else
      send_to_char("`x\n\n\r", ch);
    }

    if (disciplinegroup_total(ch, DTYPE_CLOSECOMBAT) > 0 || all == 1) {
      printf_to_char(ch, "`g[`x%3d`g] `WClose Combat`x\n\r", disciplinegroup_total(ch, DTYPE_CLOSECOMBAT));

      for (i = 0; i < DIS_USED; i++) {
        if (discipline_table[i].range != 0)
        continue;
        if (discipline_table[i].pc < 1 && get_disc(ch, discipline_table[i].vnum, FALSE) <= 0 && !guestmonster(ch))
        continue;
        if (all == 0 && ch->disciplines[discipline_table[i].vnum] <= 0 && get_disc(ch, discipline_table[i].vnum, FALSE) <= 0)
        continue;

        if (wrap < 2) {
          wrap++;
          printf_to_char(ch, "`c%-21.20s   %3d`g(`x%3d`g)`x\t\t", discipline_table[i].name, ch->disciplines[discipline_table[i].vnum], get_disc(ch, discipline_table[i].vnum, FALSE));
        }
        else {
          wrap = 1;
          printf_to_char(ch, "`c%-21.20s   %3d`g(`x%3d`g)`x\n\r", discipline_table[i].name, ch->disciplines[discipline_table[i].vnum], get_disc(ch, discipline_table[i].vnum, FALSE));
        }
      }
      if (wrap == 1)
      send_to_char("`x\n\r", ch);
      else
      send_to_char("`x\n\n\r", ch);
    }

    if (disciplinegroup_total(ch, DTYPE_DEFENSE) > 0 || all == 1) {
      printf_to_char(ch, "`g[`x%3d`g] `WDefensive`x\n\r", disciplinegroup_total(ch, DTYPE_DEFENSE));

      for (i = 0; i < DIS_USED; i++) {
        if (discipline_table[i].range != -1)
        continue;
        if (discipline_table[i].pc < 1 && get_disc(ch, discipline_table[i].vnum, FALSE) <= 0 && !guestmonster(ch))
        continue;
        if (all == 0 && ch->disciplines[discipline_table[i].vnum] <= 0 && get_disc(ch, discipline_table[i].vnum, FALSE) <= 0)
        continue;

        if (wrap < 2) {
          wrap++;
          printf_to_char(ch, "`c%-21.20s   %3d`g(`x%3d`g)`x\t\t", discipline_table[i].name, ch->disciplines[discipline_table[i].vnum], get_disc(ch, discipline_table[i].vnum, FALSE));
        }
        else {
          wrap = 1;
          printf_to_char(ch, "`c%-21.20s   %3d`g(`x%3d`g)`x\n\r", discipline_table[i].name, ch->disciplines[discipline_table[i].vnum], get_disc(ch, discipline_table[i].vnum, FALSE));
        }
      }
      if (wrap == 1)
      send_to_char("`x\n\r", ch);
      else
      send_to_char("`x\n\n\r", ch);
    }
  }

  _DOFUN(do_discipline2) {
    if (ch->pcdata->ci_editing == 4 || ch->pcdata->ci_editing == 5 || ch->pcdata->ci_editing == 6) {
      ch->pcdata->ci_absorb = 1;
      char arg[MSL];
      argument = one_argument_nouncap(argument, arg);
      if (!is_number(arg)) {
        send_to_char("Syntax: Discipline (value) (Name)\n\r", ch);
        return;
      }
      for (int j = 0; j < DIS_USED; j++) {
        if (!str_cmp(argument, discipline_table[j].name)) {
          if (ch->pcdata->ci_editing == 5 && discipline_table[j].range > 0 && discipline_table[j].vnum != DIS_CLAW && discipline_table[j].vnum != DIS_FIRE && discipline_table[j].vnum != DIS_ICE && discipline_table[j].vnum != DIS_LIGHTNING) {
            send_to_char("Minions can't take that discipline.\n\r", ch);
            return;
          }
          if (get_skill(ch, SKILL_ELEMINIONS) < 1 && discipline_table[j].range > 0 && discipline_table[j].vnum != DIS_CLAW && ch->pcdata->ci_editing == 5) {
            send_to_char("Minions can't take that discipline.\n\r", ch);
            return;
          }
          if (ch->pcdata->ci_editing == 6 && discipline_table[j].pc == 0) {
            send_to_char("Allies can't take that discipline.\n\r", ch);
            return;
          }
          ch->pcdata->ci_discipline2 = discipline_table[j].vnum;
          ch->pcdata->ci_disclevel2 = atoi(arg);
          printf_to_char(ch, "Discipline %s set to %d\n\r", argument, atoi(arg));
          return;
        }
      }
      send_to_char("Discipline not found.\n\r", ch);
      return;
    }
  }
  _DOFUN(do_discipline3) {
    if (ch->pcdata->ci_editing == 4 || ch->pcdata->ci_editing == 5 || ch->pcdata->ci_editing == 6) {
      ch->pcdata->ci_absorb = 1;
      char arg[MSL];
      argument = one_argument_nouncap(argument, arg);
      if (!is_number(arg)) {
        send_to_char("Syntax: Discipline (value) (Name)\n\r", ch);
        return;
      }
      for (int j = 0; j < DIS_USED; j++) {
        if (!str_cmp(argument, discipline_table[j].name)) {
          if (ch->pcdata->ci_editing == 5 && discipline_table[j].range > 0 && discipline_table[j].vnum != DIS_CLAW && discipline_table[j].vnum != DIS_FIRE && discipline_table[j].vnum != DIS_ICE && discipline_table[j].vnum != DIS_LIGHTNING) {
            send_to_char("Minions can't take that discipline.\n\r", ch);
            return;
          }
          if (get_skill(ch, SKILL_ELEMINIONS) < 1 && discipline_table[j].range > 0 && discipline_table[j].vnum != DIS_CLAW && ch->pcdata->ci_editing == 5) {
            send_to_char("Minions can't take that discipline.\n\r", ch);
            return;
          }
          if (ch->pcdata->ci_editing == 6 && discipline_table[j].pc == 0) {
            send_to_char("Allies can't take that discipline.\n\r", ch);
            return;
          }
          ch->pcdata->ci_discipline3 = discipline_table[j].vnum;
          ch->pcdata->ci_disclevel3 = atoi(arg);
          printf_to_char(ch, "Discipline %s set to %d\n\r", argument, atoi(arg));
          return;
        }
      }
      send_to_char("Discipline not found.\n\r", ch);
      return;
    }
  }
  _DOFUN(do_discipline4) {
    if (ch->pcdata->ci_editing == 4 || ch->pcdata->ci_editing == 5 || ch->pcdata->ci_editing == 6) {
      ch->pcdata->ci_absorb = 1;
      char arg[MSL];
      argument = one_argument_nouncap(argument, arg);
      if (!is_number(arg)) {
        send_to_char("Syntax: Discipline (value) (Name)\n\r", ch);
        return;
      }
      for (int j = 0; j < DIS_USED; j++) {
        if (!str_cmp(argument, discipline_table[j].name)) {
          if (ch->pcdata->ci_editing == 5 && discipline_table[j].range > 0 && discipline_table[j].vnum != DIS_CLAW && discipline_table[j].vnum != DIS_FIRE && discipline_table[j].vnum != DIS_ICE && discipline_table[j].vnum != DIS_LIGHTNING) {
            send_to_char("Minions can't take that discipline.\n\r", ch);
            return;
          }
          if (get_skill(ch, SKILL_ELEMINIONS) < 1 && discipline_table[j].range > 0 && discipline_table[j].vnum != DIS_CLAW && ch->pcdata->ci_editing == 5) {
            send_to_char("Minions can't take that discipline.\n\r", ch);
            return;
          }
          if (ch->pcdata->ci_editing == 6 && discipline_table[j].pc == 0) {
            send_to_char("Allies can't take that discipline.\n\r", ch);
            return;
          }
          ch->pcdata->ci_discipline4 = discipline_table[j].vnum;
          ch->pcdata->ci_disclevel4 = atoi(arg);
          printf_to_char(ch, "Discipline %s set to %d\n\r", argument, atoi(arg));
          return;
        }
      }
      send_to_char("Discipline not found.\n\r", ch);
      return;
    }
  }
  _DOFUN(do_discipline5) {
    if (ch->pcdata->ci_editing == 4 || ch->pcdata->ci_editing == 5 || ch->pcdata->ci_editing == 6) {
      ch->pcdata->ci_absorb = 1;
      char arg[MSL];
      argument = one_argument_nouncap(argument, arg);
      if (!is_number(arg)) {
        send_to_char("Syntax: Discipline (value) (Name)\n\r", ch);
        return;
      }
      for (int j = 0; j < DIS_USED; j++) {
        if (!str_cmp(argument, discipline_table[j].name)) {
          if (ch->pcdata->ci_editing == 5 && discipline_table[j].range > 0 && discipline_table[j].vnum != DIS_CLAW && discipline_table[j].vnum != DIS_FIRE && discipline_table[j].vnum != DIS_ICE && discipline_table[j].vnum != DIS_LIGHTNING) {
            send_to_char("Minions can't take that discipline.\n\r", ch);
            return;
          }
          if (get_skill(ch, SKILL_ELEMINIONS) < 1 && discipline_table[j].range > 0 && discipline_table[j].vnum != DIS_CLAW && ch->pcdata->ci_editing == 5) {
            send_to_char("Minions can't take that discipline.\n\r", ch);
            return;
          }
          if (ch->pcdata->ci_editing == 6 && discipline_table[j].pc == 0) {
            send_to_char("Allies can't take that discipline.\n\r", ch);
            return;
          }
          ch->pcdata->ci_discipline5 = discipline_table[j].vnum;
          ch->pcdata->ci_disclevel5 = atoi(arg);
          printf_to_char(ch, "Discipline %s set to %d\n\r", argument, atoi(arg));
          return;
        }
      }
      send_to_char("Discipline not found.\n\r", ch);
      return;
    }
  }

  void refund_exp(CHAR_DATA *ch, int amount) {
    int refund;
    if (ch->in_room != NULL && ch->in_room->vnum < 200 && ch->in_room->vnum > 20)
    refund = 100;
    else if (ch->played / 3600 < 20 || (ch->pcdata->account != NULL && ch->pcdata->account->maxhours < 50))
    refund = 90;
    else
    refund = 70;

    if (ch->spentexp > 0) {
      int deduct = UMIN(amount, ch->spentexp);
      ch->spentexp -= deduct;
      if (ch->pcdata->account != NULL && !is_roster_char(ch))
      ch->pcdata->account->xp += deduct * refund / 100;
      else
      ch->exp += deduct * refund / 100;
      amount -= deduct;
    }

    if (amount > 0) {
      ch->spentnewexp -= amount;
      ch->newexp += amount * refund / 100;
    }
    if (ch->spentexp < 0)
    ch->spentexp = 0;
    if (ch->spentnewexp < 0)
    ch->spentnewexp = 0;
  }

  void refund_rpexp(CHAR_DATA *ch, int amount, bool forcenew) {
    int refund;
    if (ch->in_room != NULL && ch->in_room->vnum < 200 && ch->in_room->vnum > 20)
    refund = 100;
    else if (ch->played / 3600 < 20 || (ch->pcdata->account != NULL && ch->pcdata->account->maxhours < 50))
    refund = 90;
    else
    refund = 70;

    if (ch->spentrpexp > 0 && forcenew == FALSE) {
      int deduct = UMIN(amount, ch->spentrpexp);
      ch->spentrpexp -= deduct;
      if (ch->pcdata->account != NULL && !is_roster_char(ch))
      ch->pcdata->account->rpxp += deduct * refund / 100;
      else
      ch->rpexp += deduct * refund / 100;
      amount -= deduct;
    }
    if (amount > 0) {
      ch->spentnewrpexp -= amount;
      ch->newrpexp += amount * refund / 100;
    }
    if (ch->spentrpexp < 0)
    ch->spentrpexp = 0;
    if (ch->spentnewrpexp < 0)
    ch->spentnewrpexp = 0;
  }

  void charge_exp(CHAR_DATA *ch, int amount) {
    if (ch->newexp >= amount) {
      ch->newexp -= amount;
      ch->spentnewexp += amount;
    }
    else if (ch->pcdata->account == NULL) {
      if (ch->newexp > 0) {
        int deduct = UMIN(amount, ch->newexp);
        ch->newexp -= deduct;
        ch->spentnewexp += deduct;
        amount -= deduct;
      }
      ch->exp -= amount;
      ch->spentexp += amount;
    }
    else {
      if (ch->newexp > 0) {
        int deduct = UMIN(amount, ch->newexp);
        ch->newexp -= deduct;
        ch->spentnewexp += deduct;
        amount -= deduct;
      }
      if (ch->exp > 0) {
        int deduct = UMIN(amount, ch->exp);
        ch->exp -= deduct;
        ch->spentexp += deduct;
        amount -= deduct;
      }
      ch->pcdata->account->xp -= amount;
      ch->spentexp += amount;
    }
  }
  void charge_rpexp(CHAR_DATA *ch, int amount) {
    if (ch->newrpexp >= amount) {
      ch->newrpexp -= amount;
      ch->spentnewrpexp += amount;
    }
    else if (ch->pcdata->account == NULL) {
      if (ch->newrpexp > 0) {
        int deduct = UMIN(amount, ch->newrpexp);
        ch->newrpexp -= deduct;
        ch->spentnewrpexp += deduct;
        amount -= deduct;
      }
      ch->rpexp -= amount;
      ch->spentrpexp += amount;
    }
    else {
      if (ch->newrpexp > 0) {
        int deduct = UMIN(amount, ch->newrpexp);
        ch->newrpexp -= deduct;
        ch->spentnewrpexp += deduct;
        amount -= deduct;
      }
      if (ch->rpexp > 0) {
        int deduct = UMIN(amount, ch->rpexp);
        ch->rpexp -= deduct;
        ch->spentrpexp += deduct;
        amount -= deduct;
      }
      ch->pcdata->account->rpxp -= amount;
      ch->spentrpexp += amount;
    }
  }

  // This version of negtrain uses free trains that don't mess around with a player's experience - Discordance
  _DOFUN(do_negtrain) {
    char name[MSL];
    int i;
    CHAR_DATA *target;

    if (is_gm(ch) && !IS_IMMORTAL(ch)) {
      send_to_char("You're a storyrunner.\n\r", ch);
      return;
    }

    if (IS_FLAG(ch->act, PLR_STASIS)) {
      send_to_char("You cannot do that to a character in stasis.\n\r", ch);
      return;
    }

    if (IS_IMMORTAL(ch)) {
      char *backup;
      backup = str_dup(argument);
      argument = one_argument_nouncap(argument, name);
      if ((target = get_char_world(ch, name)) == NULL || IS_NPC(target)) {
        send_to_char("Can't locate player.  Searching for a stat or discipline...\n\r", ch);
        argument = str_dup(backup);
        target = ch;
      }
    }
    else {
      target = ch;
    }
    if (IS_FLAG(ch->act, PLR_DEAD)) {
      send_to_char("You are as the day you died.\n\r", ch);
      return;
    }
    if (IS_FLAG(ch->act, PLR_NOSAVE))
    return;

    int shield_total = 0;
    for (i = 0; i < DIS_USED; i++) {
      if (target->disciplines[discipline_table[i].vnum] > 0) {
        if (discipline_table[i].range == -1)
        shield_total += target->disciplines[discipline_table[i].vnum];
      }
    }
    alter_character(ch);
    for (i = 0; i < DIS_USED; i++) {
      if (!str_cmp(argument, discipline_table[i].name)) {
        if (target->disciplines[discipline_table[i].vnum] <= 0) {
          send_to_char("It can't go any lower.\n\r", ch);
          return;
        }
        int value = 0;
        if (discipline_table[i].range == -1)
        value = shield_total;
        else
        value = target->disciplines[discipline_table[i].vnum];

        if (IS_IMMORTAL(ch)) {
          target->disciplines[discipline_table[i].vnum]--;
          send_to_char("Done.\n\r", ch);
          return;
        }
        int cost = value * BASE_DISC_COST;
        target->disciplines[discipline_table[i].vnum]--;
        refund_exp(target, cost);
        printf_to_char(target, "You lower your %s discipline.\n\r", discipline_table[i].name);
        return;
      }
    }
    for (i = 0; i < SKILL_USED; i++) {
      if (!str_cmp(skill_table[i].name, argument)) {
        if (skill_table[i].vnum == SKILL_COLDSPEC || skill_table[i].vnum == SKILL_HOTSPEC) {
          if (target->in_room == NULL || target->in_room->vnum < 50 || target->in_room->vnum > 100) {
            send_to_char("That cannot be negtrained.\n\r", ch);
            return;
          }
        }

        // Exceptions to make sure stats aren't dropped below their minimums
        if (target->skills[skill_table[i].vnum] <= -1) {
          printf_to_char(ch, "Your %s stat is already as low as it can go.\n\r", skill_table[i].name);
          continue;
        }
        else if (target->skills[skill_table[i].vnum] == 0 && skill_table[i].levels[0] != -1) {
          printf_to_char(ch, "Your %s stat is already as low as it can go.\n\r", skill_table[i].name);
          continue;
        }
        bool focusstat = FALSE;
        if (skilltype(skill_table[i].vnum) == STYPE_COMBATFOCUS || skilltype(skill_table[i].vnum) == STYPE_ARCANEFOCUS || skilltype(skill_table[i].vnum) == STYPE_PROFFOCUS) {
          if (target->in_room != NULL && target->in_room->vnum >= 50 && target->in_room->vnum < 100) {
            target->pcdata->account->xp += target->spentexp;
            target->spentexp = 0;
            target->pcdata->account->rpxp += target->spentrpexp;
            target->spentrpexp = 0;
            target->newexp += target->spentnewexp;
            target->spentnewexp = 0;
            target->newrpexp += target->spentnewrpexp;
            target->spentnewrpexp = 0;
            for (int i = 0; i < DIS_USED; i++)
            target->disciplines[i] = 0;
            for (int i = 0; i < SKILL_USED; i++)
            target->skills[i] = 0;
            send_to_char("Character reset.\n\r", ch);
            for (int x = 0; x < 300; x++) {
              int point = x;
              target->pcdata->stat_log_stat[point] = 0;
              target->pcdata->stat_log_from[point] = 0;
              target->pcdata->stat_log_to[point] = 0;
              target->pcdata->stat_log_cost[point] = 0;
              target->pcdata->stat_log_method[point] = 0;
              free_string(target->pcdata->stat_log_string[point]);
              target->pcdata->stat_log_string[point] = str_dup("");
            }

            return;
          }
          focusstat = TRUE;
        }

        // Determine where current skill level falls on increment chart
        /*
        for(j=0;j<6;j++) {
        if (target->skills[skill_table[i].vnum] == skill_table[i].levels[j]) {
        tablemark = j;
        j = 5;
        }
        else {
        tablemark = -1;
        }
        }
        */
        if (focusstat == TRUE) {
          for (int x = 0; x < 10; x++) {
            if (target->pcdata->previous_focus_vnum[x] == 0 || target->pcdata->previous_focus_vnum[x] > SKILL_MAX) {
              target->pcdata->previous_focus_vnum[x] = skill_table[i].vnum;
              target->pcdata->previous_focus_level[x] =
              target->skills[skill_table[i].vnum];
              x = 10;
            }
          }
        }
        if (target->skills[skill_table[i].vnum] == 0) {
          target->skills[skill_table[i].vnum] =
          target->skills[skill_table[i].vnum] - 1;
          refund_rpexp(target, BASE_STAT_COST, TRUE);
          printf_to_char(ch, "You lower your %s stat.\n\r", skill_table[i].name);
          return;
        }

        int maxval = -1;
        int point = -1;
        for (int x = 0; x < 300; x++) {
          if (target->pcdata->stat_log_stat[x] == skill_table[i].vnum && target->pcdata->stat_log_to[x] > maxval) {
            maxval = target->pcdata->stat_log_to[x];
            point = x;
          }
        }
        target->skills[skill_table[i].vnum] =
        target->pcdata->stat_log_from[point];
        if (!IS_IMMORTAL(ch))
        refund_rpexp(target, target->pcdata->stat_log_cost[point], FALSE);
        if (skill_table[i].vnum == SKILL_AGELESS) {
          target->pcdata->apparant_age = 0;
          printf_to_char(ch, "You appear to be %d years old.\n\r", get_age(target));
        }
        printf_to_char(ch, "You lower your %s stat.\n\r", skill_table[i].name);
        if (skill_table[i].vnum == SKILL_CLINICCONTRACT) {
          for (vector<INSTITUTE_TYPE *>::iterator it = InVect.begin();
          it != InVect.end(); ++it) {
            if (!str_cmp((*it)->name, target->name))
            (*it)->asylum_rank = 0;
          }
        }
        if (skill_table[i].vnum == SKILL_COLLEGECONTRACT) {
          for (vector<INSTITUTE_TYPE *>::iterator it = InVect.begin();
          it != InVect.end(); ++it) {
            if (!str_cmp((*it)->name, target->name))
            (*it)->college_rank = 0;
          }
        }

        target->pcdata->stat_log_stat[point] = 0;
        target->pcdata->stat_log_from[point] = 0;
        target->pcdata->stat_log_to[point] = 0;
        target->pcdata->stat_log_cost[point] = 0;
        target->pcdata->stat_log_method[point] = 0;
        free_string(target->pcdata->stat_log_string[point]);
        target->pcdata->stat_log_string[point] = str_dup("");
      }
    }
  }

  int skilltype_count(CHAR_DATA *ch, int type) {
    int total = 0;

    for (int i = 0; i < SKILL_USED; i++) {
      if (skilltype(skill_table[i].vnum) != type)
      continue;

      if (type == STYPE_ABILITIES || type == STYPE_SABILITIES) {
        int x;
        for (x = 0; x < 5 && ch->pcdata->ability_trees[x] != 0 && ch->pcdata->ability_trees[x] != skill_table[i].vnum;
        x++) {
        }
        total += ch->skills[skill_table[i].vnum] * (x + 1);
      }
      else
      total += skillpoint(ch->skills[skill_table[i].vnum]);
    }
    return total;
  }
  
  int skillbase_count(CHAR_DATA *ch, int type) {
    int total = 0;

    for (int i = 0; i < SKILL_USED; i++) {
      if (skilltype(skill_table[i].vnum) != type)
      continue;

      if (ch->skills[skill_table[i].vnum] > 0)
      total++;
    }
    return total;
  }

  int skillpointer(int skill) {
    for (int i = 0; i < SKILL_USED; i++) {
      if (skill_table[i].vnum == skill)
      return i;
    }
    return 0;
  }

  int focus_point_per_tier(CHAR_DATA *ch) {
    int points = 0;
    if (get_tier(ch) == 2) {

      points = 1;
    }
    if (get_tier(ch) == 3) {
      points = 3;
    }
    if (get_tier(ch) == 4)
    points = 5;
    if (get_tier(ch) == 5)
    points = 7;
    if (get_tier(ch) == 6)
    points = 7;

    points += ch->pcdata->extra_focus;

    return points;
  }

  bool can_train_combat_focus(CHAR_DATA *ch) {

    int cap = focus_point_per_tier(ch);
    int spent = combat_focus(ch) + arcane_focus(ch) + prof_focus(ch);
    if (ch->race == RACE_BROWN)
    spent++;
    if (ch->race == RACE_IMPORTANT)
    spent = UMAX(spent, 1);
    if (ch->race == RACE_CELEBRITY)
    spent = UMAX(spent, 3);
    if (ch->race == RACE_PILLAR)
    spent = UMAX(spent, 3);
    if (spent >= cap)
    return FALSE;

    return TRUE;
  }

  bool can_train_arcane_focus(CHAR_DATA *ch) {
    int cap = focus_point_per_tier(ch);
    int spent = combat_focus(ch) + arcane_focus(ch) + prof_focus(ch);

    if (arcane_focus(ch) >= combat_focus(ch) && arcane_focus(ch) >= prof_focus(ch) && is_werewolf(ch))
    return FALSE;
    if (ch->race == RACE_BROWN)
    spent++;
    if (ch->race == RACE_SOLDIER)
    spent = UMAX(spent, 1);
    if (ch->race == RACE_IMPORTANT)
    spent = UMAX(spent, 1);
    if (ch->race == RACE_DEPUTY)
    spent = UMAX(spent, 1);
    if (ch->race == RACE_SFORCES)
    spent = UMAX(spent, 3);
    if (ch->race == RACE_CELEBRITY)
    spent = UMAX(spent, 3);
    if (ch->race == RACE_PILLAR)
    spent = UMAX(spent, 3);
  
    if (spent >= cap)
    return FALSE;
  
    if (!is_super(ch) && ch->race != RACE_WILDLING && ch->race != RACE_TIMESWEPT
    && ch->race != RACE_DABBLER && ch->race != RACE_FACULTY && ch->race != RACE_DREAMCHILD
    && ch->race != RACE_ELSEBORN && ch->race != RACE_GIFTED)
    return FALSE;
  
    return TRUE;
  }

  bool can_train_prof_focus(CHAR_DATA *ch) {
    if (ch->race == RACE_TIMESWEPT)
    return FALSE;
    if (ch->race == RACE_WILDLING)
    return FALSE;
    int cap = focus_point_per_tier(ch);
    int spent = combat_focus(ch) + arcane_focus(ch) + prof_focus(ch);
    if (ch->race == RACE_BROWN)
    spent++;
    if (ch->race == RACE_DEPUTY)
    spent = UMAX(spent, 1);
    if (ch->race == RACE_SFORCES)
    spent = UMAX(spent, 1);

    if (spent >= cap)
    return FALSE;
  
    return TRUE;
  }

  bool overcap_combat_focus(CHAR_DATA *ch) {

    int cap = focus_point_per_tier(ch);
    int spent = combat_focus(ch) + arcane_focus(ch) + prof_focus(ch);
    if (ch->race == RACE_BROWN)
    spent++;
    if (ch->race == RACE_IMPORTANT)
    spent = UMAX(spent, 1);
    if (ch->race == RACE_CELEBRITY)
    spent = UMAX(spent, 3);
    if (ch->race == RACE_PILLAR)
    spent = UMAX(spent, 3);
    if (spent > cap)
    return TRUE;
  
    return FALSE;
  }

  bool overcap_arcane_focus(CHAR_DATA *ch) {
    int cap = focus_point_per_tier(ch);
    int spent = combat_focus(ch) + arcane_focus(ch) + prof_focus(ch);

    if (ch->race == RACE_BROWN)
    spent++;
    if (ch->race == RACE_SOLDIER)
    spent = UMAX(spent, 1);
    if (ch->race == RACE_IMPORTANT)
    spent = UMAX(spent, 1);
    if (ch->race == RACE_DEPUTY)
    spent = UMAX(spent, 1);
    if (ch->race == RACE_SFORCES)
    spent = UMAX(spent, 3);
    if (ch->race == RACE_CELEBRITY)
    spent = UMAX(spent, 3);
    if (ch->race == RACE_PILLAR)
    spent = UMAX(spent, 3);
    if (spent > cap)
    return TRUE;
  
    return FALSE;
  }

  bool overcap_prof_focus(CHAR_DATA *ch) {

    int cap = focus_point_per_tier(ch);
    int spent = combat_focus(ch) + arcane_focus(ch) + prof_focus(ch);
    if (ch->race == RACE_BROWN)
    spent++;
    if (ch->race == RACE_DEPUTY)
    spent = UMAX(spent, 1);
    if (ch->race == RACE_SFORCES)
    spent = UMAX(spent, 1);

    if (spent > cap)
    return TRUE;
  
    return FALSE;
  }

  // This seperates pact_holders from other demonborn - Discordance
  bool is_sufferingsensitive(CHAR_DATA *ch) {
    if(has_imbuement(ch, -11))
    return TRUE;

    if (pact_holder(ch)) {
      if (get_skill(ch, SKILL_DEMONBORN) <= 0 && ch->race != RACE_NEWDEMONBORN && ch->race != RACE_VETDEMONBORN && ch->race != RACE_OLDDEMONBORN && ch->race != RACE_DEMIDEMON) {
        return FALSE;
      }
    }

    if (is_demonborn(ch))
    return TRUE;

    return FALSE;
  }

  bool has_requirements(CHAR_DATA *ch, int skill, int level, bool show) {
    int value = ch->skills[skill];
    int sorcery_requirement;

    if (skilltype(skill) == -1)
    return FALSE;

    if (level > 5 || level < 0)
    level = value + 1;

    if (guestmonster(ch)) {
      if (skill == SKILL_LARCENY)
      return FALSE;
      if (skill == SKILL_WEALTH || skill == SKILL_STEALTH)
      return FALSE;
      if (skill == SKILL_MEMORYCLOAK)
      return FALSE;

      if (skilltype(skill) == STYPE_CONTACTS) {
        if (raw_skillcount(ch, STYPE_CONTACTS) > 4 || (raw_skillcount(ch, STYPE_CONTACTS) == 4 && value == 0)) {
          if (show == TRUE)
          printf_to_char(ch, "You already have four contacts.\n\r", ch);
          return FALSE;
        }
      }

      return TRUE;
    }

    if (higher_power(ch)) {
      if (skill == SKILL_LARCENY && level > 3) {
        if (show == TRUE)
        send_to_char("Higher Powers cannot take that.\n\r", ch);
        return FALSE;
      }
      
      if (skill == SKILL_DEMOLITIONS && level > 2) {
        if (show == TRUE)
        send_to_char("Higher Powers cannot take that.\n\r", ch);
        return FALSE;
      }
      
      if (skill == SKILL_GHOSTWALKING && level > 0) {
        if (show == TRUE)
        send_to_char("Higher Powers cannot take that.\n\r", ch);
        return FALSE;
      }
      
      if (skill == SKILL_STEALTH && level > 1) {
        if (show == TRUE)
        send_to_char("Higher Powers cannot take that.\n\r", ch);
        return FALSE;
      }
    }
    if (IS_FLAG(ch->act, PLR_GUEST) || IS_FLAG(ch->act, PLR_GM)) {
      if (skill == SKILL_LARCENY && level > 3) {
        if (show == TRUE)
        send_to_char("Guests cannot take that.\n\r", ch);
        return FALSE;
      }
      
      if (skill == SKILL_DEMOLITIONS && level > 2) {
        if (show == TRUE)
        send_to_char("Guests cannot take that.\n\r", ch);
        return FALSE;
      }
      
      if (skill == SKILL_WEALTH && level > 2) {
        if (show == TRUE)
        send_to_char("Guests cannot take that.\n\r", ch);
        return FALSE;
      }

      if (skill == SKILL_GHOSTWALKING && level > 0) {
        if (show == TRUE)
        send_to_char("Guests cannot take that.\n\r", ch);
        return FALSE;
      }
      
      if (skill == SKILL_STEALTH && level > 1) {
        if (show == TRUE)
        send_to_char("Guests cannot take that.\n\r", ch);
        return FALSE;
      }
      
      if (skill == SKILL_FINANCIALRUIN) {
        if (show == TRUE)
        send_to_char("Guests cannot take that.\n\r", ch);
        return FALSE;
      }
    }
    sorcery_requirement = 3;

    if (skilltype(skill) == STYPE_ORIGIN) {
      if (event_cleanse == 1)
      return FALSE;

      if (raw_skillcount(ch, STYPE_ORIGIN) > 0) {
        if (show == TRUE)
        send_to_char("You can only have one innate stat.\n\r", ch);
        return FALSE;
      }
      else if (ch->race == RACE_FACULTY) {
        if (show == TRUE)
        send_to_char("Institute staff can't take innate stats.\n\r", ch);
        return FALSE;
      }
    }

    if (skill == SKILL_LANGUAGE5 && ch->skills[SKILL_LANGUAGE4] < 1)
    return FALSE;
    if (skill == SKILL_LANGUAGE4 && ch->skills[SKILL_LANGUAGE3] < 1)
    return FALSE;
    if (skill == SKILL_LANGUAGE3 && ch->skills[SKILL_LANGUAGE2] < 1)
    return FALSE;

    if (skill == SKILL_DREAMSIGHT)
    return FALSE;

    if (skill == SKILL_FORENSICS && get_real_age(ch) < 20) {
      if (show == TRUE)
      send_to_char("You're too young to have learned forensics.\n\r", ch);
      return FALSE;
    }

    if (skill == SKILL_CLINICCONTRACT || skill == SKILL_COLLEGECONTRACT) {
      if (higher_power(ch)) {
        if (show == TRUE)
        send_to_char("Higher powers can't take contracts.\n\r", ch);
        return FALSE;
      }
    }

    if ((skill == SKILL_COLDSPEC || skill == SKILL_HOTSPEC) && is_undead(ch)) {
      if (show == TRUE)
      send_to_char("Only the living can take that.\n\r", ch);
      return FALSE;
    }

    if (skill == SKILL_MEDICINE) {
      if (level == 4 || level == 5) {
        if (get_age(ch) < 26 && get_true_age(ch) < 26) {
          if (show == TRUE)
          send_to_char("You're too young to be at that level of medicine.\n\r", ch);

          return FALSE;
        }
      }
    }

    if (skill == SKILL_EDUCATION) {
      if (level >= 2) {
        if (get_age(ch) < 21 && get_true_age(ch) < 21) {
          if (show == TRUE) {
            send_to_char("You're too young to have that qualification.\n\r", ch);
          }
          return FALSE;
        }
      }
    }

    if (skilltype(skill) == -1) {
      if (show == TRUE)
      send_to_char("No such skill.\n\r", ch);
      return FALSE;
    }

    if (skilltype(skill) == STYPE_COMBATFOCUS && !can_train_combat_focus(ch)) {
      if (show == TRUE)
      send_to_char("Your tier is too low or archetype the wrong type to develop your combat focus further.\n\r", ch);
      return FALSE;
    }

    if (skilltype(skill) == STYPE_ARCANEFOCUS && !can_train_arcane_focus(ch)) {
      if (show == TRUE)
      send_to_char("Your tier is too low or archetype the wrong type to develop your arcane focus further.\n\r", ch);
      return FALSE;
    }

    if (skilltype(skill) == STYPE_PROFFOCUS && !can_train_prof_focus(ch)) {
      if (show == TRUE)
      send_to_char("Your tier is too low or archetype the wrong type to develop your professional focus further.\n\r", ch);
      return FALSE;
    }

    if (ch->race == RACE_CELEBRITY && skilltype(skill) == STYPE_PROFFOCUS && skill != SKILL_SOCIALFOCUS) {
      if (show == TRUE)
      send_to_char("You can only gain the socialite focus.\n\r", ch);
      return FALSE;
    }

    if (skill == SKILL_GUNDISCFOCUS && !is_super(ch)) {
      if (show == TRUE)
      send_to_char("You'd need to be supernatural to learn that.\n\r", ch);
      return FALSE;
    }

    if (skill == SKILL_BLADEDISCFOCUS && !is_super(ch)) {
      if (show == TRUE)
      send_to_char("You'd need to be supernatural to learn that.\n\r", ch);
      return FALSE;
    }

    if (skill == SKILL_FAEKNIGHTFOCUS && (!is_faeborn(ch) || is_undead(ch) || !is_super(ch))) {
      if (show == TRUE)
      send_to_char("You'd need to be faeborn to learn that.\n\r", ch);
      return FALSE;
    }

    if (skill == SKILL_PRIMALFOCUS && (is_undead(ch) || !is_super(ch))) {
      if (show == TRUE)
      send_to_char("You must be alive and supernatural to learn that.\n\r", ch);
      return FALSE;
    }

    if (skill == SKILL_DEMONWARRIORFOCUS && (!is_demonborn(ch) || !is_super(ch))) {
      if (show == TRUE)
      send_to_char("You'd need to be demonborn to learn that.\n\r", ch);
      return FALSE;
    }

    if (skill == SKILL_DEMIWARRIORFOCUS && (!is_demigod(ch) || !is_super(ch))) {
      if (show == TRUE)
      send_to_char("You'd need to be demigod to learn that.\n\r", ch);
      return FALSE;
    }

    if (skill == SKILL_ANGELCHAMPIONFOCUS && (!is_angelborn(ch) || !is_super(ch))) {
      if (show == TRUE)
      send_to_char("You'd need to be angelborn to learn that.\n\r", ch);
      return FALSE;
    }

    if (skill == SKILL_ILLUSORYMAGICFOCUS) {
      if (!higher_power(ch)) {
        if (is_demonborn(ch) || is_angelborn(ch) || is_vampire(ch) || is_werewolf(ch) || is_demigod(ch)) {
          if (show == TRUE)
          send_to_char("Demonborn, angelborn, Vampires, Werewolves and Demigods cannot learn that that.\n\r", ch);
          return FALSE;
        }
      }
      if (!is_super(ch) && ch->race != RACE_WILDLING && ch->race != RACE_TIMESWEPT && ch->race != RACE_GIFTED
      && ch->race != RACE_FACULTY && ch->race != RACE_DREAMCHILD && ch->race != RACE_ELSEBORN) {
        if (show == TRUE)
        send_to_char("You need to be supernatural to learn that.\n\r", ch);
        return FALSE;
      }
    }

    if (skill == SKILL_NATURALMAGICFOCUS) {
      if (is_angelborn(ch) || is_vampire(ch) || ch->skills[SKILL_DARKMAGICFOCUS] > 0) {
        if (show == TRUE)
        send_to_char("Angelborn, vampires and practitioners of dark magic cannot learn that.\n\r", ch);
        return FALSE;
      }
      
      if (!is_super(ch) && ch->race != RACE_WILDLING && ch->race != RACE_TIMESWEPT && ch->race != RACE_DABBLER
      && ch->race != RACE_GIFTED && ch->race != RACE_FACULTY && ch->race != RACE_DREAMCHILD && ch->race != RACE_ELSEBORN) {
        if (show == TRUE)
        send_to_char("You need to be supernatural to learn that.\n\r", ch);
        return FALSE;
      }
    }

    if (skill == SKILL_DARKMAGICFOCUS) {
      if (ch->skills[SKILL_NATURALMAGICFOCUS] > 0) {
        if (show == TRUE)
        send_to_char("Practitioners of natural magic cannot learn that.\n\r", ch);
        return FALSE;
      }
      if (!is_super(ch) && ch->race != RACE_WILDLING && ch->race != RACE_TIMESWEPT && ch->race != RACE_DABBLER
      && ch->race != RACE_FACULTY && ch->race != RACE_GIFTED && ch->race != RACE_DREAMCHILD && ch->race != RACE_ELSEBORN) {
        if (show == TRUE)
        send_to_char("You need to be supernatural to learn that.\n\r", ch);
        return FALSE;
      }
    }

    if (skill == SKILL_ELEMAGICFOCUS) {
      if (!is_super(ch) && ch->race != RACE_WILDLING && ch->race != RACE_TIMESWEPT && ch->race != RACE_DABBLER
      && ch->race != RACE_FACULTY && ch->race != RACE_GIFTED && ch->race != RACE_DREAMCHILD && ch->race != RACE_ELSEBORN) {
        if (show == TRUE)
        send_to_char("You need to be supernatural to learn that.\n\r", ch);
        return FALSE;
      }
    }

    if (skill == SKILL_PERSUADE && get_tier(ch) < 2) {
      if (show == TRUE)
      send_to_char("You need to be at least tier 2 to learn that.\n\r", ch);
      return FALSE;
    }

    if (skill == SKILL_BRANDING && get_tier(ch) < 3) {
      if (show == TRUE)
      send_to_char("You need to be at least tier 3 to learn that.\n\r", ch);
      return FALSE;
    }

    if (skill == SKILL_PATHING) {
      if (value >= 2 && get_tier(ch) < 3) {
        if (show == TRUE)
        send_to_char("You need to be at least tier 3 to learn that.\n\r", ch);
        return FALSE;
      }
      if (value >= 3 && get_tier(ch) < 4) {
        if (show == TRUE)
        send_to_char("You need to be at least tier 4 to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_HYPERREFLEXES && get_skill(ch, SKILL_GUNDISCFOCUS) < 3 && get_skill(ch, SKILL_BLADEDISCFOCUS) < 3) {
      if (show == TRUE)
      send_to_char("You need gun or blade disciple 3 to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_WINGS && ch->race != RACE_FREEANGEL) {
      if (show == TRUE)
      send_to_char("Only freed angels can learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_HYBRIDSHIFTING && get_skill(ch, SKILL_PRIMALFOCUS) < 3 && !higher_power(ch)) {
      if (show == TRUE)
      send_to_char("You need primal focus 3 to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_SWARMSHIFTING && get_skill(ch, SKILL_DARKMAGICFOCUS) < 3
    && get_skill(ch, SKILL_NATURALMAGICFOCUS) < 3 && !higher_power(ch)) {
      if (show == TRUE)
      send_to_char("You need dark magic or natural magic focus 3 to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_MONSTERSHIFT && get_skill(ch, SKILL_PRIMALFOCUS) < 3
    && get_skill(ch, SKILL_FAEKNIGHTFOCUS) < 3 && !higher_power(ch)) {
      if (show == TRUE)
      send_to_char("You need fae knight focus or primal focus 3 to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_SUNRESIST && (get_tier(ch) < 3 || !is_vampire(ch))) {
      if (show == TRUE)
      send_to_char("You need to be at least tier 3 to learn that.\n\r", ch);
      return FALSE;
    }

    if (skill == SKILL_MARTIAL) {
      if (ch->skills[SKILL_WARRIORFOCUS] < 1 && get_skill(ch, SKILL_ASSASSINFOCUS) < 1) {
        if (show == TRUE)
        send_to_char("You'd need warrior or assassin focus to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_SOLDIER) {
      if (get_skill(ch, SKILL_SOLDIERFOCUS) < 1) {
        if (show == TRUE)
        send_to_char("You'd need soldier focus to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_COMMANDO) {
      if (get_skill(ch, SKILL_WARRIORFOCUS) < 1 && get_skill(ch, SKILL_SOLDIERFOCUS) < 1
      && get_skill(ch, SKILL_ASSASSINFOCUS) < 1) {
        if (show == TRUE)
        send_to_char("You'd need warrior, soldier or assassin focus to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_RIOT) {
      if (get_skill(ch, SKILL_WARRIORFOCUS) < 1 && get_skill(ch, SKILL_SOLDIERFOCUS) < 1) {
        if (show == TRUE)
        send_to_char("You'd need warrior or soldier focus to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_NATURE) {
      if (get_skill(ch, SKILL_NATURALMAGICFOCUS) < 1) {
        if (show == TRUE)
        send_to_char("You'd need natural magic focus to learn that.\n\r", ch);
        return FALSE;
      }
      int val =
      get_skill(ch, SKILL_NATURALMAGICFOCUS) - ch->skills[SKILL_WEATHER];
      if (value >= val) {
        if (show == TRUE)
        send_to_char("You'd need higher natural magic focus to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_WEATHER) {
      if (get_skill(ch, SKILL_NATURALMAGICFOCUS) < 1) {
        if (show == TRUE)
        send_to_char("You'd need natural magic focus to learn that.\n\r", ch);
        return FALSE;
      }
      int val = get_skill(ch, SKILL_NATURALMAGICFOCUS) - ch->skills[SKILL_NATURE];
      if (value >= val) {
        if (show == TRUE)
        send_to_char("You'd need higher natural magic focus to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_NECRO) {
      if (get_skill(ch, SKILL_DARKMAGICFOCUS) < 1) {
        if (show == TRUE)
        send_to_char("You'd need dark magic focus to learn that.\n\r", ch);
        return FALSE;
      }
      int val =
      get_skill(ch, SKILL_DARKMAGICFOCUS) - ch->skills[SKILL_HAEMOMANCY];
      if (value >= val) {
        if (show == TRUE)
        send_to_char("You'd need higher dark magic focus to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_HAEMOMANCY) {
      if (get_skill(ch, SKILL_DARKMAGICFOCUS) < 1) {
        if (show == TRUE)
        send_to_char("You'd need dark magic focus to learn that.\n\r", ch);
        return FALSE;
      }
      int val = get_skill(ch, SKILL_DARKMAGICFOCUS) - ch->skills[SKILL_NECRO];
      if (value >= val) {
        if (show == TRUE)
        send_to_char("You'd need higher dark magic focus to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_COMBAT_ILLUSIONS) {
      if (get_skill(ch, SKILL_ILLUSORYMAGICFOCUS) < 1) {
        if (show == TRUE)
        send_to_char("You'd need illusory magic focus to learn that.\n\r", ch);
        return FALSE;
      }
      if (value >= get_skill(ch, SKILL_ILLUSORYMAGICFOCUS)) {
        if (show == TRUE)
        send_to_char("You'd need higher illusory magic focus to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_PYRO) {
      if (get_skill(ch, SKILL_ELEMAGICFOCUS) < 1) {
        if (show == TRUE)
        send_to_char("You'd need elemental magic focus to learn that.\n\r", ch);
        return FALSE;
      }
      if (value >= get_skill(ch, SKILL_ELEMAGICFOCUS)) {
        if (show == TRUE)
        send_to_char("You'd need higher elemental magic focus to learn that.\n\r", ch);
        return FALSE;
      }
      if (ch->skills[SKILL_CRYO] > 0 && get_skill(ch, SKILL_DUALELEMENTS) <= 0) {
        if (show == TRUE)
        send_to_char("You cannot master both fire and ice.\n\r", ch);
        return FALSE;
      }
    }

    if (skill == SKILL_CRYO) {
      if (get_skill(ch, SKILL_ELEMAGICFOCUS) < 1) {
        if (show == TRUE)
        send_to_char("You'd need elemental magic focus to learn that.\n\r", ch);
        return FALSE;
      }
      if (value >= get_skill(ch, SKILL_ELEMAGICFOCUS)) {
        if (show == TRUE)
        send_to_char("You'd need higher elemental magic focus to learn that.\n\r", ch);
        return FALSE;
      }
      if (ch->skills[SKILL_PYRO] > 0 && get_skill(ch, SKILL_DUALELEMENTS) <= 0) {
        if (show == TRUE)
        send_to_char("You cannot master both fire and ice.\n\r", ch);
        return FALSE;
      }
    }

    if (skill == SKILL_FIREPROOF) {
      if (get_skill(ch, SKILL_ELEMAGICFOCUS) < 2) {
        if (show == TRUE)
        send_to_char("You'd need elemental magic focus of at least 2 to learn that.\n\r", ch);
        return FALSE;
      }
      if (ch->skills[SKILL_ICEPROOF] > 0 && get_skill(ch, SKILL_DUALELEMENTS) <= 0) {
        if (show == TRUE)
        send_to_char("You cannot master both fire and ice.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_ICEPROOF) {
      if (get_skill(ch, SKILL_ELEMAGICFOCUS) < 2) {
        if (show == TRUE)
        send_to_char("You'd need elemental magic focus of at least 2 to learn that.\n\r", ch);
        return FALSE;
      }
      if (ch->skills[SKILL_FIREPROOF] > 0 && get_skill(ch, SKILL_DUALELEMENTS) <= 0) {
        if (show == TRUE)
        send_to_char("You cannot master both fire and ice.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_ELEMINIONS && get_skill(ch, SKILL_ELEMAGICFOCUS) < 2) {
      if (show == TRUE)
      send_to_char("You need elemental magic focus of at least 2 to learn that.\n\r", ch);
      return FALSE;
    }

    if (skill == SKILL_ANGELCOMBAT) {
      if (get_skill(ch, SKILL_ANGELCHAMPIONFOCUS) < 1) {
        if (show == TRUE)
        send_to_char("You'd need angelic champion focus to learn that.\n\r", ch);
        return FALSE;
      }
      if (value >= get_skill(ch, SKILL_ANGELCHAMPIONFOCUS)) {
        if (show == TRUE)
        send_to_char("You'd need higher angelic champion focus to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_PRIMALCOMBAT) {
      if (get_skill(ch, SKILL_PRIMALFOCUS) < 1) {
        if (show == TRUE)
        send_to_char("You'd need primal focus to learn that.\n\r", ch);
        return FALSE;
      }
      if (value >= get_skill(ch, SKILL_PRIMALFOCUS)) {
        if (show == TRUE)
        send_to_char("You'd need higher primal focus to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_DAYASPECT) {
      if (get_skill(ch, SKILL_DEMIWARRIORFOCUS) < 1) {
        if (show == TRUE)
        send_to_char("You'd need demigod warrior focus to learn that.\n\r", ch);
        return FALSE;
      }
      
      if (value >= get_skill(ch, SKILL_DEMIWARRIORFOCUS)) {
        if (show == TRUE)
        send_to_char("You'd need higher demigod warrior focus to learn that.\n\r", ch);
        return FALSE;
      }
      if (ch->skills[SKILL_NIGHTASPECT] > 0 && get_skill(ch, SKILL_DUALASPECT) <= 0) {
        if (show == TRUE)
        send_to_char("You cannot master both day and night.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_NIGHTASPECT) {
      if (get_skill(ch, SKILL_DEMIWARRIORFOCUS) < 1) {
        if (show == TRUE)
        send_to_char("You'd need demigod warrior focus to learn that.\n\r", ch);
        return FALSE;
      }
      if (value >= get_skill(ch, SKILL_DEMIWARRIORFOCUS)) {
        if (show == TRUE)
        send_to_char("You'd need higher demigod warrior focus to learn that.\n\r", ch);
        return FALSE;
      }
      if (ch->skills[SKILL_DAYASPECT] > 0 && get_skill(ch, SKILL_DUALASPECT) <= 0) {
        if (show == TRUE)
        send_to_char("You cannot master both day and night.\n\r", ch);
        return FALSE;
      }
    }

    if (skill == SKILL_SPLITMIND) {
      if (ch->pcdata->dexp < 60000 && !IS_FLAG(ch->act, PLR_GUEST)) {
        if (show == TRUE)
        send_to_char("You need at least 60k dream experience to learn that.\n\r", ch);
        return FALSE;
      }
      if (value > 0 && ch->pcdata->dexp < 120000 && !IS_FLAG(ch->act, PLR_GUEST)) {
        if (show == TRUE)
        send_to_char("You need at least 120k dream experience to learn that.\n\r", ch);
        return FALSE;
      }
    }

    if (skill == SKILL_TELEMPATHY) {
      if (!is_super(ch) && ch->skills[SKILL_TOUCHED] < 1 && ch->pcdata->bonus_origin != SKILL_TOUCHED) {
        if (show == TRUE)
        send_to_char("You need to be supernatural or sensitive to learn that.\n\r", ch);
        return FALSE;
      }
      if (ch->pcdata->dexp < 50000 && !IS_FLAG(ch->act, PLR_GUEST)) {
        if (show == TRUE)
        send_to_char("You need at least 50k dream experience to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_DREAMING) {
      if (ch->pcdata->dexp < 100000 && !IS_FLAG(ch->act, PLR_GUEST)) {
        if (show == TRUE)
        send_to_char("You need at least 100k dream experience to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_TELEPATHY) {
      if (!is_super(ch) && ch->skills[SKILL_TOUCHED] < 1 && ch->pcdata->bonus_origin != SKILL_TOUCHED) {
        if (show == TRUE)
        send_to_char("You need to be supernatural or sensitive to learn that.\n\r", ch);
        return FALSE;
      }
      if (ch->pcdata->dexp < 100000 && !higher_power(ch) && !IS_FLAG(ch->act, PLR_GUEST)) {
        if (show == TRUE)
        send_to_char("You need at least 100k dream experience to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_PSYCHIC) {
      if (!is_super(ch) && ch->skills[SKILL_TOUCHED] < 1 && ch->pcdata->bonus_origin != SKILL_TOUCHED) {
        if (show == TRUE)
        send_to_char("You need to be supernatural or sensitive to learn that.\n\r", ch);
        return FALSE;
      }

      if (ch->pcdata->dexp < 150000 && !IS_FLAG(ch->act, PLR_GUEST)) {
        if (show == TRUE)
        send_to_char("You need at least 150k dream experience to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_MINDREADING) {
      if (!is_super(ch) && ch->skills[SKILL_TOUCHED] < 1 && ch->pcdata->bonus_origin != SKILL_TOUCHED) {
        if (show == TRUE)
        send_to_char("You need to be supernatural or sensitive to learn that.\n\r", ch);
        return FALSE;
      }

      if (ch->pcdata->dexp < 200000 && !higher_power(ch) && !IS_FLAG(ch->act, PLR_GUEST)) {
        if (show == TRUE)
        send_to_char("You need at least 200k dream experience to learn that.\n\r", ch);
        return FALSE;
      }
    }

    if (skill == SKILL_SILVERVULN || skill == SKILL_GOLDVULN || skill == SKILL_WOODVULN || skill == SKILL_BONEVULN) {
      if (is_vampire(ch) || is_werewolf(ch) || !is_super(ch)) {
        if (show == TRUE)
        send_to_char("Only supernaturals who aren't vampires or werewolves can learn that.\n\r", ch);
        return FALSE;
      }
    }

    if (skill == SKILL_FLIGHT && get_skill(ch, SKILL_NATURALMAGICFOCUS) < 3) {
      if (show == TRUE)
      send_to_char("You need natural magic focus of at least 3 to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_HYPERSTRENGTH && ((get_skill(ch, SKILL_DEMIWARRIORFOCUS) < 3
    && get_skill(ch, SKILL_DEMONWARRIORFOCUS) < 3) || ch->skills[SKILL_STRENGTH] < 3)) {
      if (show == TRUE)
      send_to_char("You need demigod warrior or demonborn warrior focus at 3 and have 3 strength to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_HYPERSPEED && (get_skill(ch, SKILL_ANGELCHAMPIONFOCUS) < 3 || ch->skills[SKILL_RUNNING] < 3)) {
      if (show == TRUE)
      send_to_char("You need angelborn champion of at least 3 and have running 3 to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_ARMORED && ch->race != RACE_DEMIDEMON && !higher_power(ch)) {
      if (show == TRUE)
      send_to_char("You need to be a demidemon to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_HYPERREGEN && get_skill(ch, SKILL_DEMONWARRIORFOCUS) < 3) {
      if (show == TRUE)
      send_to_char("You need demon warrior focus of at least 3 to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_HYPERSHIFTING && get_skill(ch, SKILL_FAEKNIGHTFOCUS) < 3 && !higher_power(ch)) {
      if (show == TRUE)
      send_to_char("You need fae knight focus of at least 3 to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_CUSTOM) {
      if ((get_tier(ch) < 3 && (get_tier(ch) < 2 || ch->skills[SKILL_MENTALDISCIPLINE] <= 0))
      || ch->pcdata->account->donated < 1750) {
        if (show == TRUE)
        send_to_char("You need at least tier 3 with 1750 community credit for that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_MEMORYCLOAK && get_skill(ch, SKILL_ILLUSORYMAGICFOCUS) < 3) {
      if (show == TRUE)
      send_to_char("You need illusory magic focus of at least 3 to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_ENRAPTURE && get_skill(ch, SKILL_SOCIALFOCUS) < 3) {
      if (show == TRUE)
      send_to_char("You need socialite focus of at least 3 to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_IMMORTALITY && get_skill(ch, SKILL_DEMIWARRIORFOCUS) < 3) {
      if (show == TRUE)
      send_to_char("You need demigod warrior focus of at least 3 to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_FLESHFORMING && get_skill(ch, SKILL_SCIENCEFOCUS) < 3 && !higher_power(ch)) {
      if (show == TRUE)
      send_to_char("You need scientist focus of at least 3 to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_RESURRECTION && get_skill(ch, SKILL_SCIENCEFOCUS) < 3) {
      if (show == TRUE)
      send_to_char("You need scientist focus of at least 3 to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_ICESORC && get_skill(ch, SKILL_ELEMAGICFOCUS) < sorcery_requirement && !higher_power(ch)) {
      if (show == TRUE)
      send_to_char("You need elemental magic focus of at least 3 to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_FIRESORC && get_skill(ch, SKILL_ELEMAGICFOCUS) < sorcery_requirement && !higher_power(ch)) {
      if (show == TRUE)
      send_to_char("You need elemental magic focus of at least 3 to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_LIGHTNINGSORC && get_skill(ch, SKILL_NATURALMAGICFOCUS) < sorcery_requirement && !higher_power(ch)) {
      if (show == TRUE)
      send_to_char("You need natural magic focus of at least 3 to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_CALLNATURE && get_skill(ch, SKILL_NATURALMAGICFOCUS) < 3) {
      if (show == TRUE)
      send_to_char("You need natural magic focus of at least 3 to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_CALLGRAVE && get_skill(ch, SKILL_DARKMAGICFOCUS) < 3) {
      if (show == TRUE)
      send_to_char("You need dark magic focus of at least 3 to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_POWERARMOR && get_skill(ch, SKILL_ENGINEERFOCUS) < 3 && get_skill(ch, SKILL_GENERALFOCUS) < 4) {
      if (show == TRUE)
      send_to_char("You need commander 4 or engineer focus 3 to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_FAMOUS && get_skill(ch, SKILL_SOCIALFOCUS) < 2) {
      if (show == TRUE)
      send_to_char("You need social focus 2 to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_FINANCIALRUIN && (get_skill(ch, SKILL_BUSINESSFOCUS) < 2)) {
      if (show == TRUE)
      send_to_char("You need business focus 2 to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_ARRANGEHIT && get_skill(ch, SKILL_MOGULFOCUS) < 2) {
      if (show == TRUE)
      send_to_char("You need underworld mogul focus 2 to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_VIEWSECRETS && get_skill(ch, SKILL_SOCIALFOCUS) < 2 && get_skill(ch, SKILL_MOGULFOCUS) < 2
    && ch->skills[SKILL_HACKING] < 4) {
      if (show == TRUE)
      send_to_char("You need social, or mogul focus 2 or hacking 4 to learn that.\n\r", ch);
      return FALSE;
    }

    if (skill == SKILL_DARKSORC && get_skill(ch, SKILL_DARKMAGICFOCUS) < sorcery_requirement && !higher_power(ch)) {
      if (show == TRUE)
      send_to_char("You need dark magic focus of at least 3 to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_PRISSORC && get_skill(ch, SKILL_ILLUSORYMAGICFOCUS) < sorcery_requirement && !higher_power(ch)) {
      if (show == TRUE)
      send_to_char("You need illusory magic focus of at least 3 to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_DISPOSABLEMUSCLE && get_skill(ch, SKILL_MOGULFOCUS) < 4) {
      if (show == TRUE)
      send_to_char("You need underworld mogul at at least 4 to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_MILITARYTRAINING && get_skill(ch, SKILL_GENERALFOCUS) < 4) {
      if (show == TRUE)
      send_to_char("You need commander focus of at least 4 to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_PROTECTIONDETAIL && get_skill(ch, SKILL_MOGULFOCUS) < 2 && get_skill(ch, SKILL_GENERALFOCUS) < 2) {
      if (show == TRUE)
      send_to_char("You need underworld mogul or commander focus of at least 2 to learn that.\n\r", ch);
      return FALSE;
    }
    if (skill == SKILL_TELEKINESIS) {
      if (get_skill(ch, SKILL_BLADEDISCFOCUS) < 1) {
        if (show == TRUE)
        send_to_char("You'd need blade discipline focus to learn that.\n\r", ch);
        return FALSE;
      }
      if (value >= get_skill(ch, SKILL_BLADEDISCFOCUS)) {
        if (show == TRUE)
        send_to_char("You'd need higher blade discipline focus to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_MAGNO) {
      if (get_skill(ch, SKILL_GUNDISCFOCUS) < 1) {
        if (show == TRUE)
        send_to_char("You'd need blade discipline focus to learn that.\n\r", ch);
        return FALSE;
      }
      if (value >= get_skill(ch, SKILL_GUNDISCFOCUS)) {
        if (show == TRUE)
        send_to_char("You'd need higher blade discipline focus to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_BIOMANCY) {
      if (is_undead(ch)) {
        if (show == TRUE)
        send_to_char("The undead cannot master this.\n\r", ch);
        return FALSE;
      }
      if (get_skill(ch, SKILL_FAEKNIGHTFOCUS) < 1 && get_skill(ch, SKILL_DEMONWARRIORFOCUS) < 1) {
        if (show == TRUE)
        send_to_char("You'd need fae knight or demon warrior focus to learn that.\n\r", ch);
        return FALSE;
      }
      if (value >= UMAX(get_skill(ch, SKILL_FAEKNIGHTFOCUS), get_skill(ch, SKILL_DEMONWARRIORFOCUS))) {
        if (show == TRUE)
        send_to_char("You'd need higher fae knight or demon warrior focus to learn that.\n\r", ch);
        return FALSE;
      }
    }

    if (skill == SKILL_REGEN && value > 0) {
      if (get_skill(ch, SKILL_DEMONWARRIORFOCUS) < 3 && get_skill(ch, SKILL_DEMIWARRIORFOCUS) < 4) {
        if (show == TRUE)
        send_to_char("Only demon and demigod warriors can regenerate at that speed.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_NIGHTVISION) {
      if ((!is_super(ch))) {
        if (show == TRUE)
        send_to_char("You need to be a supernatural to unlock that power.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_SUPERJUMP) {
      if (get_skill(ch, SKILL_ANGELCHAMPIONFOCUS) < 1 && get_skill(ch, SKILL_BLADEDISCFOCUS) < 2 && get_tier(ch) < 4) {
        if (show == TRUE)
        send_to_char("You need to be tier 4, an angelborn champion or a blade disciple to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_HYPNOTISM) {
      if (value > 0) {
        if (!is_vampire(ch) && get_tier(ch) < 2) {
          if (show == TRUE)
          send_to_char("You need to be a vampire or tier 2 for that.\n\r", ch);
          return FALSE;
        }
      }
      if (value > 1) {
        if (get_tier(ch) < 3) {
          if (show == TRUE)
          send_to_char("You need to be tier 3 for that.\n\r", ch);
          return FALSE;
        }
      }
    }
    if (skill == SKILL_OBFUSCATE && ch->race == RACE_DEMIDEMON) {
      if (show == TRUE)
      send_to_char("Demidemons cannot hide who they are.\n\r", ch);
      return FALSE;
    }

    if (skill == SKILL_KNOWVAMP) {
      if (!is_vampire(ch) && arcane_focus(ch) < 3 && get_skill(ch, SKILL_DARKMAGICFOCUS) < 1) {
        if (show == TRUE)
        send_to_char("You need to be a vampire, have arcane focus of 3 or dark magic focus of 1 to take that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_KNOWWERE) {
      if (!is_werewolf(ch) && arcane_focus(ch) < 3 && get_skill(ch, SKILL_NATURALMAGICFOCUS) < 1) {
        if (show == TRUE)
        send_to_char("You need to be a werewolf, have arcane focus of 3 or natural magic focus of 1 to take that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_KNOWMAGE) {
      if (arcane_focus(ch) < 5) {
        if (show == TRUE)
        send_to_char("You need to have arcane focus of 5 to take that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_AGELESS) {
      if (get_skill(ch, SKILL_AGELESS) > 0) {
        if (show == TRUE)
        send_to_char("You're already ageless.\n\r", ch);
        return FALSE;
      }
      if (get_tier(ch) < 3) {
        if (show == TRUE)
        send_to_char("You need to be tier 3 to take that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_LIGHTUP) {
      if (!is_angelborn(ch) && get_skill(ch, SKILL_ILLUSORYMAGICFOCUS) < 1) {
        if (show == TRUE)
        send_to_char("You need to be an angelborn or have illusory magic focus of 1 to gain that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_ELECTROPATHIC) {
      if (get_skill(ch, SKILL_GUNDISCFOCUS) < 3 && (ch->modifier != MODIFIER_TEMPLE || is_super(ch))
      && (get_tier(ch) < 4 || !is_demonborn(ch))) {
        if (show == TRUE)
        send_to_char("You need a gun discipline focus of 3, temple augmentation or to be a tier 4+ demonborn to take that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_CLAIRVOYANCE || skill == SKILL_CLAIRAUDIENCE) {
      if (!is_demigod(ch) && arcane_focus(ch) < 1 && get_skill(ch, SKILL_SCIENCEFOCUS) < 3) {
        if (show == TRUE)
        send_to_char("You need to be a demigod or have arcane focus of 1, or scientist 3 to take that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_SHAPESHIFTING) {
      if (value < 2) {
        if (get_skill(ch, SKILL_PRIMALFOCUS) < 1 && get_skill(ch, SKILL_FAEKNIGHTFOCUS) < 1
        && get_skill(ch, SKILL_NATURALMAGICFOCUS) < 2 && get_skill(ch, SKILL_ILLUSORYMAGICFOCUS) < 3
        && get_skill(ch, SKILL_DARKMAGICFOCUS) < 3 && !higher_power(ch)) {
          if (show == TRUE)
          send_to_char("You need to have fae knight focus, primal focus, natural magic focus at 2, or illusory/dark magic focus at 3 to learn that.\n\r", ch);
          return FALSE;
        }
      }
      if (value >= 2) {
        if (value > UMAX(get_skill(ch, SKILL_FAEKNIGHTFOCUS), get_skill(ch, SKILL_PRIMALFOCUS)) && !higher_power(ch)) {
          if (show == TRUE)
          printf_to_char(ch, "You need primal focus or fae knight focus of at least %d to learn that.\n\r", value);
          return FALSE;
        }
      }
    }
    if (skill == SKILL_METASHIFTING) {
      if (get_skill(ch, SKILL_FAEKNIGHTFOCUS) < 4 && get_skill(ch, SKILL_PRIMALFOCUS) < 2) {
        if (show == TRUE)
        send_to_char("You need fae knight focus of 4, or primal focus of 2 to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_AURASHIFTING) {
      if (get_skill(ch, SKILL_FAEKNIGHTFOCUS) < 3 && get_skill(ch, SKILL_NATURALMAGICFOCUS) < 2
      && get_skill(ch, SKILL_ILLUSORYMAGICFOCUS) < 3 && get_skill(ch, SKILL_DARKMAGICFOCUS) < 3 && !higher_power(ch)) {
        if (show == TRUE)
        send_to_char("You need fae knight focus of 3, natural magic focus of 2, or illusory/dark magic focus of 3 to learn that.\n\r", ch);
        return FALSE;
      }
    }

    if (skill == SKILL_FACESTEALING || skill == SKILL_ILLUSIONS) {
      if (get_skill(ch, SKILL_ILLUSORYMAGICFOCUS) < 2 && !higher_power(ch)) {
        if (show == TRUE)
        send_to_char("You need illusory magic focus of at least 2 to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_MIMIC) {
      if (get_skill(ch, SKILL_ILLUSORYMAGICFOCUS) < 3) {
        if (show == TRUE)
        send_to_char("You need illusory magic focus of at least 3 to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_GHOSTWALKING) {
      if (get_skill(ch, SKILL_DARKMAGICFOCUS) < 3) {
        if (show == TRUE)
        send_to_char("You need dark magic focus of at least 3 to learn that.\n\r", ch);
        return FALSE;
      }
    }

    if (skill == SKILL_CLOUDSUMMON) {
      if (get_skill(ch, SKILL_NATURALMAGICFOCUS) < 2) {
        if (show == TRUE)
        send_to_char("You need natural magic focus of at least 2 to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if(skill == SKILL_ENDOWMENT) {
      if(college_student(ch, TRUE) == FALSE) {
        if(show == TRUE)
        send_to_char("That skill is useless for non students.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_WEALTH) {
      if (value > prof_focus(ch)) {
        if (show == TRUE)
        printf_to_char(
        ch, "You need professional focus of at least %d to learn that.\n\r", value);
        return FALSE;
      }
      if (value > get_tier(ch)) {
        if (show == TRUE)
        printf_to_char(ch, "You need tier of at least %d to learn that.\n\r", value);
        return FALSE;
      }
    }
    if (skill == SKILL_CHARISMA) {
      if (value > prof_focus(ch)) {
        if (show == TRUE)
        printf_to_char(
        ch, "You need professional focus of at least %d to learn that.\n\r", value);
        return FALSE;
      }
    }
    if (skill == SKILL_ART || skill == SKILL_ART2 || skill == SKILL_ART3) {
      if (value >= 3 && prof_focus(ch) < 3) {
        if (show == TRUE)
        send_to_char("You need professional focus of at least 3 to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_STRENGTH) {
      if (value >= 1 && !is_super(ch) && combat_focus(ch) < 1 && (ch->modifier != MODIFIER_TEMPLE || is_super(ch))) {
        if (show == TRUE)
        send_to_char("You need to be supernatural or have combat focus of at least 1 to learn that.\n\r", ch);
        return FALSE;
      }
      if (value >= 3) {
        if (get_skill(ch, SKILL_DEMIWARRIORFOCUS) < 1 && get_skill(ch, SKILL_DEMONWARRIORFOCUS) < 1
        && get_skill(ch, SKILL_ANGELCHAMPIONFOCUS) < 3 && get_tier(ch) < 4) {
          if (show == TRUE)
          send_to_char("You need to be a demigod warrior, demonborn warrior, tier 4, or have angelborn champion at 3 to learn that.\n\r", ch);
          return FALSE;
        }
      }
      if (value >= 4) {
        if (get_skill(ch, SKILL_DEMIWARRIORFOCUS) < 3 && get_skill(ch, SKILL_DEMONWARRIORFOCUS) < 4) {
          if (show == TRUE)
          send_to_char("You need demigod warrior focus of 3 or demonborn warrior focus of 4 to learn that.\n\r", ch);
          return FALSE;
        }
      }
    }
    if (skill == SKILL_DEXTERITY) {
      if (value > 0) {
        if (get_skill(ch, SKILL_BLADEDISCFOCUS) < 1 && get_skill(ch, SKILL_GUNDISCFOCUS) < 1 && get_tier(ch) < 3) {
          if (show == TRUE)
          send_to_char("You need to be a gun or blade disciple or tier 3 to learn that.\n\r", ch);
          return FALSE;
        }
      }
      if (value > 1) {
        if (get_skill(ch, SKILL_BLADEDISCFOCUS) < 3 && get_skill(ch, SKILL_GUNDISCFOCUS) < 3) {
          if (show == TRUE)
          send_to_char("You need gun or blade disciple at 3 to learn that.\n\r", ch);
          return FALSE;
        }
      }
    }
    if (skill == SKILL_ACROBATICS) {
      if (value >= 1 && get_tier(ch) < 2) {
        if (show == TRUE)
        send_to_char("You need to be at least tier two to learn that.\n\r", ch);
        return FALSE;
      }
      if (value >= 2 && get_tier(ch) < 3) {
        if (show == TRUE)
        send_to_char("You need to be at least tier three to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_RUNNING) {
      if (value >= 2) {
        if (!is_angelborn(ch) && get_tier(ch) < 3) {
          if (show == TRUE)
          send_to_char("You need to be at least tier three or an angelborn to learn that.\n\r", ch);
          return FALSE;
        }
      }
      if (value >= 3) {
        if (get_skill(ch, SKILL_ANGELCHAMPIONFOCUS) < 2 && combat_focus(ch) < 4) {
          if (show == TRUE)
          send_to_char("You need at least 4 points into combat focus or to have angelborn champion focus of 2 to learn that.\n\r", ch);
          return FALSE;
        }
      }
      if (value >= 4) {
        if (get_skill(ch, SKILL_ANGELCHAMPIONFOCUS) < 4) {
          if (show == TRUE)
          send_to_char("You need angelborn champion focus at at least 4 to learn that.\n\r", ch);
          return FALSE;
        }
      }
    }
    if (skill == SKILL_STAMINA) {
      if (value >= 2) {
        if (get_tier(ch) < 3 && !is_demigod(ch) && combat_focus(ch) < 1) {
          if (show == TRUE)
          send_to_char("You need to be a demigod or tier 3 or have 1 point of combat focus to learn that.\n\r", ch);
          return FALSE;
        }
      }
      if (value >= 3) {
        if (combat_focus(ch) < 4 && get_skill(ch, SKILL_DEMIWARRIORFOCUS) < 2 && get_skill(ch, SKILL_DEMONWARRIORFOCUS) < 3) {
          if (show == TRUE)
          send_to_char("You need 4 points in combat focus, or demigod warrior focus 2, or demon warrior focus 3 to learn that.\n\r", ch);
          return FALSE;
        }
      }
      if (value >= 4) {
        if (get_skill(ch, SKILL_DEMIWARRIORFOCUS) < 4) {
          if (show == TRUE)
          send_to_char("You need at to have demigod warrior focus at 4 to learn that.\n\r", ch);
          return FALSE;
        }
      }
    }

    if (skill == SKILL_FASTREFLEXES) {
      if (value >= 1) {
        if (get_tier(ch) < 3 && get_skill(ch, SKILL_GUNDISCFOCUS) < 2 && get_skill(ch, SKILL_BLADEDISCFOCUS) < 2) {
          if (show == TRUE)
          send_to_char("You need to be tier 3 or have blade or gun discipline focus at 2 to learn that.\n\r", ch);
          return FALSE;
        }
      }
      if (value >= 2) {
        if (get_skill(ch, SKILL_GUNDISCFOCUS) < 4 && get_skill(ch, SKILL_BLADEDISCFOCUS) < 4) {
          if (show == TRUE)
          send_to_char("You need to have gun or blade discipline focus at 4 to learn that.\n\r", ch);
          return FALSE;
        }
      }
    }
    if (skill == SKILL_MARTIALART || skill == SKILL_COMBATTRAINING || skill == SKILL_DODGING || skill == SKILL_EVADING) {
      if (value >= 1) {
        if (!is_super(ch) && combat_focus(ch) < 1) {
          if (show == TRUE)
          send_to_char("You need to be supernatural or have 1 point in combat focuses to learn that.\n\r", ch);
          return FALSE;
        }
      }
      if (value >= 2) {
        if (value >= combat_focus(ch) && value >= get_tier(ch)) {
          if (show == TRUE)
          printf_to_char(ch, "You need to be tier %d or have combat focus %d to learn that.\n\r", value + 1, value + 1);
          return FALSE;
        }
      }
    }
    if (skill == SKILL_EDUCATION) {
      if (value >= 2) {
        if (value > prof_focus(ch) + 1 && ch->race != RACE_FACULTY) {
          if (show == TRUE)
          printf_to_char(ch, "You'd need professional focus of %d or to be Institute Staff to learn that.\n\r", value - 1);
          return FALSE;
        }
      }
    }
    if (skill == SKILL_CRYPTOMIND) {
      if (get_tier(ch) < 3) {
        if (show == TRUE)
        send_to_char("You need to be at least tier 3 to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_DEMOLITIONS) {
      if (value >= 1) {
        if (get_skill(ch, SKILL_SOLDIERFOCUS) < 1 && get_skill(ch, SKILL_ENGINEERFOCUS) < 1
        && get_skill(ch, SKILL_MOGULFOCUS) < 1 && get_skill(ch, SKILL_GENERALFOCUS) < 1) {
          if (show == TRUE)
          send_to_char("You need soldier focus, engineer focus, commander focus or underworld mogul focus to learn that.\n\r", ch);
          return FALSE;
        }
      }
      if (value >= 2) {
        if (get_skill(ch, SKILL_SOLDIERFOCUS) < 3 && get_skill(ch, SKILL_ENGINEERFOCUS) < 3) {
          if (show == TRUE)
          send_to_char("You need soldier or engineer focus at 3 to learn that.\n\r", ch);
          return FALSE;
        }
        if(get_tier(ch) < 3) {
          if (show == TRUE)
          send_to_char("You need tier 3 to learn that.\n\r", ch);
          return FALSE;
        }
      }
    }
    if (skill == SKILL_HACKING) {
      if (value >= 2) {
        if (get_skill(ch, SKILL_THIEFFOCUS) < 1 && get_skill(ch, SKILL_ASSASSINFOCUS) < 1
        && get_skill(ch, SKILL_SCIENCEFOCUS) < 1 && get_skill(ch, SKILL_ENGINEERFOCUS) < 1) {
          if (show == TRUE)
          send_to_char("You need thief, hunter, scientist, or engineer focus to learn that.\n\r", ch);
          return FALSE;
        }
      }
      if (value >= 3) {
        if (value > get_skill(ch, SKILL_ENGINEERFOCUS) + 1) {
          if (show == TRUE)
          printf_to_char(ch, "You need engineer focus of %d to learn that.\n\r", value - 1);
          return FALSE;
        }
      }
    }
    if (skill == SKILL_STEALTH) {
      if (value >= 2) {
        if (!is_faeborn(ch) && get_skill(ch, SKILL_THIEFFOCUS) < 1 && get_skill(ch, SKILL_ASSASSINFOCUS) < 1
        && get_skill(ch, SKILL_ILLUSORYMAGICFOCUS) < 2) {
          if (show == TRUE)
          send_to_char("You need to be faeborn, or have thief or hunter focus at 1, or illusory magic focus at 2 to learn that.\n\r", ch);
          return FALSE;
        }
      }
      if (value >= 3) {
        if (value > get_skill(ch, SKILL_THIEFFOCUS) + 1 && value > get_skill(ch, SKILL_ASSASSINFOCUS) + 1
        && value > get_skill(ch, SKILL_ILLUSORYMAGICFOCUS)) {
          if (show == TRUE)
          printf_to_char(ch, "You'd need hunter or thief focus of %d or illusory magic focus of %d to learn that.\n\r", value - 1, value);
          return FALSE;
        }
        if(value > get_tier(ch)) {
          if (show == TRUE)
          send_to_char("You need to be at least tier 3 to learn that.\n\r"
          ,ch);
          return FALSE;


        }
      }
    }
    if (skill == SKILL_PERCEPTION) {
      if (value >= 2) {
        if (get_tier(ch) < 3 && !is_demigod(ch) && !is_angelborn(ch)) {
          if (show == TRUE)
          send_to_char("You'd need tier 3, or demigod, or angelborn to learn that.\n\r", ch);
          return FALSE;
        }
      }
      if (value >= 3) {
        if (value >= get_tier(ch)) {
          if (show == TRUE)
          printf_to_char(ch, "You'd need to be at least tier %d to learn that.\n\r", value + 1);
          return FALSE;
        }
      }
    }
    if (skill == SKILL_MEDICINE) {
      if (value >= 2) {
        if (value > get_skill(ch, SKILL_SCIENCEFOCUS) + 1) {
          if (show == TRUE)
          printf_to_char(
          ch, "You'd need scientist focus of at least %d to learn that.\n\r", value - 1);
          return FALSE;
        }
      }
    }
    if (skill == SKILL_ENGINEERING) {
      if (value >= 2) {
        if (value > get_skill(ch, SKILL_ENGINEERFOCUS) + 1) {
          if (show == TRUE)
          printf_to_char(
          ch, "You'd need engineer focus of at least %d to learn that.\n\r", value - 1);
          return FALSE;
        }
      }
    }
    if (skill == SKILL_LARCENY) {
      if (value >= 2) {
        if (get_skill(ch, SKILL_MOGULFOCUS) < 1 && get_skill(ch, SKILL_THIEFFOCUS) < 1) {
          if (show == TRUE)
          send_to_char("You'd need to have underworld mogul, or thief.\n\r", ch);
          return FALSE;
        }
      }
      if(value > get_tier(ch)) {
        if (show == TRUE)
        send_to_char("You'd need to be higher tier for that.\n\r", ch);
        return FALSE;
      }
      if (value >= 3) {
        if (get_skill(ch, SKILL_THIEFFOCUS) < 1) {
          if (show == TRUE)
          send_to_char("You'd need thief focus of 1.\n\r", ch);
          return FALSE;
        }
      }
      if (value >= 4) {
        if (get_skill(ch, SKILL_THIEFFOCUS) < 2) {
          if (show == TRUE)
          send_to_char("You'd need thief focus of 2 to learn that.\n\r", ch);
          return FALSE;
        }
      }
    }
    if (skill == SKILL_ANIMALS) {
      if (value >= 3) {
        if (get_skill(ch, SKILL_PRIMALFOCUS) < 1 && get_skill(ch, SKILL_NATURALMAGICFOCUS) < 2) {
          if (show == TRUE)
          send_to_char("You'd need primal focus of 2 or natural magic focus of 2 to learn that.\n\r", ch);
          return FALSE;
        }
      }
    }
    if (skill == SKILL_GAMES) {
      if (value >= 2) {
        if (!is_faeborn(ch)) {
          if (show == TRUE)
          send_to_char("You'd need to be faeborn to learn that.\n\r", ch);
          return FALSE;
        }
      }
    }
    if (skilltype(skill) == STYPE_CONTACTS) {
      if (ch->pcdata->job_type_one == JOB_EMPLOYEE) {
        if (show == TRUE)
        printf_to_char(ch, "Employees cannot have contacts.\n\r", ch);
        return FALSE;
      }
      if (raw_skillcount(ch, STYPE_CONTACTS) > 4 || (raw_skillcount(ch, STYPE_CONTACTS) == 4 && value == 0)) {
        if (show == TRUE)
        printf_to_char(ch, "You already have four contacts.\n\r", ch);
        return FALSE;
      }
      if (value >= 1) {
        if (value > prof_focus(ch)) {
          if (show == TRUE)
          printf_to_char(
          ch, "You need professional focus of at least %d to learn that.\n\r", value);
          return FALSE;
        }
        if(value > get_tier(ch)) {
          if (show == TRUE)
          printf_to_char(
          ch, "You need tier of at least %d to learn that.\n\r", value);
          return FALSE;
        }
      }
      if(raw_skillcount_level(ch, STYPE_CONTACTS) + 1 > get_tier(ch)*get_tier(ch))
      {
        if (show == TRUE)
        printf_to_char(ch, "You need to be tier %d to learn that.\n\r", get_tier(ch)+1);
        return FALSE;
      }

    }
    if (skill == SKILL_DEMONOLOGY) {
      if (value >= 2) {
        if (value > arcane_focus(ch) + 1) {
          if (show == TRUE)
          printf_to_char(
          ch, "You need arcane focus of at least %d to learn that.\n\r", value - 1);
          return FALSE;
        }
      }
    }
    if (skill == SKILL_MINIONS) {
      if (value >= arcane_focus(ch) || value > get_tier(ch) || (!is_super(ch) && ch->race != RACE_GIFTED)) {
        if (show == TRUE)
        printf_to_char(
        ch, "You need arcane focus of at least %d to learn that.\n\r", value + 1);
        return FALSE;
      }
    }

    if (skill == SKILL_INCANTATION) {
      if (value >= arcane_focus(ch)) {
        if (show == TRUE)
        printf_to_char(
        ch, "You need arcane focus of at least %d to learn that.\n\r", value + 1);
        return FALSE;
      }
    }
    if (skill == SKILL_ALCHEMY || skill == SKILL_RITUALISM) {
      if (value >= 1) {
        if ((ch->race != RACE_GIFTED && !is_super(ch)) && skill == SKILL_RITUALISM) {
          if (show == TRUE)
          printf_to_char(ch, "You need to be supernatural to learn that.\n\r", ch);
          return FALSE;
        }
        if (value > arcane_focus(ch)) {
          if (show == TRUE)
          printf_to_char(
          ch, "You need arcane focus of at least %d to learn that.\n\r", value);
          return FALSE;
        }
      }
    }
    if (skill == SKILL_CONDITIONING) {
      if(ch->skills[SKILL_BEAUTY] == value + 1 || ch->skills[SKILL_FASHION] == value +1) {
        if (show == TRUE)
        printf_to_char(
        ch, "You need to raise your other attractiveness skills first.\n\r");
        return FALSE;
      }
    }
    if (skill == SKILL_BEAUTY) {
      if(ch->skills[SKILL_CONDITIONING] == value + 1 || ch->skills[SKILL_FASHION] == value +1) {
        if (show == TRUE)
        printf_to_char(
        ch, "You need to raise your other attractiveness skills first.\n\r");
        return FALSE;
      }
    }
    if (skill == SKILL_FASHION) {
      if(ch->skills[SKILL_BEAUTY] == value + 1 || ch->skills[SKILL_CONDITIONING] == value +1) {
        if (show == TRUE)
        printf_to_char(
        ch, "You need to raise your other attractiveness skills first.\n\r");
        return FALSE;
      }
    }

    if (skill == SKILL_GLIDE) {
      if (get_skill(ch, SKILL_ANGELCHAMPIONFOCUS) < 4) {
        if (show == TRUE)
        send_to_char("You need angelic champion focus of 4 to learn that.\n\r", ch);
        return FALSE;
      }
      if (ch->skills[SKILL_SUPERJUMP] <= 0) {
        if (show == TRUE)
        send_to_char("You need to get super jumping first to attain the nessesary height to glide.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_FLUIDSHIFT) {
      if (get_skill(ch, SKILL_FAEKNIGHTFOCUS) < 4) {
        if (show == TRUE)
        send_to_char("You need fae knight focus of 4 to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_DUALASPECT) {
      if (get_skill(ch, SKILL_DEMIWARRIORFOCUS) < 4) {
        if (show == TRUE)
        send_to_char("You need demigod warrior focus of 4 to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_DEMONMETABOL) {
      if (get_skill(ch, SKILL_DEMONWARRIORFOCUS) < 4) {
        if (show == TRUE)
        send_to_char("You need demon warrior focus of 4 to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_VICIOUSSTRIKES) {
      if (get_skill(ch, SKILL_PRIMALFOCUS) < 4) {
        if (show == TRUE)
        send_to_char("You need primal focus of 4 to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_BLADEDEFENSE) {
      if (get_skill(ch, SKILL_BLADEDISCFOCUS) < 4) {
        if (show == TRUE)
        send_to_char("You need blade disciple focus of 4 to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_QUICKRELOAD) {
      if (get_skill(ch, SKILL_GUNDISCFOCUS) < 4) {
        if (show == TRUE)
        send_to_char("You need gun disciple focus of 4 to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_ILLUSORYAFFINITY) {
      if (get_skill(ch, SKILL_ILLUSORYMAGICFOCUS) < 4) {
        if (show == TRUE)
        send_to_char("You need illusory magic focus of 4 to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_NATURALAFFINITY) {
      if (get_skill(ch, SKILL_NATURALMAGICFOCUS) < 4) {
        if (show == TRUE)
        send_to_char("You need natural magic focus of 4 to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_MAGICOVERLOAD) {
      if (get_skill(ch, SKILL_DARKMAGICFOCUS) < 4) {
        if (show == TRUE)
        send_to_char("You need a dark magic focus of 4 to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_DUALELEMENTS) {
      if (get_skill(ch, SKILL_ELEMAGICFOCUS) < 4) {
        if (show == TRUE)
        send_to_char("You need elemental magic focus of 4 to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_SNIPERTRAINING) {
      if (get_skill(ch, SKILL_SOLDIERFOCUS) < 3) {
        if (show == TRUE)
        send_to_char("You need soldier focus of 3 to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_RIPOSTE) {
      if (get_skill(ch, SKILL_WARRIORFOCUS) < 3) {
        if (show == TRUE)
        send_to_char("You need warrior focus of 3 to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_PARALYTIC) {
      if (get_skill(ch, SKILL_ASSASSINFOCUS) < 1) {
        if (show == TRUE)
        send_to_char("You need hunter focus of 1 to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_POISONTOXIN) {
      if (get_skill(ch, SKILL_ASSASSINFOCUS) < 3) {
        if (show == TRUE)
        send_to_char("You need hunter focus of 3 to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_GIANTSLAYER) {
      if (combat_focus(ch) < 4) {
        if (show == TRUE)
        send_to_char("You need combat focus of 4 to learn that.\n\r", ch);
        return FALSE;
      }
    }

    if (skill == SKILL_SEDUCE || skill == SKILL_ENRAGE || skill == SKILL_RAGEFUELED || skill == SKILL_NIGHTMARE || skill == SKILL_WAILING) {
      if (!is_demonborn(ch)) {
        if (show == TRUE)
        send_to_char("You must be demonborn to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_STORMCALLING || skill == SKILL_OCEANAFFINITY || skill == SKILL_SOLARBLESS || skill == SKILL_LUNARBLESS || skill == SKILL_DEATHTOUCH || skill == SKILL_WARBLESS || skill == SKILL_FERTILITY) {
      if (!is_demigod(ch)) {
        if (show == TRUE)
        send_to_char("You must be a demigod to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_LUCKCHANGE || skill == SKILL_MERSHIFTER || skill == SKILL_BLOOMING || skill == SKILL_SIRENSONG || skill == SKILL_SENSEWEAKNESS) {
      if (!is_faeborn(ch)) {
        if (show == TRUE)
        send_to_char("You must be a faeborn to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_GUARDIAN || skill == SKILL_FLEETFOOT || skill == SKILL_SOOTHING) {
      if (!is_angelborn(ch)) {
        if (show == TRUE)
        send_to_char("You must be an angelborn to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_FAEBORN || skill == SKILL_DEMIGOD || skill == SKILL_ANGELBORN || skill == SKILL_DEMONBORN) {
      if (is_sufferingsensitive(ch) || is_angelborn(ch) || is_demigod(ch) || is_faeborn(ch) || is_vampire(ch) || is_werewolf(ch) || ch->race == RACE_GIFTED) {
        if (show == TRUE)
        send_to_char("You already have a supernautral heritage.\n\r", ch);
        return FALSE;
      }
    }
    if (skill == SKILL_TOUCHED) {
      if (is_super(ch)) {
        if (show == TRUE)
        send_to_char("You must be a natural human to learn that.\n\r", ch);
        return FALSE;
      }
    }
    if (skilltype(skill) == STYPE_ABOMINATION && !IS_FLAG(ch->act, PLR_SINSPIRIT)) {
      if (get_tier(ch) == 4 && skillbase_count(ch, STYPE_ABOMINATION) > 0) {
        if (show == TRUE)
        send_to_char("You can only have one legendary power at your tier.\n\r", ch);
        return FALSE;
      }
      if (get_tier(ch) >= 5 && skillbase_count(ch, STYPE_ABOMINATION) > 1) {
        if (show == TRUE)
        send_to_char("You can only have two legendary powers at your tier.\n\r", ch);
        return FALSE;
      }

      if (get_tier(ch) < 4) {
        if (show == TRUE)
        send_to_char("You aren't high enough tier for legendary powers.\n\r", ch);
        return FALSE;
      }
    }

    if (skilltype(skill) == STYPE_SABILITIES) {
      if (!is_super(ch) && ch->race != RACE_GIFTED && (skill != SKILL_ELECTROPATHIC || ch->modifier != MODIFIER_TEMPLE) && skill != SKILL_PSYCHIC) {
        if (show == TRUE)
        send_to_char("You'd need to be a supernatural to gain that power.\n\r", ch);
        return FALSE;
      }
    }

    if (skilltype(skill) == STYPE_SUPERNATURAL || skilltype(skill) == STYPE_DEFENSE) {
      if (!is_super(ch) && (skill != SKILL_ELECTROPATHIC || ch->modifier != MODIFIER_TEMPLE) && (skill != SKILL_TELEMPATHY && skill != SKILL_TELEPATHY && skill != SKILL_MINDREADING && skill != SKILL_DREAMING && skill != SKILL_SPLITMIND)) {
        if (show == TRUE)
        send_to_char("You'd need to be a supernatural to gain that power.\n\r", ch);
        return FALSE;
      }
    }

    if ((skilltype(skill) == STYPE_PHYSICAL || skilltype(skill) == STYPE_SPECIALIZATION) && !IS_FLAG(ch->act, PLR_GUEST) && !is_abom(ch)) {
      int cap = human_cap(skill);
      if (ch->modifier == MODIFIER_TEMPLE && !is_super(ch))
      cap++;
      if (level > cap && !is_super(ch)) {
        if (show == TRUE)
        send_to_char("Humans cannot be that strong.\n\r", ch);
        return FALSE;
      }
    }

    return TRUE;
  }

  bool can_train_disc(CHAR_DATA *ch, int disc) {
    int cap = 0;
    int defense_total = 0;
    int mundane_total = 0;
    int super_total = 0;

    if (guestmonster(ch) || higher_power(ch))
    return TRUE;

    if (!is_super(ch) && ch->modifier == MODIFIER_TEMPLE && (disc == DIS_TOUGHNESS || disc == DIS_BONES)) {
      if (ch->disciplines[DIS_TOUGHNESS] + ch->disciplines[DIS_BONES] >= 10)
      return FALSE;
      return TRUE;
    }
    if (!is_undead(ch) && disc == DIS_UNDEAD)
    return FALSE;

    for (int i = 0; i < DIS_USED; i++) {
      if (ch->disciplines[discipline_table[i].vnum] > 0) {
        if (discipline_table[i].range == -1) {
          defense_total += ch->disciplines[discipline_table[i].vnum];
          if (discipline_table[i].vnum == DIS_MARMOR || discipline_table[i].vnum == DIS_BARMOR || discipline_table[i].vnum == DIS_MARMOR || discipline_table[i].vnum == DIS_MSHIELD || discipline_table[i].vnum == DIS_BSHIELD)
          mundane_total += ch->disciplines[discipline_table[i].vnum];
          else
          super_total += ch->disciplines[discipline_table[i].vnum];
        }
      }
    }

    if (disc == DIS_MARMOR || disc == DIS_BARMOR || disc == DIS_MSHIELD || disc == DIS_BSHIELD) {
      cap = 25 + UMIN(combat_focus(ch), get_tier(ch)) * 5;
      if (mundane_total >= cap)
      return FALSE;
      return TRUE;
    }
    else if (disc == DIS_TOUGHNESS || disc == DIS_BONES || disc == DIS_FORCES || disc == DIS_UNDEAD || disc == DIS_FATE || disc == DIS_PUSH || disc == DIS_UNDEAD) {
      if (!is_super(ch))
      return FALSE;
      cap = 0;
      if (get_tier(ch) == 2) {
        if (get_skill(ch, SKILL_MENTALDISCIPLINE) > 0)
        cap = 15;
        else
        cap = 10;
      }
      if (get_tier(ch) == 3) {
        if (get_skill(ch, SKILL_MENTALDISCIPLINE) > 0)
        cap = 30;
        else
        cap = 20;
      }
      if (get_tier(ch) == 4) {
        cap = 50;
      }
      if (get_tier(ch) == 5)
      cap = 100;
      if (super_total >= cap)
      return FALSE;
      return TRUE;
    }

    if (disc == DIS_STRIKING || disc == DIS_GRAPPLE) {
      cap = 10 + UMIN(combat_focus(ch), get_tier(ch)) * 5;
      if (ch->disciplines[disc] >= cap)
      return FALSE;
      return TRUE;
    }
    if (disc == DIS_KNIFE || disc == DIS_LONGBLADE || disc == DIS_BLUNT || disc == DIS_SPEAR) {
      cap = 20;
      if (get_tier(ch) == 2) {
        if (get_skill(ch, SKILL_MENTALDISCIPLINE) > 0)
        cap = 35;
        else
        cap = 30;
      }
      if (get_tier(ch) == 3) {
        if (get_skill(ch, SKILL_MENTALDISCIPLINE) > 0)
        cap = 60;
        else
        cap = 40;
      }
      if (get_tier(ch) == 4) {
        cap = 80;
      }
      if (get_tier(ch) == 5)
      cap = 120;
      if (ch->disciplines[disc] >= cap)
      return FALSE;
      return TRUE;
    }
    
    if (disc == DIS_PISTOLS || disc == DIS_RIFLES || disc == DIS_BOWS || disc == DIS_THROWN || disc == DIS_SHOTGUNS || disc == DIS_CARBINES || disc == DIS_SPEARGUN) {
      cap = 50;
      if (get_tier(ch) == 2) {
        if (get_skill(ch, SKILL_MENTALDISCIPLINE) > 0)
        cap = 65;
        else
        cap = 60;
      }
      if (get_tier(ch) == 3) {
        if (get_skill(ch, SKILL_MENTALDISCIPLINE) > 0)
        cap = 75;
        else
        cap = 70;
      }
      if (get_tier(ch) == 4) {
        cap = 80;
      }
      if (get_tier(ch) == 5)
      cap = 100;
      if (ch->disciplines[disc] >= cap)
      return FALSE;
      return TRUE;
    }
    return FALSE;
  }

  int train_disc_cost(CHAR_DATA *ch, int disc) {
    int point = 0, shield_total = 0;
    for (int i = 0; i < DIS_USED; i++) {
      if (ch->disciplines[discipline_table[i].vnum] > 0) {
        if (discipline_table[i].range == -1)
        shield_total += ch->disciplines[discipline_table[i].vnum];
      }
      if (discipline_table[i].vnum == disc)
      point = i;
    }
    int value = ch->disciplines[disc];
    if (discipline_table[point].range == -1)
    value = shield_total;
    value++;
    int cost = value * BASE_DISC_COST;
    return cost;
  }

  int train_skill_cost(CHAR_DATA *ch, int skill, int method) {
    int pointer = -1, trains;
    for (int i = 0; i < SKILL_USED; i++) {
      if (skill_table[i].vnum == skill) {
        if (ch->skills[skill] == 0) {
          if (skill_table[i].levels[0] == -1)
          trains = 1;
          else
          trains = skillpoint(skill_table[i].levels[0]);
        }
        else {
          for (int j = 0; j < 6; j++) {
            if (ch->skills[skill] == skill_table[i].levels[j] && pointer == -1) {
              pointer = j;
            }
          }

          if (pointer == -1 || pointer == 5)
          return 0;

          if (skill_table[i].levels[pointer + 1] == 0)
          return 0;
          int difference = skillpoint(skill_table[i].levels[pointer + 1]) -
          skillpoint(skill_table[i].levels[pointer]);
          if (ch->skills[skill] == -1)
          trains = 1;
          else
          trains = difference;
        }

        if (skill_table[i].vnum == SKILL_ENDOWMENT && college_group(ch, FALSE) == COLLEGE_PREP)
        return trains * BASE_STAT_COST * stat_cost_mod(ch, method) / 150;

        if (skill_table[i].vnum == SKILL_ART && college_group(ch, FALSE) == COLLEGE_THEATRE)
        return trains * BASE_STAT_COST * stat_cost_mod(ch, method) / 150;
        if (skill_table[i].vnum == SKILL_ART2 && college_group(ch, FALSE) == COLLEGE_THEATRE)
        return trains * BASE_STAT_COST * stat_cost_mod(ch, method) / 150;
        if (skill_table[i].vnum == SKILL_ART3 && college_group(ch, FALSE) == COLLEGE_THEATRE)
        return trains * BASE_STAT_COST * stat_cost_mod(ch, method) / 150;

        return trains * BASE_STAT_COST * stat_cost_mod(ch, method) / 100;
      }
    }
    return 0;
  }

  _DOFUN(do_train) {
    int i, cost, tpoints = 0, points, orig, j;
    char name[MSL];
    CHAR_DATA *target;

    if (IS_FLAG(ch->act, PLR_BOUND) || in_fight(ch) || room_hostile(ch->in_room)) {
      send_to_char("Not now.\n\r", ch);
      return;
    }
    if (IS_FLAG(ch->act, PLR_STASIS)) {
      send_to_char("You cannot do that to a character in stasis.\n\r", ch);
      return;
    }

    if (ch->in_room->vnum == ROOM_INDEX_GENESIS) {
      send_to_char("Not yet.\n\r", ch);
      return;
    }

    if (is_gm(ch) && !IS_IMMORTAL(ch)) {
      send_to_char("You're a storyrunner.\n\r", ch);
      return;
    }
    if (safe_strlen(argument) < 2) {
      int point;
      if (ch->pcdata->training_disc > 0) {
        for (int i = 0; i < DIS_USED; i++) {
          if (ch->pcdata->training_disc == discipline_table[i].vnum)
          point = i;
        }
        printf_to_char(ch, "You are currently training %s.\n\r", discipline_table[point].name);
      }
      return;
    }
    if (!str_cmp(argument, "stop")) {
      if (ch->pcdata->training_disc != 0)
      ch->pcdata->account->xp =
      UMAX(ch->pcdata->account->xp - 2500, ch->pcdata->account->xp * 4 / 5);
      ch->pcdata->training_stat = 0;
      ch->pcdata->training_disc = 0;
      send_to_char("You stop training.\n\r", ch);
      return;
    }
    if (ch->pcdata->rerollselftime > current_time + (3600 * 24 * 30 * 3))
    ch->pcdata->rerollselftime = 0;
    if (ch->pcdata->rerollselftime > current_time - (3600 * 24 * 60)) {
      send_to_char("You reset this character too recently.\n\r", ch);
      return;
    }
    if (IS_IMMORTAL(ch)) {
      char *backup;
      backup = str_dup(argument);
      argument = one_argument_nouncap(argument, name);
      if ((target = get_char_world(ch, name)) == NULL || IS_NPC(target)) {
        send_to_char("Can't locate player.  Searching for a stat or discipline...\n\r", ch);
        argument = str_dup(backup);
        target = ch;
      }
    }
    else {
      target = ch;
    }

    // ghosts should be the same as when they died - Discordance
    if (is_dead(target)) {
      send_to_char("You are as the day you died.\n\r", ch);
      return;
    }
    else if (is_ghost(target) && !higher_power(target)) {
      send_to_char("You're out of your body.\n\r", ch);
      return;
    }

    if (target->played / 3600 > 15 && safe_strlen(target->pcdata->history) < 250) {
      send_to_char("Your character needs a history before training anymore, type history to write one.\n\r", ch);
      return;
    }
    alter_character(ch);
    for (i = 0; i < DIS_USED; i++) {
      if (!str_cmp(argument, discipline_table[i].name) && (discipline_table[i].pc == 1 || guestmonster(target))) {
        if (target->race == RACE_CIVILIAN) {
          send_to_char("Innocents are non combat characters.\n\r", ch);
          return;
        }
        if (discipline_table[i].pc < 1 && !guestmonster(target)) {
          send_to_char("That discipline can't be trained by PCs.\n\r", ch);
          return;
        }
        if (!can_train_disc(target, discipline_table[i].vnum)) {
          send_to_char("You're already at your limit for that discipline.\n\r", ch);
          return;
        }
        if (IS_IMMORTAL(ch)) {
          target->disciplines[discipline_table[i].vnum]++;
          printf_to_char(target, "You train %s.\n\r", discipline_table[i].name);
          return;
        }
        cost = train_disc_cost(target, discipline_table[i].vnum);

        if (cost < 1)
        return;

        if (target->spentexp + target->spentnewexp >= target->pcdata->exp_cap && !IS_FLAG(target->act, PLR_GUEST)) {
          if (ch->pcdata->training_disc != 0 && ch->pcdata->training_disc != discipline_table[i].vnum) {
            ch->pcdata->account->xp = UMAX(ch->pcdata->account->xp - 2500, ch->pcdata->account->xp * 4 / 5);
          }
          ch->pcdata->training_disc = discipline_table[i].vnum;
          printf_to_char(ch, "You begin working on developing %s.\n\r", discipline_table[i].name);
          return;
        }

        if (cost > available_exp(target)) {
          if (ch->pcdata->training_disc != 0 && ch->pcdata->training_disc != discipline_table[i].vnum) {
            ch->pcdata->account->xp = UMAX(ch->pcdata->account->xp - 2500, ch->pcdata->account->xp * 4 / 5);
          }
          ch->pcdata->training_disc = discipline_table[i].vnum;
          printf_to_char(ch, "You begin working on developing %s.\n\r", discipline_table[i].name);
          return;
        }
        target->disciplines[discipline_table[i].vnum]++;
        charge_exp(target, cost);
        target->pcdata->time_since_train = 0;
        printf_to_char(ch, "You train %s.\n\r", discipline_table[i].name);
        return;
      }
    }
    for (i = 0; i < SKILL_USED; i++) {
      int pointer = 0;
      if (!str_cmp(skill_table[i].name, argument)) {
        if (target->skills[skill_table[i].vnum] == 0) {
          if (skill_table[i].levels[0] == -1)
          points = skill_table[i].levels[1];
          else
          points = skill_table[i].levels[0];
        }
        else if (target->skills[skill_table[i].vnum] == -1) {
          points = 0;
        }
        else {
          for (j = 0; j < 6; j++) {
            if (target->skills[skill_table[i].vnum] == skill_table[i].levels[j])
            pointer = j;
          }
          if (pointer == 5 || (skill_table[i].levels[pointer + 1] == 0 && skill_table[i].levels[pointer] != -1)) {
            send_to_char("You can't raise it that high.\n\r", ch);
            return;
          }
          j = pointer;
          points = skill_table[i].levels[j + 1];
        }

        if (target->skills[skill_table[i].vnum] == -1) {
          tpoints = 1;
          orig = -1;
        }
        else {
          orig = target->skills[skill_table[i].vnum];
          for (j = points; j > orig; j--)
          tpoints += j;
        }

        if (!has_requirements(target, skill_table[i].vnum, tpoints, TRUE)) {
          send_to_char("You don't meet the requirements to raise that.\n\r", ch);
          return;
        }

        if (skilltype(skill_table[i].vnum) == STYPE_ARCANEFOCUS || skilltype(skill_table[i].vnum) == STYPE_COMBATFOCUS
        || skilltype(skill_table[i].vnum) == STYPE_PROFFOCUS) {
          bool thisfound = FALSE;
          bool otherfound = FALSE;
          for (int x = 0; x < 10; x++) {
            if (target->pcdata->previous_focus_vnum[x] > 100 && target->pcdata->previous_focus_vnum[x] < 200
            && target->pcdata->previous_focus_level[x] < 10
            && target->pcdata->previous_focus_level[x] > target->skills[target->pcdata->previous_focus_vnum[x]])
            otherfound = TRUE;
            if (target->pcdata->previous_focus_vnum[x] == skill_table[i].vnum)
            thisfound = TRUE;
          }

          if (otherfound == TRUE && thisfound == FALSE) {
            send_to_char("You have to train the focus you previously had first.\n\r", ch);
            return;
          }
        }

        if(skilltype(skill_table[i].vnum) == STYPE_COMBATFOCUS && ch->fcore == FACTION_HAND)
        {
          if((combat_focus(ch) + 1 ) > 1 && (combat_focus(ch) +1) > arcane_focus(ch) && (combat_focus(ch) + 1) > prof_focus(ch))
          {
            send_to_char("As a manipulative faction the Hand hard restricts characters who are too heavily combat focused. You will need to leave the Hand before training this.\n\r", ch);
            return;
          }
        }
        if(skilltype(skill_table[i].vnum) == STYPE_ARCANEFOCUS && ch->fcore == FACTION_TEMPLE)
        {
          if((arcane_focus(ch) + 1 ) > 1 && (arcane_focus(ch) +1) > combat_focus(ch) && (arcane_focus(ch) + 1) > prof_focus(ch))
          {
            send_to_char("As a faction dedicated to the eradication of magic the Temple hard restricts characters who are too heavily arcane focused. You will need to leave the Temple before training this.\n\r", ch);
            return;
          }
        }
        if(skilltype(skill_table[i].vnum) == STYPE_PROFFOCUS && ch->fcore == FACTION_ORDER)
        {
          if((prof_focus(ch) + 1 ) > 1 && (prof_focus(ch) +1) > arcane_focus(ch) && (prof_focus(ch) + 1) > arcane_focus(ch))
          {
            send_to_char("As a faction adverse to inequality the Order hard restricts characters who are too heavily professionally focused. You will need to leave the Order before training this.\n\r", ch);
            return;
          }
        }


        if (IS_IMMORTAL(ch)) {
          target->skills[skill_table[i].vnum] = points;
          printf_to_char(ch, "You train %s.\n\r", skill_table[i].name);
          return;
        }

        cost = train_skill_cost(target, skill_table[i].vnum, TRAINED_NATURAL);
        if (cost < 1)
        return;

        if (target->spentrpexp + target->spentnewrpexp >=
            target->pcdata->rpexp_cap && !IS_FLAG(target->act, PLR_GUEST)) {
          send_to_char("You're already at your  rpxp cap.\n\r", ch);
          return;
        }
        if (target->skills[skill_table[i].vnum] == -1) {
          if (BASE_STAT_COST > available_rpexp(target)) {
            printf_to_char(ch, "You'd need %d rpxp to train that.\n\r", BASE_STAT_COST);
            return;
          }
          target->skills[skill_table[i].vnum] = 0;
          charge_rpexp(target, BASE_STAT_COST);
          printf_to_char(ch, "You train %s.\n\r", skill_table[i].name);
          return;
        }

        if (cost > available_rpexp(target)) {
          printf_to_char(ch, "You'd need %d rpxp to train that.\n\r", cost);
          return;
        }
        target->pcdata->training_stage = 1;
        target->pcdata->training_stat = skill_table[i].vnum;
        target->pcdata->training_type = 0;
        send_to_char("Please choose how your character would acquire that stat, options are:\n\r", ch);
        if (elligible_training(target, skill_table[i].vnum, TRAINED_SELF))
        send_to_char("self-mastered, ", ch);
        if (elligible_training(target, skill_table[i].vnum, TRAINED_ITEM))
        send_to_char("item, ", ch);
        if (elligible_training(target, skill_table[i].vnum, TRAINED_TAUGHT))
        send_to_char("taught, ", ch);
        if (elligible_training(target, skill_table[i].vnum, TRAINED_FRIEND))
        send_to_char("friendship, ", ch);
        if (elligible_training(target, skill_table[i].vnum, TRAINED_BLACKMAIL))
        send_to_char("blackmail, ", ch);
        if (elligible_training(target, skill_table[i].vnum, TRAINED_MINDCONTROL))
        send_to_char("mind control, ", ch);
        if (elligible_training(target, skill_table[i].vnum, TRAINED_TOOL))
        send_to_char("tool, ", ch);
        if (elligible_training(target, skill_table[i].vnum, TRAINED_JOBLEGAL))
        send_to_char("legitimate job, ", ch);
        if (elligible_training(target, skill_table[i].vnum, TRAINED_JOBBLACKMAIL))
        send_to_char("blackmail acquired job, ", ch);
        if (elligible_training(target, skill_table[i].vnum, TRAINED_JOBMINDCONTROL))
        send_to_char("mind control acquired job, ", ch);
        if (elligible_training(target, skill_table[i].vnum, TRAINED_THEFT))
        send_to_char("theft, ", ch);
        if (elligible_training(target, skill_table[i].vnum, TRAINED_INHERIT))
        send_to_char("inheritance, ", ch);
        if (elligible_training(target, skill_table[i].vnum, TRAINED_DEMON))
        send_to_char("demonic pact, ", ch);
        if (elligible_training(target, skill_table[i].vnum, TRAINED_FAE))
        send_to_char("fae bargain, ", ch);
        if (elligible_training(target, skill_table[i].vnum, TRAINED_BOOK))
        send_to_char("book, ", ch);
        if (elligible_training(target, skill_table[i].vnum, TRAINED_EDULEGIT))
        send_to_char("legitimately, ", ch);
        if (elligible_training(target, skill_table[i].vnum, TRAINED_EDUBRIBE))
        send_to_char("bribery, ", ch);
        if (elligible_training(target, skill_table[i].vnum, TRAINED_EDUFRAUD))
        send_to_char("fraud, ", ch);
        if (elligible_training(target, skill_table[i].vnum, TRAINED_NATURAL))
        send_to_char("natural, ", ch);
        if (elligible_training(target, skill_table[i].vnum, TRAINED_IMPLANT))
        send_to_char("implant, ", ch);
        if (elligible_training(target, skill_table[i].vnum, TRAINED_TATTOO))
        send_to_char("tattoo, ", ch);
      }
    }
  }

  _DOFUN(do_telepath) {
    char arg[MAX_INPUT_LENGTH], buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;

    if (get_skill(ch, SKILL_TELEPATHY) <= 0) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (ch->pcdata->tcooldown > 1000)
    ch->pcdata->tcooldown = 0;
    if (ch->pcdata->tcooldown > 0) {
      send_to_char("You did that too recently.\n\r", ch);
      return;
    }
    if (is_gm(ch) && !IS_IMMORTAL(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }

    if (is_animal(ch) && get_skill(ch, SKILL_NATURALAFFINITY) <= 0 && get_skill(ch, SKILL_ILLUSORYAFFINITY) <= 0) {
      send_to_char("You can't do that while shifted.\n\r", ch);
      return;
    }

    if (silenced(ch))
    return;
    argument = one_argument(argument, arg);

    if (arg[0] == '\0' || argument[0] == '\0') {
      send_to_char("Your thoughts go unheard.\n\r", ch);
      return;
    }

    else if ((victim = get_char_world(ch, arg)) == NULL || (IS_NPC(victim) && victim->in_room != ch->in_room)) {
      send_to_char("Your thoughts go unheard.\n\r", ch);
      return;
    }
    else if (get_world(ch) != get_world(victim)) {
      send_to_char("Your thoughts go unheard.\n\r", ch);
      return;
    }
    else if (is_dead(victim) || is_ghost(victim)) {
      send_to_char("Your thoughts go unheard.\n\r", ch);
      return;
    }

    if (IS_FLAG(ch->act, PLR_DEEPSHROUD) !=
        IS_FLAG(victim->act, PLR_DEEPSHROUD)) {
      send_to_char("Your thoughts go unheard.\n\r", ch);
      return;
    }

    // ghostie check and limit for telepath -Discordance
    if (is_ghost(ch)) {
      if (is_manifesting(ch)) {
        if (deplete_ghostpool(ch, GHOST_MANIFESTATION) == FALSE) {
          send_to_char("You can't muster the strength to project your thoughts any more today.\n\r", ch);
          return;
        }
      }
      else {
        send_to_char("You must be prepared to manifest this power.\n\r", ch);
        return;
      }
    }
    else if (is_dead(ch)) {
      send_to_char("Your thoughts go unheard.\n\r", ch);
      return;
    }

    printf_to_char(ch, "You say into %s's mind '%s`x'\n\r", PERS(victim, ch), argument);
    printf_to_char(victim, "A voice in your head says '%s`x'\n\r", argument);

    triggercheck(victim, argument);
    persuade_check(ch, victim, argument);

    for (DescList::iterator it = descriptor_list.begin();
    it != descriptor_list.end(); ++it) {
      DESCRIPTOR_DATA *d = *it;
      CHAR_DATA *to;
      if (d->character != NULL && d->connected == CON_PLAYING) {
        to = d->character;
        if (IS_NPC(to))
        continue;
        if (to->in_room == NULL || ch->in_room == NULL)
        continue;

        if (get_skill(to, SKILL_MINDREADING) > 0 && number_percent() % 3 == 0 && in_world(ch) == in_world(to)) {
          printf_to_char(to, "You overhear '%s' drifting through the psychic realm.", argument);
          continue;
        }
        if ((!IS_IMMORTAL(to) || !IS_FLAG(to->act, PLR_SPYING) || !can_spy(to, ch)) || IS_FLAG(victim->act, PLR_SPYSHIELD))
        continue;

        printf_to_char(to, "%s telepaths %s: %s\n\r", NAME(ch), NAME(victim), argument);
      }
    }
    char rplog[MSL];
    sprintf(rplog, "%s telepaths %s: %s\n\r", NAME(ch), NAME(victim), argument);
    rp_log(rplog);
    ch->pcdata->tcooldown = 10;

    return;
  }

  _DOFUN(do_illusion) {
    char arg1[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;

    argument = one_argument(argument, arg1);
    if ((victim = get_char_distance(ch, arg1, 2)) == NULL) {
      if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
    }
    if(!is_gm(ch))
    {
      if (get_skill(ch, SKILL_ILLUSIONS) <= 0 && !mindbroken(victim)) {
        send_to_char("You can't do that.\n\r", ch);
        return;
      }
      if (ch->pcdata->tcooldown > 0 && !mindbroken(victim)) {
        send_to_char("You did that too recently.\n\r", ch);
        return;
      }
    }
    if (higher_power(ch) && power_bound(ch) && !IS_NPC(victim) && str_cmp(ch->pcdata->place, victim->pcdata->place)) {
      send_to_char("Your power is bound.\n\r", ch);
      return;
    }

    if (mindwarded(victim)) {
      send_to_char("It doesn't seem to work.\n\r", ch);
      ch->pcdata->tcooldown = 2;
      return;
    }
    process_emote(ch, victim, EMOTE_ILLUSION, argument);
    ch->pcdata->tcooldown = 2;
    send_to_char("You show them an illusion.\n\r", ch);
  }

  _DOFUN(do_cauterize) {
    if (str_cmp(argument, ch->name)) {
      send_to_char("Syntax: cauterize (character name)\n\r", ch);
      return;
    }
    if (ch->pcdata->account->karma < 1000) {
      send_to_char("You'd need at least 1000 karma to do that.\n\r", ch);
      return;
    }
    if (IS_FLAG(ch->act, PLR_WOLFBIT))
    REMOVE_FLAG(ch->act, PLR_WOLFBIT);

    wound_char_absolute(ch, 2);
    ch->pcdata->account->karma -= 1000;
    ch->spentkarma += 500;
    act("You cauterize the bite.", ch, NULL, NULL, TO_CHAR);
    act("$n cauterizes their bite.", ch, NULL, NULL, TO_ROOM);
  }

  _DOFUN(do_lightup) {

    if (get_skill(ch, SKILL_LIGHTUP) <= 0) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }

    // ghostie check and limit for lightup -Discordance
    if (is_ghost(ch)) {
      if (is_manifesting(ch)) {
        if (deplete_ghostpool(ch, GHOST_MANIFESTATION) == FALSE) {
          send_to_char("You can't muster the strength to manifest your will any more today.\n\r", ch);
          return;
        }
      }
      else {
        send_to_char("You must be prepared to manifest this power.\n\r", ch);
        return;
      }
    }

    if (ch->pcdata->litup == 0) {
      ch->pcdata->litup = 1;
      act("$n lights up the room.", ch, NULL, NULL, TO_ROOM);
      act("You light up the room.", ch, NULL, NULL, TO_CHAR);
    }
    else {
      ch->pcdata->litup = 0;
      act("$n stops lighting up the room.", ch, NULL, NULL, TO_ROOM);
      act("You stop lighting up the room.", ch, NULL, NULL, TO_CHAR);
    }
  }

  _DOFUN(do_telempath) {
    char arg[MAX_INPUT_LENGTH], buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;
    char arg2[MSL];

    if (ch->pcdata->tcooldown > 0) {
      send_to_char("You did that too recently.\n\r", ch);
      return;
    }
    if (is_gm(ch) && !IS_IMMORTAL(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }

    argument = one_argument(argument, arg);

    if (arg[0] == '\0' || argument[0] == '\0') {
      send_to_char("Tell whom what?\n\r", ch);
      return;
    }

    bool canfind = TRUE;
    if ((victim = get_char_world(ch, arg)) == NULL || (IS_NPC(victim) && victim->in_room != ch->in_room)) {
      ch->pcdata->tcooldown = 10;
      send_to_char("They aren't here or you can't do that.\n\r", ch);
      canfind = FALSE;
      return;
    }

    if (is_ghost(victim) || is_dead(victim)) {
      canfind = FALSE;
      ch->pcdata->tcooldown = 10;
      send_to_char("They aren't here or you can't do that.\n\r", ch);
      return;
    }
    if (get_skill(ch, SKILL_TELEMPATHY) <= 0 && !mindbroken(victim)) {
      ch->pcdata->tcooldown = 10;
      send_to_char("They aren't here or you can't do that.\n\r", ch);
      return;
    }
    if (higher_power(ch) && power_bound(ch) && !IS_NPC(victim) && str_cmp(ch->pcdata->place, victim->pcdata->place)) {
      send_to_char("Your power is bound.\n\r", ch);
      return;
    }
    if (ch == victim)
    return;

    // ghostie check and limit for telempath -Discordance
    if (is_ghost(ch)) {
      if (is_manifesting(ch)) {
        if (deplete_ghostpool(ch, GHOST_MANIFESTATION) == FALSE) {
          send_to_char("You can't muster the strength to project your emotions any more today.\n\r", ch);
          return;
        }
      }
      else {
        send_to_char("You must be prepared to manifest this power.\n\r", ch);
        return;
      }
    }
    else if (is_dead(ch)) {
      send_to_char("Your thoughts go unheard.\n\r", ch);
      return;
    }

    printf_to_char(ch, "You make %s feel %s.\n\r", PERS(victim, ch), argument);

    if (canfind == TRUE) {
      printf_to_char(victim, "You emotionally feel %s.\n\r", argument);

      for (DescList::iterator it = descriptor_list.begin();
      it != descriptor_list.end(); ++it) {
        DESCRIPTOR_DATA *d = *it;
        CHAR_DATA *to;
        if (d->character != NULL && d->connected == CON_PLAYING) {
          to = d->character;
          if (IS_NPC(to))
          continue;
          if (to->in_room == NULL || ch->in_room == NULL)
          continue;
          if ((!IS_IMMORTAL(to) || !IS_FLAG(to->act, PLR_SPYING) || !can_spy(to, ch)) || IS_FLAG(victim->act, PLR_SPYSHIELD))
          continue;

          printf_to_char(to, "%s makes %s feel: %s\n\r", NAME(ch), NAME(victim), argument);
        }
      }
    }
    char rplog[MSL];
    sprintf(rplog, "%s makes %s feel: %s\n\r", NAME(ch), NAME(victim), argument);
    rp_log(rplog);
    ch->pcdata->tcooldown = 10;

    return;
  }

  _DOFUN(do_trance) {
    CHAR_DATA *victim;

    if ((victim = get_char_room(ch, NULL, argument)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (IS_NPC(victim)) {
      send_to_char("Not on NPCs.\n\r", ch);
      return;
    }
    if (get_skill(ch, SKILL_HYPNOTISM) <= 0) {
      send_to_char("You don't have that skill.\n\r", ch);
      return;
    }
    if (in_fight(ch) || room_hostile(ch->in_room) || in_fistfight(ch) || in_fight(victim) || in_fistfight(victim)) {
      send_to_char("Things seem a little tense for that to work.\n\r", ch);
      return;
    }
    if (is_prisoner(ch) && !is_prisoner(victim)) {
      send_to_char("The guards would stop you.\n\r", ch);
      return;
    }
    if (higher_power(ch) && power_bound(ch) && !IS_NPC(victim) && str_cmp(ch->pcdata->place, victim->pcdata->place)) {
      send_to_char("Your power is bound.\n\r", ch);
      return;
    }
    if (higher_power(victim)) {
      send_to_char("That seems beyond you.\n\r", ch);
      return;
    }

    if (ch->pcdata->tcooldown > 0) {
      send_to_char("You did that too recently.\n\r", ch);
      return;
    }
    if (!IS_IMMORTAL(ch)) {
      if (mindwarded(victim) || is_covered(ch, COVERS_EYES) || is_helpless(ch) || victim->pcdata->trance < 0
      || victim->pcdata->mind_guarded > 0) {
        send_to_char("You can't seem to catch their gaze.\n\r", ch);
        return;
      }
      if (get_skill(victim, SKILL_HYPNOTISM) > 0 && get_tier(victim) > get_tier(ch)) {
        send_to_char("You sense power coming from their gaze and need to look away.\n\r", ch);
        return;
      }
    }
    if (!can_see(victim, ch)) {
      send_to_char("You can't seem to catch their gaze.\n\r", ch);
      return;
    }
    if (!can_see(ch, victim)) {
      send_to_char("You can't seem to catch their gaze.\n\r", ch);
      return;
    }
    if (is_ghost(victim) || is_dead(victim)) {
      send_to_char("You can't hypnotize the dead.\n\r", ch);
      return;
    }
    act("You snag $N's gaze with your eyes and place $M into a trance.", ch, NULL, victim, TO_CHAR);
    act("$n catches $N's gaze for a moment.", ch, NULL, victim, TO_NOTVICT);
    victim->pcdata->trance = 5;
    ch->pcdata->tcooldown = 5;
  }

  int get_language_points(CHAR_DATA *ch) {
    int val = 0;
    if (get_skill(ch, SKILL_LANGUAGE2) > 0)
    val++;
    if (get_skill(ch, SKILL_LANGUAGE3) > 0)
    val++;
    if (get_skill(ch, SKILL_LANGUAGE4) > 0)
    val++;
    if (get_skill(ch, SKILL_LANGUAGE5) > 0)
    val++;
    return val;
  }

  _DOFUN(do_language) {
    char arg1[MSL];
    char arg2[MSL];
    int i;

    argument = one_argument_nouncap(argument, arg1);
    argument = one_argument_nouncap(argument, arg2);

    if (!str_cmp(arg1, "learn")) {

      i = atoi(arg2);
      if (i < 1 || i > get_language_points(ch)) {
        send_to_char("Syntax: language learn <slot> <language>\n\r", ch);
        return;
      }
      i--;

      if (safe_strlen(ch->pcdata->languages[i]) > 3 && ch->played / 3600 > 5) {
        send_to_char("You've already have a language in that slot.\n\r", ch);
        return;
      }

      free_string(ch->pcdata->languages[i]);
      ch->pcdata->languages[i] = str_dup(argument);
      printf_to_char(ch, "You learn the language %s\n\r", ch->pcdata->languages[i]);

    }
    else {
      send_to_char("You can speak.\n\r", ch);
      for (i = 0; i < get_language_points(ch); i++) {
        printf_to_char(ch, "[%d] %s\n\r", i + 1, ch->pcdata->languages[i]);
      }
      if (safe_strlen(ch->pcdata->speaking) > 2)
      printf_to_char(ch, "You are speaking %s.\n\r", ch->pcdata->speaking);
      else
      send_to_char("You are speaking English.\n\r", ch);
    }
  }

  bool knows_language(CHAR_DATA *ch, char *string) {
    int i;
    if (IS_NPC(ch))
    return FALSE;
    if (IS_IMMORTAL(ch))
    return TRUE;
    for (i = 0; i < get_language_points(ch); i++) {
      if (!str_cmp(ch->pcdata->languages[i], string))
      return TRUE;
    }
    return FALSE;
  }

  bool knows_fluent(CHAR_DATA *ch, char *string) {
    int i;
    if (IS_NPC(ch))
    return FALSE;
    if (IS_IMMORTAL(ch))
    return TRUE;
    for (i = 0; i < get_language_points(ch); i++) {
      if (!str_cmp(ch->pcdata->languages[i], string)) {
        if (get_skill(ch, SKILL_LANGUAGE2 + i) >= 3)
        return TRUE;
      }
    }
    return FALSE;
  }
  bool knows_moderate(CHAR_DATA *ch, char *string) {
    int i;
    if (IS_NPC(ch))
    return FALSE;
    if (IS_IMMORTAL(ch))
    return TRUE;
    for (i = 0; i < get_language_points(ch); i++) {
      if (!str_cmp(ch->pcdata->languages[i], string)) {
        if (get_skill(ch, SKILL_LANGUAGE2 + i) == 2)
        return TRUE;
      }
    }
    return FALSE;
  }

  bool knows_basic(CHAR_DATA *ch, char *string) {
    int i;
    if (IS_NPC(ch))
    return FALSE;
    if (IS_IMMORTAL(ch))
    return TRUE;
    for (i = 0; i < get_language_points(ch); i++) {
      if (!str_cmp(ch->pcdata->languages[i], string)) {
        if (get_skill(ch, SKILL_LANGUAGE2 + i) == 1)
        return TRUE;
      }
    }
    return FALSE;
  }

  int lang_level(CHAR_DATA *ch, char *string) {
    int i;
    if (IS_NPC(ch))
    return 0;
    if (is_gm(ch))
    return 3;
    if (higher_power(ch))
    return 3;
    if (!str_cmp(string, "English"))
    return 3;
    if (get_skill(ch, SKILL_MINDREADING) > 0)
    return 3;
    int min = 10;
    int count = 0;
    for (i = 0; i < get_language_points(ch); i++) {
      if (!str_cmp(ch->pcdata->languages[i], string)) {
        return get_skill(ch, SKILL_LANGUAGE2 + i);
      }
      if (get_skill(ch, SKILL_LANGUAGE2 + i) < min)
      min = get_skill(ch, SKILL_LANGUAGE2 + i);
      if (safe_strlen(ch->pcdata->languages[i]) < 2)
      min = 0;
      count++;
    }
    if (count >= 3 && min > 0 && min < 10)
    return UMIN(min, 2);

    return 0;
  }

  int langoffset(char *language, int i) {
    char tmp[MSL];
    sprintf(tmp, "%s", language);
    int length = safe_strlen(language);
    i = i % length;
    if (isupper(tmp[i]))
    tmp[i] = tolower(tmp[i]);
    int position = tmp[i] - 'a';
    return position;
  }

  char *to_gibberish(char *language, char *word) {
    if (safe_strlen(language) < 1) {
      return language;
    }
    char tmp[MSL];
    sprintf(tmp, "%s", word);
    char newword[MSL];
    newword[0] = 0;
    char blah[MSL];
    for (int i = 0; tmp[i] != '\0'; i++) {
      if (!isalpha(tmp[i])) {
        sprintf(blah, "%c", tmp[i]);
        strcat(newword, blah);
      }
      else {
        int position;
        if (isupper(tmp[i]))
        position = tmp[i] - 'A';
        else
        position = tmp[i] - 'a'; // 0 -25
        position += langoffset(language, i);
        position = position % 26;
        if (isupper(tmp[i])) {
          tmp[i] = position + 'a';
          tmp[i] = toupper(tmp[i]);
        }
        else {
          tmp[i] = position + 'a';
        }

        sprintf(blah, "%c", tmp[i]);
        strcat(newword, blah);
      }
    }
    return str_dup(newword);
  }

  char *mangle_text(CHAR_DATA *ch, CHAR_DATA *victim, char *language, char *argument) {
    char buf[MSL];
    char outbuf[MSL];
    strcpy(buf, argument);
    int cnt = 0;
    char arg[MSL];
    int chance = 100;
    int rate = 10;
    int min = 50;
    if (IS_NPC(ch) || IS_NPC(victim))
    return argument;

    if(number_percent() % 3 == 0 && ch->pcdata->fixation_timeout > current_time && fixation_happy_room(ch) == FALSE)
    return "blah blah blah";

    if ((lang_level(ch, language) >= 3 && lang_level(victim, language) >= 3) || is_gm(victim)) {
      if (!str_cmp(ch->pcdata->speaking, victim->pcdata->speaking))
      return argument;
      else {
        sprintf(buf, "%s(%s)", argument, ch->pcdata->speaking);
        return str_dup(buf);
      }
    }
    if (lang_level(ch, language) == 2 || lang_level(victim, language) == 2) {
      chance = 100;
      rate = 10;
      min = 70;
    }
    if (lang_level(ch, language) == 1 || lang_level(victim, language) == 1) {
      chance = 100;
      rate = 15;
      min = 60;
    }
    if (lang_level(ch, language) == 1 && lang_level(victim, language) == 1) {
      chance = 100;
      rate = 20;
      min = 50;
    }

    outbuf[0] = '\0';
    while (argument[0] != '\0') {
      arg[0] = '\0';
      argument = one_argument_true(argument, arg);

      if (chance > number_percent() && number_range(5, 15) > (int)safe_strlen(arg) && lang_level(victim, language) > 0) {
        chance = UMAX(chance - rate, min);
        sprintf(outbuf, "%s%s%s", outbuf, (cnt == 0) ? "" : " ", arg);
      }
      else {
        chance = UMAX(chance - rate, min);
        sprintf(outbuf, "%s%s%s", outbuf, (cnt == 0) ? "" : " ", to_gibberish(language, arg));
        chance += rate;
      }
      cnt++;
    }
    if (str_cmp(ch->pcdata->speaking, victim->pcdata->speaking)) {
      if (lang_level(victim, language) > 0) {
        sprintf(buf, "%s(%s)", outbuf, ch->pcdata->speaking);
        return str_dup(buf);
      }
      else {
        return str_dup(outbuf);
      }
    }
    return str_dup(outbuf);
  }

  char *mangle_word(CHAR_DATA *ch, CHAR_DATA *victim, char *language, char *argument) {
    char buf[MSL];
    char outbuf[MSL];
    strcpy(buf, argument);
    int cnt = 0;
    char arg[MSL];
    int chance = 100;
    if (is_dreaming(ch))
    return argument;
    if (is_mute(ch))
    return "...";
    if (is_gm(victim))
    return argument;
    if (lang_level(ch, language) >= 3 && lang_level(victim, language) >= 3)
    return argument;
    if (ch == victim)
    return argument;
    if (lang_level(ch, language) == 2 || lang_level(victim, language) == 2) {
      chance = 70;
    }
    if (lang_level(ch, language) == 1 || lang_level(victim, language) == 1) {
      chance = 60;
    }
    if (lang_level(ch, language) == 1 && lang_level(victim, language) == 1) {
      chance = 50;
    }
    outbuf[0] = '\0';
    while (argument[0] != '\0') {
      arg[0] = '\0';
      argument = one_argument_true(argument, arg);

      if (chance > number_percent() && number_range(5, 15) > (int)safe_strlen(arg) && lang_level(victim, language) > 0) {
        sprintf(outbuf, "%s%s%s", outbuf, (cnt == 0) ? "" : " ", arg);
      }
      else {
        sprintf(outbuf, "%s%s%s", outbuf, (cnt == 0) ? "" : " ", to_gibberish(language, arg));
      }
      cnt++;
    }
    return str_dup(outbuf);
  }

  char *static_text(CHAR_DATA *ch, CHAR_DATA *victim, char *argument) {

    if (!is_town_blackout())
    return argument;

    char buf[MSL];
    char outbuf[MSL];
    strcpy(buf, argument);
    int cnt = 0;
    char arg[MSL];

    int chance = ch->pcdata->garbled + victim->pcdata->garbled;

    chance = UMAX(chance, 20);

    outbuf[0] = '\0';
    while (argument[0] != '\0') {
      argument = one_argument(argument, arg);

      if (chance < number_percent() && number_range(5, 11) > (int)safe_strlen(arg)) {
        ch->pcdata->garbled++;
        victim->pcdata->garbled++;
        sprintf(outbuf, "%s%s%s", outbuf, (cnt == 0) ? "" : " ", arg);
        chance = UMAX(20, UMIN(60, ch->pcdata->garbled) +
        UMIN(60, ch->pcdata->garbled));
      }
      else {
        sprintf(outbuf, "%s%s", outbuf, (cnt == 0) ? "" : " <static>");
      }
      cnt++;
    }
    return str_dup(outbuf);
  }

  _DOFUN(do_lsay) {
    char arg[MSL];
    argument = one_argument_nouncap(argument, arg);
    if (lang_level(ch, arg) <= 0) {
      send_to_char("You don't know that language.\n\r", ch);
      return;
    }
    do_function(ch, &do_speak, arg);
    do_function(ch, &do_say, argument);
    do_function(ch, &do_speak, "English");
  }

  int skill_by_name(char *argument) {
    for (int i = 0; i < SKILL_USED; i++) {
      if (!str_cmp(skill_table[i].name, argument))
      return skill_table[i].vnum;
    }
    return -1;
  }

  int dis_by_name(char *argument) {
    for (int i = 0; i < DIS_USED; i++) {
      if (!str_cmp(discipline_table[i].name, argument))
      return discipline_table[i].vnum;
    }
    return -1;
  }

  _DOFUN(do_showability) {
    if (!str_cmp(argument, "root") && get_skill(ch, SKILL_NATURE) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can summon small roots from natural soil.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can summon small roots from natural soil.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "quicksand") && get_skill(ch, SKILL_NATURE) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can turn topsoil to quicksand.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can turn topsoil to quicksand.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "rapidgrowth") && get_skill(ch, SKILL_NATURE) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can cause plants to grow rapidly with a touch.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can cause plants to grow rapidly with a touch.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "tremor") && get_skill(ch, SKILL_NATURE) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can cause mild tremors in the earth.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can cause mild tremors in the earth.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "commandbeast") && get_skill(ch, SKILL_NATURE) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can stun an animal with a word.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can stun an animal with a word.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "pepperspray") && get_skill(ch, SKILL_GADGETS) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou know how to skillfully use pepperspray.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e knows how to skillfully use pepperspray.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "triage") && get_skill(ch, SKILL_GADGETS) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou know how to skillfully use bandages for triage.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e knows how to skillfully use bandages for triage.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "taser") && get_skill(ch, SKILL_GADGETS) > 2) {
      act("\t\t`WAbility Report:`xYou\n\tYou know how to skillfully use a taser.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e knows how to skillfully use a taser.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "tasergun") && get_skill(ch, SKILL_GADGETS) > 2) {
      act("\t\t`WAbility Report:`xYou\n\tYou know how to skillfully use a tasergun.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e knows how to skillfully use a tasergun.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "tranq") && get_skill(ch, SKILL_GADGETS) > 2) {
      act("\t\t`WAbility Report:`xYou\n\tYou know how to skillfully use a tranq gun, firing darts that will temporarily induce weakness and lethargy in humans.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e knows how to skillfully use a tranq gun, firing darts that will temporarily induce weakness and lethargy in humans.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "grapple") && get_skill(ch, SKILL_MARTIAL) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou know how to grapple with someone to stop them leaving.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e knows how to grapple with someone to stop them leaving.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "trip") && get_skill(ch, SKILL_MARTIAL) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou are adept at trips and legsweeps.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e is adept at trips and legsweeps.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "disarm") && get_skill(ch, SKILL_MARTIAL) > 2) {
      act("\t\t`WAbility Report:`xYou\n\tYou can disarm most weapons in close.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can disarm most weapons in close.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "bodyshield") && get_skill(ch, SKILL_MARTIAL) > 2) {
      act("\t\t`WAbility Report:`xYou\n\tYou can use others as a bodyshield.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can use others as a bodyshield.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "throw") && get_skill(ch, SKILL_MARTIAL) > 2) {
      act("\t\t`WAbility Report:`xYou\n\tYou can use others momentum against them to throw them when they run at you.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can use others momentum against them to throw them if they run at $m.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "suppressor") && get_skill(ch, SKILL_SOLDIER) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can skillfully attach and use firearm suppressors.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can skillfully attach and use firearm suppressors.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "bipod") && get_skill(ch, SKILL_SOLDIER) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can skillfully deploy and use firearm stabilizingh bipods.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can skillfully deploy and use firearm stabilizing bipods.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "naturalize") && get_skill(ch, SKILL_SOLDIER) > 2) {
      act("\t\t`WAbility Report:`xYou\n\tYou can use a naturalizer.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can use a naturalizer.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "laserdesignate") && get_skill(ch, SKILL_SOLDIER) > 2) {
      act("\t\t`WAbility Report:`xYou\n\tYou can tag people with a laser target.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can tag people with a laser target.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "bayonett") && get_skill(ch, SKILL_SOLDIER) > 2) {
      act("\t\t`WAbility Report:`xYou\n\tYou can skillfully attach and use a bayonett.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can skillfully attach and use a bayonett.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "suppressingfire") && get_skill(ch, SKILL_SOLDIER) > 2) {
      act("\t\t`WAbility Report:`xYou\n\tYou know how to lay down suppressing fire on some cover.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e knows how to lay down suppressing fire on some cover.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "caltrops") && get_skill(ch, SKILL_COMMANDO) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can skillfully spread caltrops.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can skillfully spread caltrops.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "sprint") && get_skill(ch, SKILL_COMMANDO) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou are capable of putting on an extra burst of speed when you need to.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e is capable of putting on an extra burst of speed when $e needs to.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "landmine") && get_skill(ch, SKILL_COMMANDO) > 2) {
      act("\t\t`WAbility Report:`xYou\n\tYou can arm and deploy landmines.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can arm and deploy landmines.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "bola") && get_skill(ch, SKILL_COMMANDO) > 2) {
      act("\t\t`WAbility Report:`xYou\n\tYou know how to throw a bola.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e knows how to throw a bola.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "deadswitch") && get_skill(ch, SKILL_COMMANDO) > 2) {
      act("\t\t`WAbility Report:`xYou\n\tYou can create and arm deadswitch explosives.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can create and arm deadswitch explosives.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "gasmask") && get_skill(ch, SKILL_RIOT) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou know how to properly use a gasmask.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e knows how to properly use a gasmask.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "smokegrenade") && get_skill(ch, SKILL_RIOT) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou know how to arm and properly use a smoke grenade.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e knows how to arm and properly use a smoke grenade.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "neutralize") && get_skill(ch, SKILL_RIOT) > 2) {
      act("\t\t`WAbility Report:`xYou\n\tYou know how to use a neutralizer.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e knows how to use a neutralizer.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "teargas") && get_skill(ch, SKILL_RIOT) > 2) {
      act("\t\t`WAbility Report:`xYou\n\tYou know how to arm and properly use a tear gas grenade.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e knows how to arm and properly use a tear gas grenade.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "grenadelauncher") && get_skill(ch, SKILL_RIOT) > 2) {
      act("\t\t`WAbility Report:`xYou\n\tYou know how to properly attach and use an underbarrel grenade launcher.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e knows how to properly attach and use an underbarrel grenade launcher.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "fraggrenade") && get_skill(ch, SKILL_RIOT) > 2) {
      act("\t\t`WAbility Report:`xYou\n\tYou know how to arm and properly use a fragmentation grenade.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e knows how to arm and properly use a fragmentation grenade.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "bewilder") && get_skill(ch, SKILL_PSYCHIC) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou know how to confuse someone's depth perception.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e knows how to confuse someone's depth perception.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "confuse") && get_skill(ch, SKILL_PSYCHIC) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou know how to cause someone to grow more confused.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e knows how to cause someone to grow more confused.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "doubt") && get_skill(ch, SKILL_PSYCHIC) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can cause someone to doubt themselves.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can cause someone to doubt themselves.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "stasis") && get_skill(ch, SKILL_PSYCHIC) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can place someone into a trance for up to 12 seconds through concentration.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can place someone in a trance for up to 12 seconds through concentration.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "fear") && get_skill(ch, SKILL_PSYCHIC) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can supernaturally induce fear.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can supernaturally induce fear.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "distract") && get_skill(ch, SKILL_COMBAT_ILLUSIONS) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can cause a momentary distraction in the corner of someone's vision.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can cause a momentary distraction in the corner of someone's vision.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "double") && get_skill(ch, SKILL_COMBAT_ILLUSIONS) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can cause someone to temporarily confuse you with another person.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can cause someone to temporarily confue them with another person.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "cloak") && get_skill(ch, SKILL_COMBAT_ILLUSIONS) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can cause someone to be unable to see you for up to 8 seconds.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can cause someone to be unable to see them for up to 8 seconds.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "aura") && get_skill(ch, SKILL_COMBAT_ILLUSIONS) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can make someone glow briefly.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can make someone glow briefly.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "trick") && get_skill(ch, SKILL_COMBAT_ILLUSIONS) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can make it look as if someone else performed an action instead of yourself.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can make it look as if someone else performed an action instead of themselves.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "burstvessel") && get_skill(ch, SKILL_HAEMOMANCY) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can burst minor surface blood vessels, blinding someone for several seconds if it targets the eyes.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can burst minor surface blood vessels, blinding someone for several seconds if it targets the eyes.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "slowheart") && get_skill(ch, SKILL_HAEMOMANCY) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can slow down someone's heart, causing them to feel faint and lightheaded.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can slow down someone's heart, causing them to feel faint and lightheaded.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "declot") && get_skill(ch, SKILL_HAEMOMANCY) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can temporarily stop wounds from clotting like they should.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can temporarily stop wounds from clotting like they should.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "heartattack") && get_skill(ch, SKILL_HAEMOMANCY) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can speed up someone's heart, potentially leading to a panic attack or death in already badly injured person.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can speed up someone's heart, potentially leading to a panic attack or death in an already badly injured person.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "bleed") && get_skill(ch, SKILL_HAEMOMANCY) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can cause someone to bleed far more intensely for a few seconds.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can cause someone to bleed far more intensely for a few seconds.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "push") && get_skill(ch, SKILL_TELEKINESIS) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can telekinetically push objects away from you up to the weight of a large man.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can telekinetically push objects away from them, up to the weight of a large man.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "pull") && get_skill(ch, SKILL_TELEKINESIS) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can telekinetically pull objects towards you up to the weight of a large man.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can telekinetically pull objects towards them, up to the weight of a large man.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "tklift") && get_skill(ch, SKILL_TELEKINESIS) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can telekinetically lift objects, up to the weight of a large man.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can telekinetically lift objects, up to the weight of a large man.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "tkthrow") && get_skill(ch, SKILL_TELEKINESIS) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can telekinetically hurl objects up to the weight of a brick around.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can telekinetically hurl objects up to the weight of a brick around.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "tkjump") && get_skill(ch, SKILL_TELEKINESIS) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can hurl yourself through the air with telekinesis.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can hurl $mself through the air with telekinesis", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "gust") && get_skill(ch, SKILL_WEATHER) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can direct a brief gust of wind at someone.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can direct a brief gust of wind at someone.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "thickenair") && get_skill(ch, SKILL_WEATHER) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can thicken the air around you, slowing objects and distorting sound.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can thicken the air around $m, slowing objects and distorting sound.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "wind") && get_skill(ch, SKILL_WEATHER) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can summon brief, potent winds when outdoors.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can summon brief, potent winds when outdoors.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "suffocate") && get_skill(ch, SKILL_WEATHER) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can pull most of the air from someone's lungs temporarily.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can pull most of the air from someone's lungs temporarily.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "lightningstrike") && get_skill(ch, SKILL_WEATHER) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can summon a roughly aimed lightning strike from thunderclouds.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can summon a roughly aimed lightning strike from thunderclouds.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "jam") && get_skill(ch, SKILL_MAGNO) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can apply random force to small metal objects, jamming mechanical devices.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can apply random force to small metal objects, jamming mechanical devices.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "curvebullets") && get_skill(ch, SKILL_MAGNO) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can slightly curve the flight of bullets.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can slightly curve the flight of bullets.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "repel") && get_skill(ch, SKILL_MAGNO) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can powerfully repel metal objects, up to the weight of a small car.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can powerfully repel metal objects, up to the weight of a small car.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "overload") && get_skill(ch, SKILL_MAGNO) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can overload electronic devices, causing them to shut down and wiping magnetic storage.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can overload electronic devices, causing them to shut down and wiping magnetic storage.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "reflect") && get_skill(ch, SKILL_MAGNO) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can create magnetic slingshots with a few seconds preparation and enough space, redirecting metal projectiles.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can create magnetic slingshots with a few seconds preparation and enough space, redirecting metal projectiles.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "adrenaline") && get_skill(ch, SKILL_BIOMANCY) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can cause a surge of adrenaline in your own body.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can cause a surge of adrenaline in their own body.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "heal") && get_skill(ch, SKILL_BIOMANCY) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can increase your healing rate, and close wounds.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can increase their healing rate and close wounds.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "resistpain") && get_skill(ch, SKILL_BIOMANCY) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can temporarily shut off your body's pain receptors.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can temporarily shut off their body's pain receptors.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "recover") && get_skill(ch, SKILL_BIOMANCY) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can rapidly recover your balance and sense of equilibrium.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can rapidly recover $s balance and sense of equilibrium.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "oxygenate") && get_skill(ch, SKILL_BIOMANCY) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can oxygenate your muscles for a brief peek in performance.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can oxygenate their muscles for a brief peek in performance.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "chill") && get_skill(ch, SKILL_CRYO) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can cause objects to rapidly cool by up to 15 degrees Celcius.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can cause objects to rapidly cool by up to 15 degrees Celcius.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "reinforce") && get_skill(ch, SKILL_CRYO) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can reinforce objects with ice drawn from the air.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can reinforce objects with ice drawn from the air.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "stickweapons") && get_skill(ch, SKILL_CRYO) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can temporarily freeze weapons into their holsters and sheathes.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can temporarily freeze weapons into their holsters and sheathes.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "colddiscipline") && get_skill(ch, SKILL_CRYO) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can still your autonomic system temporarily.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can still their autonomic system temporarily.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "coldsnap") && get_skill(ch, SKILL_CRYO) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can turn small amounts of water instantly to ice.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can turn small amounts of water instantly to ice.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "sweat") && get_skill(ch, SKILL_PYRO) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can cause objects to rapidly heat up by up to 15 degrees Celcius.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can cause objects to rapidly heat up by up to 15 degrees Celcius.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "burnarmor") && get_skill(ch, SKILL_PYRO) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can cause make objects blacken and smoulder.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can cause objects to blacken and smoulder.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "burnweapon") && get_skill(ch, SKILL_PYRO) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can cause small fires on wooden objects.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can cause small fires on wooden objects.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "heatmetal") && get_skill(ch, SKILL_PYRO) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can cause metal you touch to turn red hot.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can cause metal they touch to turn red hot.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "startfire") && get_skill(ch, SKILL_PYRO) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can start fires on most combustible objects, such as cotton clothing.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can start fires on most combustible objects, such as cotton clothing.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "regenerate") && get_skill(ch, SKILL_NECRO) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can regenerate the flesh of the undead.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can regenerate the flesh of the undead.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "rigormortis") && get_skill(ch, SKILL_NECRO) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can temporarily paralyze some of an undead's limbs.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can temprarily paralyze some of an undead's limbs.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "lethargy") && get_skill(ch, SKILL_NECRO) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can substantialy slow all of an undead's movements.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can substantially slow all of an undead's movements.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "halt") && get_skill(ch, SKILL_NECRO) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can completely paralyze an undead with a spoken word.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can completely paralyze an undead with a spoken word.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "commandundead") && get_skill(ch, SKILL_NECRO) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can temporarily puppet some of an undead's limbs.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can temporarily puppet some of an undead's limbs.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "fieryweapon") && get_skill(ch, SKILL_ANGELCOMBAT) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can cause fire with a touch.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can cause fire with a touch.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "incandescence") && get_skill(ch, SKILL_ANGELCOMBAT) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can glow with an intense light.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can glow with an intense light.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "heataura") && get_skill(ch, SKILL_ANGELCOMBAT) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can radiate heat.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can radiate heat.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "lightfeet") && get_skill(ch, SKILL_ANGELCOMBAT) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can temporarily make yourself weigh less.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can temporarily make themselves weigh less.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "burden") && get_skill(ch, SKILL_ANGELCOMBAT) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can temporarily make someone or something else weigh more.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can temporarily make someone or something else weigh more.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "takedown") && get_skill(ch, SKILL_PRIMALCOMBAT) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can bring a target to the ground in animal form.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can bring a target to the ground in animal form.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "rush") && get_skill(ch, SKILL_PRIMALCOMBAT) > 0) {
      act("\t\t`WAbility Report:`xYou\n\tYou can put on a burst of speed when chasing prey.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can put on a burst of speed when chasing prey.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "prowl") && get_skill(ch, SKILL_PRIMALCOMBAT) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can move low to the ground in animal form, making them harder to see or hit.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can move low to the ground in animal form, making them harder to see or hit.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "ferocity") && get_skill(ch, SKILL_PRIMALCOMBAT) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can attack with startling ferocity in animal form.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can attack with startling ferocity in animal form.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "pounce") && get_skill(ch, SKILL_PRIMALCOMBAT) > 1) {
      act("\t\t`WAbility Report:`xYou\n\tYou can spring suddenly on a target in animal form.", ch, NULL, NULL, TO_CHAR);
      act("\t\t`WAbility Report:`x$n\n\t$e can spring suddenly on a target in animal form.", ch, NULL, NULL, TO_ROOM);
    }
    if (!str_cmp(argument, "messengeraspect") && get_skill(ch, SKILL_DAYASPECT) > 0) {
      if (ch->pcdata->divine_focus == CAFF_AMESSENGER) {
        act("\t\t`WAbility Report:`xYou\n\tYou can make themselves incredibly swift for a dozen seconds or so.", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WAbility Report:`x$n\n\t$e can make themselves incredibly swift for a dozen seconds or so.", ch, NULL, NULL, TO_ROOM);
      }
      else {
        act("\t\t`WAbility Report:`xYou\n\tYou can make themselves unusually swift for a dozen seconds or so.", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WAbility Report:`x$n\n\t$e can make themselves unusually swift for a dozen seconds or so.", ch, NULL, NULL, TO_ROOM);
      }
    }
    if (!str_cmp(argument, "sunaspect") && get_skill(ch, SKILL_DAYASPECT) > 0) {
      if (ch->pcdata->divine_focus == CAFF_ASUN) {
        act("\t\t`WAbility Report:`xYou\n\tYou can make your body give off an intense, blinding solar light for a dozen seconds or so.", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WAbility Report:`x$n\n\t$e can make $s body give off an intense, blinding solar light for a dozen seconds or so.", ch, NULL, NULL, TO_ROOM);
      }
      else {
        act("\t\t`WAbility Report:`xYou\n\tYou can make your body give off a radiant solar light for a dozen seconds or so.", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WAbility Report:`x$n\n\t$e can make $s body give off a radiant solar light for a dozen seconds or so.", ch, NULL, NULL, TO_ROOM);
      }
    }
    if (!str_cmp(argument, "warrioraspect") && get_skill(ch, SKILL_DAYASPECT) > 1) {
      if (ch->pcdata->divine_focus == CAFF_AWARRIOR) {
        act("\t\t`WAbility Report:`xYou\n\tYou can gain the knowledge of a legendary warrior for a dozen or so seconds, sacrificing your knowledge of ranged combat in the process.", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WAbility Report:`x$n\n\t$e can gain the knowledge of a legendary warrior for a dozen or so seconds, sacrificing $s knowledge of ranged combat in the process.", ch, NULL, NULL, TO_ROOM);
      }
      else {
        act("\t\t`WAbility Report:`xYou\n\tYou can gain the knowledge of a veteran warrior for a dozen or so seconds, sacrificing some of your knowledge of ranged combat in the process.", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WAbility Report:`x$n\n\t$e can gain the knowledge of a veteran warrior for a dozen or so seconds, sacrificing some of $s knowledge of ranged combat in the process.", ch, NULL, NULL, TO_ROOM);
      }
    }
    if (!str_cmp(argument, "smithaspect") && get_skill(ch, SKILL_DAYASPECT) > 1) {
      if (ch->pcdata->divine_focus == CAFF_ASMITH) {
        act("\t\t`WAbility Report:`xYou\n\tYou can make your skin as hard as steel for a dozen or so seconds.", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WAbility Report:`x$n\n\t$e can make $s skin as hard as steel for a dozen or so seconds.", ch, NULL, NULL, TO_ROOM);
      }
      else {
        act("\t\t`WAbility Report:`xYou\n\tYou can make your skin as hard as wood for a dozen or so seconds.", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WAbility Report:`x$n\n\t$e can make $s skin as hard as wood for a dozen or so seconds.", ch, NULL, NULL, TO_ROOM);
      }
    }
    if (!str_cmp(argument, "healeraspect") && get_skill(ch, SKILL_DAYASPECT) > 1) {
      if (ch->pcdata->divine_focus == CAFF_AHEALER) {
        act("\t\t`WAbility Report:`xYou\n\tYou can gain a near perfect understanding of the biology of healthy creatures, allowing you to much more accurately predict their actions and injure them for a dozen or so seconds, but sacrifice your knowledge of injured ones to do so.", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WAbility Report:`x$n\n\t$e can a near perfect understanding of the biology of healthy creatures, allowing $m to much more accurately predict their actions and injure them for a dozen or so seconds, but sacrifices $s knowledge of injured ones to do so.", ch, NULL, NULL, TO_ROOM);
      }
      else {
        act("\t\t`WAbility Report:`xYou\n\tYou can gain an expert understanding of the biology of healthy creatures, allowing you to much more accurately predict their actions and injure them for a dozen or so seconds, but sacrifice some of your understanding of injured ones to do so.", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WAbility Report:`x$n\n\t$e can gain an expert understanding of the biology of healthy creatures, allowing $m to much more accurately predict their actions and injure them for a dozen or so seconds, but sacrifices some of $s understanding of injured ones to do so.", ch, NULL, NULL, TO_ROOM);
      }
    }
    if (!str_cmp(argument, "underworldaspect") && get_skill(ch, SKILL_NIGHTASPECT) > 0) {
      if (ch->pcdata->divine_focus == CAFF_AUNDERWORLD) {
        act("\t\t`WAbility Report:`xYou\n\tYou can gain a near perfect understanding of wounds, disease and weakness for a dozen or so seconds, making you better able to fight impaired and wounded enemies, but sacrifice your understanding of healthy creatures to do so.", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WAbility Report:`x$n\n\t$e can gain a near perfect understanding of wounds, disease and weakness for a dozen or so seconds, making $m better able to fight impaired and woudned enemies, but sacrifices $s understanding of healthy creatures to do so.", ch, NULL, NULL, TO_ROOM);
      }
      else {
        act("\t\t`WAbility Report:`xYou\n\tYou can gain an expert understanding of wounds, disease and weakness for a dozen or so seconds, making you better able to fight impaired and wounded enemies, but sacrifice some of your understanding of healthy creatures to do so.", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WAbility Report:`x$n\n\t$e can gain an expert understanding of wounds, disease and weakness for a dozen or so seconds, making $m better able to fight impaired and wounded enemies, but sacrifices some of $s understanding of healthy creatures to do so.", ch, NULL, NULL, TO_ROOM);
      }
    }
    if (!str_cmp(argument, "moonaspect") && get_skill(ch, SKILL_NIGHTASPECT) > 0) {
      if (ch->pcdata->divine_focus == CAFF_AMOON) {
        act("\t\t`WAbility Report:`xYou\n\tYou can lengthen and enhance shadows around you, creating a small pocket of deepest night and making you almost impossible to see from a distance.", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WAbility Report:`x$n\n\t$e can lengthen and enhance shadows around $m, creating a small pocket of deepest night and making $m almost impossible to see from a distance.", ch, NULL, NULL, TO_ROOM);
      }
      else {
        act("\t\t`WAbility Report:`xYou\n\tYou can lengthen and enhance the shadows around you, making you harder to see at a distance.", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WAbility Report:`x$n\n\t$e can lengthen and enhance the shadows around $m, making $m harder to see at a distance.", ch, NULL, NULL, TO_ROOM);
      }
    }
    if (!str_cmp(argument, "thunderaspect") && get_skill(ch, SKILL_NIGHTASPECT) > 1) {
      if (ch->pcdata->divine_focus == CAFF_ATHUNDER) {
        act("\t\t`WAbility Report:`xYou\n\tYou can deliver a thunderous shock with a touch, and charge an object with lightning.", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WAbility Report:`x$n\n\t$e can deliver a thunderous shock with a touch, and charge an object with lightning.", ch, NULL, NULL, TO_ROOM);
      }
      else {
        act("\t\t`WAbility Report:`xYou\n\tYou can deliver an electric shock with a touch, and charge an object with electricity.", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WAbility Report:`x$n\n\t$e can deliver an electic shock with a touch, and charge an object with electricity.", ch, NULL, NULL, TO_ROOM);
      }
    }
    if (!str_cmp(argument, "windaspect") && get_skill(ch, SKILL_NIGHTASPECT) > 1) {
      if (ch->pcdata->divine_focus == CAFF_AWIND) {
        act("\t\t`WAbility Report:`xYou\n\tYou can fly through the air for a dozen or so seconds, borne on a fierce supernatural wind.", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WAbility Report:`x$n\n\t$e can fly through the air for a dozen or so seconds, borne on a fierce supernatural wind.", ch, NULL, NULL, TO_ROOM);
      }
      else {
        act("\t\t`WAbility Report:`xYou\n\tYou can leap preternaturally through the air, supported by a supernatural wind.", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WAbility Report:`x$n\n\t$e can leap preternaturally through the air, supported by a supernatural wind.", ch, NULL, NULL, TO_ROOM);
      }
    }
    if (!str_cmp(argument, "hunteraspect") && get_skill(ch, SKILL_NIGHTASPECT) > 1) {
      if (ch->pcdata->divine_focus == CAFF_AHUNTER) {
        act("\t\t`WAbility Report:`xYou\n\tYou can gain the knowledge of a legendary sniper or ranger for a dozen or so seconds, sacrificing your knowledge of melee combat in the process.", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WAbility Report:`x$n\n\t$e can gain the knowledge of a legendary sniper or ranger for a dozen or so seconds, sacrificing $s knowledge of melee combat in the process.", ch, NULL, NULL, TO_ROOM);
      }
      else {
        act("\t\t`WAbility Report:`xYou\n\tYou can gain the knowledge of a veteran sniper or ranger for a dozen or so seconds, sacrificing some of your knowledge of melee combat in the process.", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WAbility Report:`x$n\n\t$e can gain the knowledge of a veteran sniper or ranger for a dozen or so seconds, sacrificing some of $s knowledge of melee combat in the process.", ch, NULL, NULL, TO_ROOM);
      }
    }
  }

  _DOFUN(do_showskill) {
    char buf[MSL];
    FANTASY_TYPE *fant;
    if (is_dreaming(ch)) {
      if ((fant = in_fantasy(ch)) != NULL) {
        for (int i = 0; i < 25; i++) {
          if (!str_cmp(ch->name, fant->participants[i])) {
            for (int x = 0; x < 20; x++) {
              if (!str_cmp(argument, fant->stats[x])) {
                sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou have %s dreamworld stat at %d.\n\n%s\n\r", fant->stats[x], fant->participant_stats[i][x], fant->stat_desc[x]);
                send_to_char(buf, ch);
                sprintf(buf, "\t\t`WStat Report:`x%s\n\tThey have %s dreamworld stat at %d.\n\n%s\n\r", dream_name(ch), fant->stats[x], fant->participant_stats[i][x], fant->stat_desc[x]);
                dreamscape_message(ch, ch->pcdata->dream_room, buf);
                return;
              }
            }
            send_to_char("No such stat.\n\r", ch);
            return;
          }
        }
      }
      send_to_char("You can't do that.\n\r", ch);
      return;
    }

    if (!str_cmp(argument, modifier_table[ch->modifier].name)) {
      sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou are modified by %s.\n\r", modifier_table[ch->modifier].name);
      act(buf, ch, NULL, NULL, TO_CHAR);
      sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e is modified by %s.\n\r", modifier_table[ch->modifier].name);
      act(buf, ch, NULL, NULL, TO_ROOM);
      return;
    }

    int val = skill_by_name(argument);
    if (val == -1 || val == SKILL_CUSTOM || val == SKILL_FIRESORC || val == SKILL_ICESORC || val == SKILL_LIGHTNINGSORC
    || val == SKILL_DARKSORC || val == SKILL_PRISSORC) {
      val = dis_by_name(argument);
      if (val == -1) {
        send_to_char("No such stat or discipline.\n\r", ch);
        return;
      }
      int point;
      for (int i = 0; i < DIS_USED; i++) {
        if (val == discipline_table[i].vnum)
        point = i;
      }
      if (discipline_table[point].vnum == DIS_CUSTOM) {
        sprintf(
        buf, "\t\t`WStat Report:`xYou\n\tYou have custom discipline %s at %d.\n\r", ch->pcdata->cdisc_name, get_disc(ch, val, FALSE));
        act(buf, ch, NULL, NULL, TO_CHAR);
        sprintf(
        buf, "\t\t`WStat Report:`x$n\n\t$e has custom discipline %s at %d.\n\r", ch->pcdata->cdisc_name, get_disc(ch, val, FALSE));
        act(buf, ch, NULL, NULL, TO_ROOM);
      }
      else {
        sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou have %s discipline at %d.\n\r", discipline_table[point].name, get_disc(ch, val, FALSE));
        act(buf, ch, NULL, NULL, TO_CHAR);
        sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e has %s discipline at %d.\n\r", discipline_table[point].name, get_disc(ch, val, FALSE));
        act(buf, ch, NULL, NULL, TO_ROOM);
      }
      return;
    }
    else {
      sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou have %s stat at %d.\n\r", skill_table[skillpoint_by_vnum(val)].name, get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_CHAR);
      sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e has %s stat at %d.\n\r", skill_table[skillpoint_by_vnum(val)].name, get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_ROOM);

      if (val == SKILL_LANGUAGE2) {
        sprintf(buf, "Language: %s\n\r", ch->pcdata->languages[0]);
        act(buf, ch, NULL, NULL, TO_CHAR);
        act(buf, ch, NULL, NULL, TO_ROOM);
      }
      if (val == SKILL_LANGUAGE3) {
        sprintf(buf, "Language: %s\n\r", ch->pcdata->languages[1]);
        act(buf, ch, NULL, NULL, TO_CHAR);
        act(buf, ch, NULL, NULL, TO_ROOM);
      }
      if (val == SKILL_LANGUAGE4) {
        sprintf(buf, "Language: %s\n\r", ch->pcdata->languages[2]);
        act(buf, ch, NULL, NULL, TO_CHAR);
        act(buf, ch, NULL, NULL, TO_ROOM);
      }
      if (val == SKILL_LANGUAGE5) {
        sprintf(buf, "Language: %s\n\r", ch->pcdata->languages[3]);
        act(buf, ch, NULL, NULL, TO_CHAR);
        act(buf, ch, NULL, NULL, TO_ROOM);
      }
      if (val == SKILL_ART) {
        sprintf(buf, "Artistic Ability: %s\n\r", ch->pcdata->art1);
        act(buf, ch, NULL, NULL, TO_CHAR);
        act(buf, ch, NULL, NULL, TO_ROOM);
      }
      if (val == SKILL_ART2) {
        sprintf(buf, "Artistic Ability: %s\n\r", ch->pcdata->art2);
        act(buf, ch, NULL, NULL, TO_CHAR);
        act(buf, ch, NULL, NULL, TO_ROOM);
      }
      if (val == SKILL_ART3) {
        sprintf(buf, "Artistic Ability: %s\n\r", ch->pcdata->art3);
        act(buf, ch, NULL, NULL, TO_CHAR);
        act(buf, ch, NULL, NULL, TO_ROOM);
      }
      if (val == SKILL_CSUBFACTION && get_subfac_name(ch->pcdata->association) != NULL) {
        sprintf(buf, "Subfaction: %s\n\r", get_subfac_name(ch->pcdata->association));
        act(buf, ch, NULL, NULL, TO_CHAR);
        act(buf, ch, NULL, NULL, TO_ROOM);
      }
      for (CharList::iterator it = ch->in_room->people->begin();
      it != ch->in_room->people->end(); ++it) {
        CHAR_DATA *rch = *it;
        if (IS_NPC(rch))
        continue;
        if (is_gm(rch) || rch == ch)
        stat_explain(rch, ch, val);
      }

      return;
    }
    bool disc = FALSE;
    if (disc == TRUE) {
      // I went through and spell checked or rephrased each of the show skill
      // strings - Discordance
      switch (val) {
      case DIS_TELEKINESIS:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou have no telekinetic ability.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has no telekinetic ability.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary telekinetic ability.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary telekinetic ability.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou are capable of basic feats of telekinesis.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is capable of basic feats of telekinesis", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou are competently telekinetic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is competently telekinetic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou are capable of fairly powerful feats of telekinesis.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is capable of fairly powerful feats of telekinesis.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou are capable of very powerful feats of telekinesis.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is capable of very powerful feats of telekinesis.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou are capable of extremely powerful feats of telekinesis.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is capable of extremely powerful telekinesis.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield godlike telekinetic power.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields godlike telekinetic power.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_CUSTOM:
        if (get_disc(ch, val, FALSE) < 1) {
          sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou have no skill at %s.", ch->pcdata->cdisc_name);
          act(buf, ch, NULL, NULL, TO_CHAR);
          sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e has no skill at %s.", ch->pcdata->cdisc_name);
          act(buf, ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou have rudimentary skill at %s.", ch->pcdata->cdisc_name);
          act(buf, ch, NULL, NULL, TO_CHAR);
          sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e has rudimenty skill at %s.", ch->pcdata->cdisc_name);
          act(buf, ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou have basic skill at %s.", ch->pcdata->cdisc_name);
          act(buf, ch, NULL, NULL, TO_CHAR);
          sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e has basic skill at %s.", ch->pcdata->cdisc_name);
          act(buf, ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou have competant skill at %s.", ch->pcdata->cdisc_name);
          act(buf, ch, NULL, NULL, TO_CHAR);
          sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e has competant skill at %s.", ch->pcdata->cdisc_name);
          act(buf, ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou are skilled at %s.", ch->pcdata->cdisc_name);
          act(buf, ch, NULL, NULL, TO_CHAR);
          sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e is skilled at %s.", ch->pcdata->cdisc_name);
          act(buf, ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou are very skilled at %s.", ch->pcdata->cdisc_name);
          act(buf, ch, NULL, NULL, TO_CHAR);
          sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e is very skilled at %s.", ch->pcdata->cdisc_name);
          act(buf, ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou are extremely skilled at %s.", ch->pcdata->cdisc_name);
          act(buf, ch, NULL, NULL, TO_CHAR);
          sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e is extremely skilled at %s.", ch->pcdata->cdisc_name);
          act(buf, ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou have godlike skill at %s.", ch->pcdata->cdisc_name);
          act(buf, ch, NULL, NULL, TO_CHAR);
          sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e has godlike skill at %s.", ch->pcdata->cdisc_name);
          act(buf, ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_PISTOLS:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou have no skill with pistols.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has no skill with pistols.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary pistol skills.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary pistol skills.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic pistol skills.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic pistol skills.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou wield pistols competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields pistols competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou are fairly skilled with pistols.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is fairly skilled with pistols.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou are very skilled with pistols.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is very skilled with pistols.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou are extremely skilled with pistols.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is extremely skilled with pistols.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou have godlike skill with pistols.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is has godlike skill with pistols.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_RIFLES:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou have no skill with rifles.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has no skill with rifles.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary rifle skills.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary rifle skills.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic rifle skills.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic rifle skills.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou wield rifles competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields rifles competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou are fairly skilled with rifles.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is fairly skilled with rifles.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou are very skilled with rifles.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is very skilled with rifles.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou are extremely skilled with rifles.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is extremely skilled with rifles.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou have godlike skill with rifles.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is has godlike skill with rifles.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_CARBINES:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou have no skill with carbines.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has no skill with carbines.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary carbine skills.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary carbine skills.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic carbine skills.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic carbine skills.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou wield carbines competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields carbines competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou are fairly skilled with carbines.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is fairly skilled with carbines.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou are very skilled with carbines.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is very skilled with carbines.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou are extremely skilled with carbines.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is extremely skilled with carbines.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou have godlike skill with carbines.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is has godlike skill with carbines.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_THROWN:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou have no skill with throwing weapons.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has no skill with throwing weapons.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary skill with throwing weapons.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary skill with throwing weapons.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic throwing weapon skills.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic throwing weapon skills.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou wield throwing weapons competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields throwing weapons competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou are fairly skilled with throwing weapons", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is fairly skilled with throwing weapons.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou are very skilled with throwing weapons", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is very skilled with throwing weapons.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou are extremely skilled with throwing weapons.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is extremely skilled with throwing weapons.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou throw like a god.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e throws like a god.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_BOWS:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou have no skill with bows.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has no skill with bows.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary skill with bows.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary skill with bows.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic bow skills.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic bow skills.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou wield bows competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields bows competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou are fairly skilled with bows.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is fairly skilled with bows.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou are very skilled with bows.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is very skilled with bows.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou are extremely skilled with bows.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is extremely skilled with bows.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield a bow like a god.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields a bow like a god.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_ENERGY:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou are incapable of wielding energy magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is incapable of wielding energy magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary control of energy magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary control of energy magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic control of energy magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic control of energy magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou wield energy magic competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields energy magic competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou wield fairly powerful energy magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields fairly powerful energy magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou wield very powerful energy magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields very powerful energy magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield extremely powerful energy magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields extremely powerful energy magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield energy magic like a god.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields energy magic like a god.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_FIRE:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou are incapable of wielding fire magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is incapable of wielding fire magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary control of fire magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary control of  fire magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic control of fire magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic control of fire magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou wield fire magic competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields fire magic competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou wield fairly powerful fire magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields fairly powerful fire magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou wield very powerful fire magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields very powerful fire magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield extremely powerful fire magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields extremely powerful fire magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield fire magic like a god.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$s wields fire magic like a god.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_ICE:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou are incapable of wielding ice magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is incapable of wielding ice magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary control of ice magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary control of ice magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic control of ice magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic control of ice magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou wield ice magic competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields ice magic competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou wield fairly powerful ice magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields fairly powerful ice magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou wield very powerful ice magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields very powerful ice magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield extremely powerful ice magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields extremely powerful ice magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield ice magic like a god.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields ice magic like a god.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_NATURE:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou are incapable of wielding nature magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is incapable of wielding nature magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary control of nature magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary control of nature magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic control of nature magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic control of nature magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou wield nature magic competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields nature magic competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou wield fairly powerful nature magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields fairly powerful nature magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou wield very powerful nature magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields very powerful nature magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield extremely powerful nature magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields extremely powerful nature magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield nature magic like a god.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields nature magic like a god.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_WEATHER:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou are incapable of wielding weather magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is incapable of wielding weather magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary control of weather magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary control of weather magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic control of weather magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic control of weather magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou wields weather magic competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields weather magic competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou wield fairly powerful weather magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields fairly powerful weather magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou wield very powerful weather magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields very powerful weather magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield extremely powerful weather magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields extremely powerful weather magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield weather magic like a god.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields weather magic like a god.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_LIGHTNING:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou are incapable of wielding lightning magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is incapable of wielding lightning magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary control of lightning magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary control of lightning magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic control of lightning magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic control of lightning magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou wield lightning magic competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields lightning magic competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou wield fairly powerful lightning magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields fairly powerful lightning magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou wield very powerful lightning magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields very powerful lightning magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield fairly powerful lightning magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields fairly powerful lightning magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield lightning magic like a god.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields lightning magic like a god.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_HELLFIRE:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou are incapable of wielding hellfire.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is incapable of wielding hellfire.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary control of hellfire.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary control of hellfire.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic control of hellfire.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic control of hellfire.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou wield hellfire competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields hellfire competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou wield fairly powerful hellfire.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields fairly powerful hellfire.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou wield very powerful hellfire.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields very powerful hellfire.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield fairly powerful hellfire.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields fairly powerful hellfire.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield hellfire like a god.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields hellfire like a god.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_SHADOWL:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou are incapable of wielding shadow lightning.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is incapable of wielding shadow lightning.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary control of shadow lightning.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary control of shadow lightning.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic control of shadow lightning.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic control of shadow lightning.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou wield shadow lightning competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields shadow lightning competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou wield fairly powerful shadow lightning.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields fairly powerful shadow lightning.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou wield very powerful shadow lightning.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields very powerful shadow lightning.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield fairly powerful shadow lightning.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields fairly powerful shadow lightning.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield shadow lightning like a god.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields shadow lightning like a god.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_DARK:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou are incapable of wielding dark magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is incapable of wielding dark magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary control of dark magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary control of dark magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic control of dark magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic control of dark magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou wield dark magic competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields dark magic competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou wield fairly powerful dark magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields fairly powerful dark magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou wield very powerful dark magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields very powerful dark magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield fairly powerful dark magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields fairly powerful dark magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield dark magic like a god.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields dark magic like a god.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_SHOTGUNS:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou have no skill with shotguns.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has no skill with shotguns.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary shotgun skills.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary shotgun skills.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic shotgun skills.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic shotgun skills.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou wield shotguns competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields shotguns competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou are fairly skilled with shotguns.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is fairly skilled with shotguns.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou are very skilled with shotguns.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is very skilled with shotguns.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou are extremely skilled with shotguns.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is extremely skilled with shotguns.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield a shotgun like a god.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields a shotgun like a god.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_TELEPATHY:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou are incapable of significant psychic projection.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is incapable of significant psychic projection.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary psychic ability.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary psychic ability.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic psychic ability.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic psychic ability.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou wield your psychic ability competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields $s psychic ability competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou posses fairly powerful psychic ability.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e possesses fairly powerful psychic ability.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou posses very powerful psychic ability.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e possesses very powerful psychic ability.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou possess extremely powerful psychic ability.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e possesses extremely powerful psychic ability.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou have the psychic ability of a god.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has the psychic ability of a god.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_SONIC:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou are incapable of significant sonic projection.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is incapable of significant sonic projection.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary sonic ability.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary sonic ability.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic sonic ability.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic sonic ability.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou wield your sonic ability competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields $s sonic ability competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou possess fairly powerful sonic ability.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e possesses fairly powerful sonic ability.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou possess very powerful sonic ability.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e possesses very powerful sonic ability.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou possess extremely powerful sonic ability.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e possesses extremely powerful sonic ability..", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou possess the sonic ability of a god.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e possesses the sonic ability of a god.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_RADIATION:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou are incapable of projecting radiation.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is incapable of projecting radiation.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou have only rudimentary ability to radiate.\n\tYou .", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary ability to radiate.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic control over your ability to radiate.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic control over $s ability to radiate.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou possess the ability to radiate competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e possesses the ability to radiate competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou possess fairly powerful radiation ability.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e possesses fairly powerful radiation ability.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou possess very powerful radiation ability.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e possesses very powerful radiation ability.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou possess extremely powerful radiation ability.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e possesses extremely powerful radiation ability.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou radiate like a god.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e radiate like a god.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_STONE:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou are incapable of wielding stone magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is incapable of wielding stone magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary control of stone magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary control of stone magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic control of stone magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic control of stone magic..", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou wield stone magic competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields stone magic competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou wield fairly powerful stone magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields fairly powerful stone magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou wield very powerful stone magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields very powerful stone magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield extremely powerful stone magic.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wield extremely powerful stone magic.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield stone magic like a god.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields stone magic like a god.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_BLUNT:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou have no skill with large blunt weapons.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has no skill with large blunt weapons.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary skill with large blunt weapons.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary skill with large blunt weapons.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic large blunt weapon skills.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic large blunt weapon skills.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou wield large blunt weapons competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields large blunt weapons competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou are fairly skilled with large blunt weapons.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is fairly skilled with large blunt weapons.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou are very skilled with large blunt weapons.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is very skilled with large blunt weapons.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou are extremely skilled with large blunt weapons.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is extremely skilled with large blunt weapons.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield large blunt weapons like a god.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields large blunt weapons like a god.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_LONGBLADE:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou have no skill with large bladed weapons.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has no skill with large bladed weapons.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary skill with large bladed weapons.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary skill with large bladed weapons.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic large bladed weapon skills.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic large bladed weapon skills.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou wield large bladed weapons competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields large bladed weapons competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou are fairly skilled with large bladed weapons.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is fairly skilled with large bladed weapons.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou are very skilled with large bladed weapons.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is very skilled with large bladed weapons.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou are extremely skilled with large bladed weapons.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is extremely skilled with large bladed weapons.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield large bladed weapons like a god.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields large bladed weapons like a god.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_STRIKING:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou have no skill at unarmed striking.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has no skill at unarmed striking.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary unarmed striking skills.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary unarmed striking skills.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic unarmed striking skills.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic unarmed striking skills.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou perform unarmed striking competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e performs unarmed striking competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou are a skilled unarmed striker.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is a skilled underarmed striker.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou are a very skilled unarmed striker.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is a very skilled unarmed striker.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou are an extremely skilled unarmed striker.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is an extremely skilled unarmed striker.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou have godlike unarmed striking skills.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e godlike unarmed striking skills.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_GRAPPLE:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou have no skill at unarmed grappling.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has no skill at unarmed grappling.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary unarmed grappling skills.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary unarmed grappling skills.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic unarmed grappling skills.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic unarmed grappling skills.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou perform unarmed grappling competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e performs unarmed grappling competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou are a skilled unarmed grappler.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is a skilled underarmed grappler.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou are a very skilled unarmed grappler.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is a very skilled unarmed grappler.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou are an extremely skilled unarmed grappler.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is an extremely skilled unarmed grappler.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou have godlike unarmed grappling skills.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e godlike unarmed grappling skills.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_KNIFE:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou have no skill at knife fighting.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has no skill at knife fighting.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary knife fighting skills.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary knife fighting skills.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic knife fighting skills.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic knife fighting skills.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou wield a knife competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields a knife competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou are a skilled knife fighter.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is a skilled knife fighter.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou are a very skilled knife fighter.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is a very skilled knife fighter.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou are an extremely skilled knife fighter.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is an extremely skilled knife fighter.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield a knife like a god.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields a knife like a god.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_CLAW:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou have no skill at fighting with tooth and claw.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has no skill at fighting with tooth and claw.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary skill fighting with tooth and claw.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary skill fighting with tooth and claw.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic skills for fighting with tooth and claw.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic skills for fighting with tooth and claw.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou fight with tooth and claw competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e fights with tooth and claw competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou are skilled at fighting with tooth and claw.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is skilled at fighting with tooth and claw.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou are very skilled at fighting with tooth and claw.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is very skilled at fighting with tooth and claw.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou are extremely skilled at fighting with tooth and claw.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is extremely skilled at fighting with tooth and claw.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou fight with tooth and claw like a bestial god.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e fight with tooth and claw like a bestial god.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_BRUTE:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou have no ability to apply brute force.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has no ability to apply brute force.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary ability to apply brute force.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary ability to apply brute force.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic ability to apply brute force.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic ability to apply brute force.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou apply brute force competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e apply brute force competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou apply brute force skillfully.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e applies brute force skillfully.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou apply brute force very skillfully.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e applies brute force very skillfully.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou apply brute force extremely skillfully.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e applies brute force extremely skillfully.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou apply brute force like a god.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e applies brute force like a god.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_ENERGYF:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou are incapable of wielding energy in melee.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is incapable of wielding energy in melee.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary skill when wielding energy in melee.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary skill when wielding energy in melee.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic skills related to wielding energy in melee.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic skills related to wielding energy in melee.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou wield energy in melee competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields energy in melee competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou wield energy in melee skillfully.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields energy in melee skillfully.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou wield energy in melee very skillfully.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields energy in melee very skillfully.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield energy in melee extremely skillfully.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields energy in melee extremely skillfully.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield energy like a god in melee.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wield energy like a god in melee.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_FIREF:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou are incapable of wielding fire in melee.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is incapable of wielding fire in melee.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary skill when wielding fire in melee.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary skill when wielding fire in melee.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have only basic skills related to wielding fire in melee.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only basic skills related to wielding fire in melee.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou wield fire in melee competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields fire in melee competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou wield fire in melee skillfully.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields fire in melee skillfully.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou wield fire in melee very skillfully.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields fire in melee very skillfully.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield fire in melee extremely skillfully.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields fire in melee extremely skillfully.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield fire like a god in melee.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields fire like a god in melee.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_ICEF:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou are incapable of wielding ice in melee.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is incapable of wielding ice in melee.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary skill when wielding ice in melee.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary skill when wielding ice in melee.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic skills related to wielding ice in melee.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic skills related to wielding ice in melee.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou wield ice in melee competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields ice in melee competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou wield ice in melee skillfully.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields ice in melee skillfully.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou wield ice in melee very skillfully.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields ice in melee very skillfully.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield ice in melee extremely skillfully.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields ice in melee extremely skillfully.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield ice like a god in melee.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields ice like a god in melee.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_LIGHTNINGF:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou are incapable of wielding lightning in melee.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is incapable of wielding lightning in melee.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary skill when wielding lightning in melee.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary skill when wielding lightning in melee.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic skills related to wielding lightning in melee.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic skills related to wielding lightning in melee.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou wield lightning in melee competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields lightning in melee competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou wield lightning in melee skillfully.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields lightning in melee skillfully.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou wield lightning in melee very skillfully.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields lightning in melee very skillfully.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield lightning in melee extremely skillfully.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields lightning in melee extremely skillfully.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield lightning like a god in melee.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields lightning like a god in melee.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_DARKF:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou are incapable of wielding dark magic in melee.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is incapable of wielding dark magic in melee.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou have only rudimentary skill when wielding dark magic in melee.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has only rudimentary skill when wielding dark magic in melee.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou have basic skills related to wielding dark magic in melee.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has basic skills related to wielding dark magic in melee.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou wield dark magic competently in melee.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields dark magic competently in melee.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou wield dark magic skillfully in melee.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields dark magic skillfully in melee.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou wield dark magic very skillfully in melee.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields dark magic very skillfully in melee.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield dark magic extremely skillfully in melee.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields dark magic extremely skillfully in melee.", ch, NULL, NULL, TO_CHAR);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou wield dark magic like a god in melee.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e wields dark magic like a god in melee.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_BARMOR:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou can make no significant use of modern armor.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e can make no significant use of modern armor.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou can make only rudimentary use of modern armor.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e can make only rudimentary use of modern armor.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou can make basic use of modern armor.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e can make basic use of modern armor.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou can use modern armor competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e can use modern armor competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou can use modern armor skillfully.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e can use modern armor skillfully.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou can use modern armor very skillfully.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e can use modern armor very skillfully.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou can make extremely skillful use of modern armor.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e can make extremely skillful use of modern armor.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou are like a god in your modern armor.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is like a god inside $s modern armor.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_MARMOR:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou can make no significant use of archaic armor.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e can make no significant use of archaic armor.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou can make rudimentary use of archaic armor.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e can make rudimentary use of archaic armor.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou can make basic use of archaic armor.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e can make basic use of archaic armor.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou can use archaic armor competently.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e can use archaic armor competently.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou can use archaic armor skillfully.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e can use archaic armor skillfully.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou can use archaic armor very skillfully.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e can use archaic armor very skillfully.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou can use archaic armor extremely skillfully.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e can use archaic armor extremely skillfully.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou are like a god in your archaic armor.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is like a god in $s archaic armor.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_NARMOR:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou possess no natural armor.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e possesses no natural armor.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou are protected by rudimentary natural armor.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is protected by rudimentary natural armor.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou are protected by basic natural armor.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is protected by basic natural armor.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou are protected by durable natural armor.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is protected by durable natural armor.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou are protected by fairly robust natural armor.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is protected by fairly robust natural armor.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou are protected by very robust natural armor.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is protected by very robust natural armor.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou are protected by extremely robust natural armor.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is protected by extremely robust natural armor.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou are like a god inside your shell of natural armor.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is like a god inside $s shell of natural armor.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      case DIS_TOUGHNESS:
        if (get_disc(ch, val, FALSE) < 1) {
          act("\t\t`WStat Report:`xYou\n\tYou possess no supernatural toughness.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e possesses no supernatural toughness.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 10) {
          act("\t\t`WStat Report:`xYou\n\tYou are a little more resistant to damage than most people.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is a little more resistant to damage than most people.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 20) {
          act("\t\t`WStat Report:`xYou\n\tYou are significantly more resistant to damage than most people.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is significantly more resistant to damage than most people.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 40) {
          act("\t\t`WStat Report:`xYou\n\tYou are well protected by your supernatural constitution.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is well protected by $s supernatural constitution.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 60) {
          act("\t\t`WStat Report:`xYou\n\tYou are very well protected by your supernatural constitution.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is very well protected by $s supernatural constitution.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 80) {
          act("\t\t`WStat Report:`xYou\n\tYou are extremely well protected by your supernatural constitution.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is extremely well protected by $s supernatural constitution.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) < 100) {
          act("\t\t`WStat Report:`xYou\n\tYou are incredibly well protected by your supernatural constitution.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e is incredibly well protected by $s supernatural constitution.", ch, NULL, NULL, TO_ROOM);
        }
        else if (get_disc(ch, val, FALSE) >= 100) {
          act("\t\t`WStat Report:`xYou\n\tYou have godlike supernatural durability.", ch, NULL, NULL, TO_CHAR);
          act("\t\t`WStat Report:`x$n\n\t$e has godlike supernatural durability.", ch, NULL, NULL, TO_ROOM);
        }
        break;
      }
      return;
    }
    switch (val) {
    case SKILL_REGEN:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou have no ability to regenerate.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has no ability to regenerate.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou have basic powers of regeneration.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has basic powers of regeneration.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou have significant powers of regeneration.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has significant powers of regeneration.(3)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_NIGHTVISION:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou cannot see in the dark.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e cannot see in the dark.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou can see in the dark.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can see in the dark.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou can see in the dark.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can see in the dark.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou can see in the dark.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can see in the dark.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou can see in the dark.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can see in the dark.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou can see in the dark.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can see in the dark.(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_TELEPATHY:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou are incapable of telepathy.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is incapable of telepathy.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou are telepathic.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is telepathic.(2)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_TELEMPATHY:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou are incapable of telempathy.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is incapable of telempathy.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou are telempathic.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is telempathic.(2)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_ATTRACTIVENESS:
      return;
      if (get_attract(ch, ch) < 30) {
        act("\t\t`WStat Report:`xYou\n\tYou are somewhat unattractive.", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is somewhat unattractive.", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_attract(ch, ch) < 60) {
        act("\t\t`WStat Report:`xYou\n\tYou are average looking.", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is average looking.", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_attract(ch, ch) < 75) {
        act("\t\t`WStat Report:`xYou\n\tYou are mildly attractive.", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is mildly attractive.", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_attract(ch, ch) < 90) {
        act("\t\t`WStat Report:`xYou\n\tYou are very attractive.", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is very attractive.", ch, NULL, NULL, TO_ROOM);
      }
      else {
        act("\t\t`WStat Report:`xYou\n\tYou are incredibly attractive.", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is incredibly attractive.", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_HYPNOTISM:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou have no powers of hypnotism.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has no powers of hypnotism.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou can place people into hypnotic trances, but not give instructions.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can place people into hypnotic trances, but not give instructions.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou can place people into hypnotic trances and give them instructions.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can place people into hypnotic trances and give them instructions.(3)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_WEALTH:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou have a low income of about 15,000 a year.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a low income of about 15,000 a year.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == -1) {
        act("\t\t`WStat Report:`xYou\n\tYou have no income.(-1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has no income.(-1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou have a low to moderate income of 25,000 a year.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a low to moderate income of 25,000 a year.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou have a moderate to high income of 50,000 a year.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a moderate to high income of 50,000 a year.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou have a high income of 100,000 a year.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a high income of 100,000 a year.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou have a very high income of 200,000 a year.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a very high income of 200,000 a year.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou have an extremely high income of 500,000 a year.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has an extremely high income of 500,000 a year.(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_FLIGHT:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou cannot fly.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e cannot fly.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou can fly.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can fly.(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_SUPERJUMP:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou can jump as far as a normal person.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can jump as far as a normal person.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou can make enormous, supernatural leaps.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can make enormous, supernatural leaps.(2)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_STRENGTH:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou are about as strong as the average person.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is about as strong as the average person.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == -1) {
        act("\t\t`WStat Report:`xYou\n\tYou are weaker than the average person.(-1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is weaker than the average person.(-1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou are stronger than most people.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is stronger than most people.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou are as strong as a professional athlete(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is as strong as a professional athlete.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou are stronger than any human.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is stronger than any human.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou are much stronger than any human.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is much stronger than any human.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou are extremely and supernaturally strong.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is extremely and supernaturally strong.(5)", ch, NULL, NULL, TO_ROOM);
      }
      else {
        sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou are incredibly supernaturally strong.(%d)", get_skill(ch, val));
        act(buf, ch, NULL, NULL, TO_CHAR);
        sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e is incredibly supernaturally strong.(%d)", get_skill(ch, val));
        act(buf, ch, NULL, NULL, TO_ROOM);
      }

      break;
    case SKILL_DEXTERITY:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou are about as dexterous as the average person.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is about as dexterous as the average person.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == -1) {
        act("\t\t`WStat Report:`xYou\n\tYou are clumsier than the average person.(-1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is clumsier than the average person.(-1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou are more dexterous than most people.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is more dexterous than most people.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou are as agile and adroit as a professional martial artist(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is as agile and adroit as a professional martial artist(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou are more agile and adroit than any human.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is more agile and adroit than any human.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else {
        sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou are incredibly supernaturally agile and adroit.(%d)", get_skill(ch, val));
        act(buf, ch, NULL, NULL, TO_CHAR);
        sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e is incredibly supernaturally agile and adroit.(%d)", get_skill(ch, val));
        act(buf, ch, NULL, NULL, TO_ROOM);
      }

      break;
    case SKILL_ACROBATICS:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou can do simple rolls.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can do simple rolls.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == -1) {
        act("\t\t`WStat Report:`xYou\n\tYou can't even do the simplest of acrobatic maneuvers.(-1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can't even do the simplest of acrobatic maneuvers.(-1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou can confidently do simple acrobatic maneuvers.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can confidently do simple acrobatic maneuvers.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou can tumble, flip and roll like a professional acrobat.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can tumble, flip and roll like a professional acrobat.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou can perform more advanced acrobatics than any human.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can perform more advanced acrobatics than any human.(3)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_RUNNING:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou can run as fast as an average fit person or 15 MPH.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can run as fast as an average fit person or 15 MPH(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou can run as fast as a professional athlete or 18 MPH.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can run as fast as a professional athlete or 18 MPH.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou can run as fast as the fastest sprinters in the world or 21 MPH.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can run as fast as the fastest sprinters in the world or 21 MPH.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou can run faster than the fastest sprinters in the world or 24 MPH.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can run faster than the fastest sprinters in the world or 24 MPH.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou can run obviously faster than any human or 30 MPH.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can run obviously faster than any human or 30 MPH.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou can run incredibly fast or 50 MPH.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can run incredibly fast or 50 MPH.(5)", ch, NULL, NULL, TO_ROOM);
      }
      else {
        int speed = UMAX(get_skill(ch, val), 0);
        speed -= 5;
        speed *= 20;
        speed += 50;
        sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou can run blurringly fast or %d MPH.(%d)", speed, get_skill(ch, val));
        act(buf, ch, NULL, NULL, TO_CHAR);
        sprintf(
        buf, "\t\t`WStat Report:`x$n\n\t$e can run blurringly fast or %d MPH.(%d)", speed, get_skill(ch, val));
        act(buf, ch, NULL, NULL, TO_ROOM);
      }

      break;
    case SKILL_CHARISMA:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou have about as much political know how as the average person.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is about as politically knowledgeable as the average person.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou are a bit more politically knowledgeable than average.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is a bit more politically knowledgeable than average.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou are significantly more politically savvy than average.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is significantly more politically savvy than average.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou are much more politically savvy than average.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is much more politically savvy than average.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou are incredibly good at politics.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is incredibly good at politics.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou are a master of politics.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is a master of politics.(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_NECRO:
      sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou have Necromancy ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_CHAR);
      sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e has Necromancy ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_ROOM);
      break;
    case SKILL_PYRO:
      sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou have Pyrokinesis ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_CHAR);
      sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e has Pyrokinesis ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_ROOM);
      break;
    case SKILL_CRYO:
      sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou have Cryokinesis ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_CHAR);
      sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e has Cryokinesis ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_ROOM);
      break;
    case SKILL_BIOMANCY:
      sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou have Biomancy ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_CHAR);
      sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e has Biomancy ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_ROOM);
      break;
    case SKILL_MAGNO:
      sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou have Magnokinesis ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_CHAR);
      sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e has Magnokinesis ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_ROOM);
      break;
    case SKILL_WEATHER:
      sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou have Weather ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_CHAR);
      sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e has Weather ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_ROOM);
      break;
    case SKILL_TELEKINESIS:
      sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou have Telekinesis ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_CHAR);
      sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e has Telekinesis ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_ROOM);
      break;
    case SKILL_HAEMOMANCY:
      sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou have Haemomancy ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_CHAR);
      sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e has Haemomancy ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_ROOM);
      break;
    case SKILL_COMBAT_ILLUSIONS:
      sprintf(
      buf, "\t\t`WStat Report:`xYou\n\tYou have Combat Illusions ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_CHAR);
      sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e has Combat Illusions ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_ROOM);
      break;
    case SKILL_PSYCHIC:
      sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou have Psychic ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_CHAR);
      sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e has Psychic ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_ROOM);
      break;
    case SKILL_NATURE:
      sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou have Nature ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_CHAR);
      sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e has Nature ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_ROOM);
      break;
    case SKILL_RIOT:
      sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou have Riot Control ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_CHAR);
      sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e has Riot Control ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_ROOM);
      break;
    case SKILL_COMMANDO:
      sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou have Comando ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_CHAR);
      sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e has Comando ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_ROOM);
      break;
    case SKILL_SOLDIER:
      sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou have Soldering ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_CHAR);
      sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e has Soldiering ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_ROOM);
      break;
    case SKILL_MARTIAL:
      sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou have Martial arts ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_CHAR);
      sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e has Martial arts ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_ROOM);
      break;
    case SKILL_GADGETS:
      sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou have Gadgets ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_CHAR);
      sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e has Gadgets ability of (%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_ROOM);
      break;
    case SKILL_EDUCATION:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou graduated high school.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has graduated high school.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == -1) {
        act("\t\t`WStat Report:`xYou\n\tYou never graduated high school.(-1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e never graduated high school.(-1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou're currently an undergraduate or have completed a lesser degree than a bachelor's.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is currently an undergraduate or has completed a lesser degree than a bachelor's.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou have completed an undergraduate degree.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has completed an undergraduate degree.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou have completed more than one degree or a Masters degree.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has completed more than one degree or a Masters degree.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou have completed a phD or MD.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has completed a phD or MD.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou are a professor or other academically established individual.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is a professor or other academically established individual.(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_FAME:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou are not famous.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is not famous.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou are locally famous in Haven.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is locally famous in Haven.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou are famous in some circles.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is famous in some circles.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou are very famous.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is very famous.(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_LANGUAGE2:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou do not speak a second language.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e does not speak a second language.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou speak a second language to a basic level.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e speaks a second language to a basic level.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou speak a second language to a moderate level.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e speaks a second language to a moderate level.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou speak a second language fluently.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e speaks a second language fluently.(3)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_LANGUAGE3:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou do not speak a third language.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e does not speak a third language.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou speak a third language to a basic level.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e speaks a third language to a basic level.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou speak a third language to a moderate level.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e speaks a third language to a moderate level.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou speak a third language fluently.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e speaks a third language fluently.(3)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_LANGUAGE4:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou do not speak a fourth language.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e does not speak a fourth language.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou speak a fourth language to a basic level.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e speaks a fourth language to a basic level.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou speak a fourth language to a moderate level.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e speaks a fourth language to a moderate level.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou speak a fourth language fluently.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e speaks a fourth language fluently.(3)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_LANGUAGE5:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou do not speak a fifth language.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e does not speak a fifth language.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou speak a fifth language to a basic level.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e speaks a fifth language to a basic level.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou speak a fifth language to a moderate level.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e speaks a fifth language to a moderate level.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou speak a fifth language fluently.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e speaks a fifth language fluently.(3)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_CAR:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou don't have a car.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e doesn't have a car.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou have a slow car.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a slow car.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou have a car of about average speed.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a car of about average speed.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou have a faster than average car.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a faster than average car.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou have a very fast car.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a very fast car.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou have an extremely fast car.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has an extremely fast car.(5)", ch, NULL, NULL, TO_ROOM);
      }

      break;
    case SKILL_BIKE:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou don't have a bike.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e doesn't have a bike.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou have a slow bike.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a slow bike.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou have a bike of about average speed.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a bike of about average speed.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou have a faster than average bike.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a faster than average bike.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou have a very fast bike.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a very fast bike.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou have an extremely fast bike.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has an extremely fast bike.(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_GAMES:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou're about average at playing games.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is about average at playing games.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou are better than average at playing games.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is better than average at playing games.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou are exceptionally good at playing games.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is exceptionally good at playing games.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou are phenomenally talented at playing games.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is phenomenally talented at playing games.(3)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_ART:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou have no artistic ability.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has no artistic ability.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou can perform the artistic ability %s to a hobbyist level.(1)", ch->pcdata->art1);
        act(buf, ch, NULL, NULL, TO_CHAR);
        sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e can perform the artistic ability %s to a hobbyist level.(1)", ch->pcdata->art1);
        act(buf, ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou can perform the artistic ability %s to a professional level.(3)", ch->pcdata->art1);
        act(buf, ch, NULL, NULL, TO_CHAR);
        sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e can perform the artistic ability %s to a professional level.(3)", ch->pcdata->art1);
        act(buf, ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou can perform the artistic ability %s as well as the best in the world.(5)", ch->pcdata->art1);
        act(buf, ch, NULL, NULL, TO_CHAR);
        sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e can perform the artistic ability %s as well as the best in the world.(5)", ch->pcdata->art1);
        act(buf, ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_ART2:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou have no second artistic ability.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has no second artistic ability.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou can perform the artistic ability %s to a hobbyist level.(1)", ch->pcdata->art2);
        act(buf, ch, NULL, NULL, TO_CHAR);
        sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e can perform the artistic ability %s to a hobbyist level.(1)", ch->pcdata->art2);
        act(buf, ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou can perform the artistic ability %s to a professional level.(3)", ch->pcdata->art2);
        act(buf, ch, NULL, NULL, TO_CHAR);
        sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e can perform the artistic ability %s to a professional level.(3)", ch->pcdata->art2);
        act(buf, ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou can perform the artistic ability %s as well as the best in the world.(5)", ch->pcdata->art2);
        act(buf, ch, NULL, NULL, TO_CHAR);
        sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e can perform the artistic ability %s as well as the best in the world.(5)", ch->pcdata->art2);
        act(buf, ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_ART3:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou have no third artistic ability.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has no third artistic ability.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou can perform the artistic ability %s to a hobbyist level.(1)", ch->pcdata->art3);
        act(buf, ch, NULL, NULL, TO_CHAR);
        sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e can perform the artistic ability %s to a hobbyist level.(1)", ch->pcdata->art3);
        act(buf, ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou can perform the artistic ability %s to a professional level.(3)", ch->pcdata->art3);
        act(buf, ch, NULL, NULL, TO_CHAR);
        sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e can perform the artistic ability %s to a professional level.(3)", ch->pcdata->art3);
        act(buf, ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou can perform the artistic ability %s as well as the best in the world.(5)", ch->pcdata->art3);
        act(buf, ch, NULL, NULL, TO_CHAR);
        sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e can perform the artistic ability %s as well as the best in the world.(5)", ch->pcdata->art3);
        act(buf, ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_ARTAMULET:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou have no skill with artificing amulets.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e does not have any skill with artificing amulets.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou have basic skill with artificing amulets.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has basic skill with artificing amulets(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou have basic skill with artificing amulets.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has basic skill with artificing amulets(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou have decent skill with artificing amulets.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has decent skill with artificing amulets(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou have advanced skill with artificing amulets.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has advanced skill with artificing amulets(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou have expert skill with artificing amulets.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has expert skill with artificing amulets(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_DODGING:
      sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou have melee defense.(%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_CHAR);
      sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e has melee defense.(%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_ROOM);
      break;
    case SKILL_EVADING:
      sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou have ranged defense.(%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_CHAR);
      sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e has ranged defense.(%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_ROOM);
      break;
    case SKILL_CPOLICE:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou don't have any police contacts.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e doesn't have any police contacts.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou have a low level contact in the police force.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a low level contact in the police force.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou have a low level friend in the police force.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a low level friend in the police force.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou have a mid level contact in the police force.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a mid level contact in the police force.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou have a high level contact in the police force.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a high level contact in the police force.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou have a very high level friend in the police force.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a very high level friend in the police force.(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_CMILITARY:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou don't have any military contacts.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e doesn't have any military contacts.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou have a low level contact in the military.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a low level contact in the military.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou have a low level friend in the military.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a low level friend in the military.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou have a mid level contact in the military.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a mid level contact in the military.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou have a high level contact in the military.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a high level contact in the military.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou have a very high level friend in the military.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a very high level friend in the military.(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_CGOVERNMENT:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou don't have any government contacts.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e doesn't have any government contacts.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou have a low level contact in the government.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a low level contact in the government.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou have a low level friend in the government.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a low level friend in the government.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou have a mid level contact in the government.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a mid level contact in the government.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou have a high level contact in the government.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a high level contact in the government.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou have a very high level friend in the government.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a very high level friend in the government.(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_CMEDIA:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou don't have any media contacts.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e doesn't have any media contacts.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou have a low level contact in the media.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a low level contact in the media.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou have a low level friend in the media.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a low level friend in the media.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou have a mid level contact in the media.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a mid level contact in the media.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou have a high level contact in the media.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a high level contact in the media.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou have a very high level friend in the media.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a very high level friend in the media.(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_CCRIMINAL:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou don't have any criminal contacts.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e doesn't have any criminal contacts.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou have a low level criminal contact.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a low level criminal.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou have a low level friend in the criminal underground.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a low level friend in the criminal underground.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou have a mid level contact in the criminal underground.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a mid level contact in the criminal underground.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou have a high level contact in the criminal underground.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a high level contact in the criminal underground.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou have a very high level friend in the criminal underground.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a very high level friend in the criminal underground.(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_CHOMELESS:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou don't have any homeless contacts.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e doesn't have any homeless contacts.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou have a contact amongst the homeless.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a contact amongst the homeless.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou have a friend amongst the homeless.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a friend amongst the homeless.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou have a good number of contacts amongst the homeless.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a good number of contacts amongst the homeless.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou have a very large number of contacts amongst the homeless.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a very large number of contacts amongst the homeless.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou have a very large number of friends amongst the homeless.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a very large number of friends amongst the homeless.(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_COCCULT:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou don't have any occult contacts.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e doesn't have any occult contacts.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou know someone who dabbles in the occult.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e knows someone who dabbles in the occult.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou have a friend who dabbles in the occult.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a friend who dabbles in the occult.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou know someone who is routinely involved in the occult.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e knows someone who is routinely involved in the occult.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou know someone who is considered to be an expert in the occult.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e knows someone who is considered to be an expert in the occult.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou are friends with someone who is considered to be an expert in the occult.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is friends with someone who is considered to be an expert in the occult.(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_RITUALISM:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou have no special knoweldge of rituals.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has no special knowledge of rituals.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou have basic ritual knowledge.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has basic ritual knoweldge.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou have decent ritual knowledge.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has decent ritual knowledge.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou have a professional level of ritual knowledge.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a professional level of ritual knowledge.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou are an expert on rituals.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is an expert on rituals.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou are one of the most skilled ritualists in the world.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is one of the most skilled ritualists in the world.(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_DEMOLITIONS:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou can't make things blow up.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can't make things blow up.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou can use pipe bombs and similar explosives.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can use pipe bombs and similar explosives.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou can use improvised and military grade explosives.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can use improvised and military grade explosives.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou can shape explosions and use any type or grade of demolition.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can shape explosions and use any type or grade of demolition.(3)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_HACKING:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou can't hack anything.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can't hack anything.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou can sniff out unencrypted information sent over the internet.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can sniff out unencrypted information sent over the internet.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou can sniff out and read simply encrypted materials sent over the internet, e.g. e-mails.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can sniff out and read simply encrypted materials sent over the internet, e.g. e-mails.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou can hack into unprotected or very poorly protected PCs.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can hack into unprotected or very poorly protected PCs.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou can hack into almost any PC and read almost any legally encrypted material sent over the internet.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can hack into almost any PC and read almost any legally encrypted material sent over the internet.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou can hack into most professionally encrypted sites and often decrypt military grade encrypted messages.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can hack into most professionally encrypted sites and often decrypt military grade encrypted messages.(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_STEALTH:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou're not stealthy.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is not stealthy.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou can blend in, making you more difficult to spot.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can blend in, making $m more difficult to spot.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou can blend in and move quietly, making you difficult to detect.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can blend in and move quietly, making $m difficult to detect.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou can stay out of people's sight lines, making you very difficult to detect.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can stay out of people's sight lines, making $m very difficult to detect.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou can move without making a single sound.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can move without making a single sound.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou can can blend into any background and move completely silently.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can blend into any background and move completely silently.(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_PERCEPTION:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou're about as perceptive as an average person.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is about as perceptive as an average person.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == -1) {
        act("\t\t`WStat Report:`xYou\n\tYou are very unperceptive.(-1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is very unperceptive.(-1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou are more perceptive than the average person.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is more perceptive than the average person.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou are very perceptive.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is very perceptive.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou are extremely perceptive.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is extremely perceptive.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou are more perceptive than any human.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is more perceptive than any human.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou are extremely supernaturally perceptive.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is extremely supernaturally perceptive.(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_MEDICINE:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou have no medical training.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has no medical training.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou know basic first aid.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e knows basic first aid.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou know advanced first aid.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e knows advanced first aid.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou have some level of professional medical training, like a paramedic or nurse.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has some level of professional medical training, like a paramedic or nurse.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou have the equivalent medical training of a doctor.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has the equivalent medical training of a doctor.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou are as capable medically as the best doctors.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is as medically capable as the best doctors.(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_DEMONOLOGY:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou have no special knowledge of the supernatural.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has no special knowledge of the supernatural.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou have basic supernatural knowledge.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has basic supernatural knowledge.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou have decent supernatural knowledge.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has decent supernatural knowledge.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou have professional research level knowledge of the supernatural.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has professional research level knowledge of the supernatural.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou are a renown expert on the supernatural.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is a renown expert on the supernatural.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou are one of the premier experts on the supernatural in the world.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is one of the premier experts on the supernatural in the world.(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_ENGINEERING:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou have no engineering skill.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has no engineering skill.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou can design or build simple devices.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can design or build simple devices.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou can design and build commercial quality devices.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can design and build commercial quality devices.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou can design and build cutting edge quality devices.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can design and build cutting edge quality devices.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou can design and build military quality devices.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can design and build military quality devices.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou can design and build more advanced devices than anything that currently exists.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can design and build more advanced devices than anything that currently exists.(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_HANDYMAN:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou're not very handy.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is not very handy.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou can fix simple broken things.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can fix simple broken things.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou can fix most every day things when they break.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can fix most every day things when they break.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou can fix most commercial machinery when it breaks.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can fix most commercial machinery when it breaks.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou can fix military grade machinery when it breaks.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can fix military grade machinery when it breaks.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou can repair things that haven't even been invented yet.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can repair things that haven't even been invented yet.(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_STAMINA:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou've the stamina of an average person.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has the stamina of an average person.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == -1) {
        act("\t\t`WStat Report:`xYou\n\tYou tire just going up the stairs.(-1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e tires just going up the stairs.(-1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou have a bit more stamina than an average person.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e have a bit more stamina than an average person.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou have the stamina of an athlete.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has the stamina of an athlete.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou have the stamina of an endurance athlete.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has the stamina of an endurance athlete.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou have the stamina of one of the best endurance athletes in the world.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has the stamina of one of the best endurance athletes in the world.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou have more stamina than any human could have.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has more stamina than any human could have.(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_LARCENY:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou have no skill at larceny.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has no skill at larceny.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou can get away with shoplifting from most stores.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can get away with shoplifting from most stores.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou can pick simple locks.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can pick simple locks.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou can pick the pockets of most people.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can pick the pockets of most people.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou can pick advanced locks.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can pick advanced locks.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou can pick almost any lock and override almost any security system.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can pick almost any lock and override almost any security system.(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_ANIMALS:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou have no skill with animals.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has no skill with animals.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == -1) {
        act("\t\t`WStat Report:`xYou\n\tAnimals hate you.(-1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\tAnimals hate $m.(-1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou get along pretty well with animals.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e gets along pretty well with animals.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou are really good with animals.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is really good with animals.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou have a natural bond with animals.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a natural bond with animals.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou are almost empathic when it comes to understanding and communicating with animals.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is almost empathic when it comes to understanding and communicating with animals.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou have a supernatural bond with animals.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a supernatural bond with animals.(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_MARTIALART:
      sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou have melee specialization.(%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_CHAR);
      sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e has melee specialization.(%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_ROOM);
      break;
    case SKILL_COMBATTRAINING:
      sprintf(buf, "\t\t`WStat Report:`xYou\n\tYou have ranged specialization.(%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_CHAR);
      sprintf(buf, "\t\t`WStat Report:`x$n\n\t$e has ranged specialization.(%d)", get_skill(ch, val));
      act(buf, ch, NULL, NULL, TO_ROOM);
      break;
    case SKILL_FASTREFLEXES:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou have normal reflexes.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has normal reflexes.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou have faster reflexes than most people.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has faster reflexes than most people.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou have incredibly quick reflexes.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has incredibly quick reflexes.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou have supernaturally quick reflexes.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has supernaturally quick reflexes.(3)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_ACUTESIGHT:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou have normal vision.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has normal vision.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou have particularly acute vision.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has particularly acute vision.(1)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_ACUTEHEAR:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou have normal hearing.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has normal hearing.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou have particularly acute hearing.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has particularly acute hearing.(1)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_ACUTESMELL:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou have a normal sense of smell.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a normal sense of smell.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou have a particularly acute sense of smell.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a particularly acute sense of smell.(1)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_SUNRESIST:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou have no sunlight resistance.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has no sunlight resistance.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou are resistant to the effects of sunlight.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is resistant to the effects of sunlight.(3)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_ICEPROOF:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou have no cold resistance.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has no cold resistance.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou are immune to the cold.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is immune to the cold.(2)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_FIREPROOF:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou have no fire resistance.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has no fire resistance.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou are immune to fire and heat.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is immune to fire and heat.(2)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_ELECPROOF:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou have no electricity resistance.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has no electricity resistance.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou are immune to electricity and lightning.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is immune to electricity and lightning.(2)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_IMMORTALITY:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou are not immortal.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is not immortal.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou cannot be killed by normal means.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e cannot be killed by normal means.(2)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_CLAIRAUDIENCE:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou are incapable of clairaudience.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is incapable of clairaudience.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou are clairaudient(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is clairaudient.(2)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_CLAIRVOYANCE:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou are incapable of clairvoyance.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is incapable of clairvoyance.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou have limited clairvoyance.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has limited clairvoyance.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou are clairvoyant.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is clairvoyant.(2)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_KNOWVAMP:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou cannot detect vampires.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e cannot detect vampires.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou can detect vampires.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can detect vampires.(2)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_KNOWWERE:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou cannot detect werewolves.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e cannot detect werewolves.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou can detect werewolves.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can detect werewolves.(2)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_KNOWMAGE:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou cannot detect supernaturals.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e cannot detect supernaturals.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou can detect supernaturals.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can detect supernaturals.(2)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_FORENSICS:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou have no knowledge of forensics.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has no knowledge of forensics.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou have solid forensics knowledge.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has solid forensics knowledge.(2)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_FLESHFORMED:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou are entirely physically human.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is entirely physically human.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou have some inhuman physical attributes.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has some inhuman physical attributes.(1)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_MISTVISION:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou can't see through mist.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e cannot see through mist.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else {
        act("\t\t`WStat Report:`xYou\n\tYou can see through mist.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can see through mist.(2)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_HYPERREGEN:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou have no hyper-regenerative abilities.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has no hyper-regenerative abilities.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else {
        act("\t\t`WStat Report:`xYou\n\tYou are capable of hyper-regeneration.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e is capable of hyper-regeneration.(3)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_MESMERIZING:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou have no supernatural attractiveness.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has no supernatural attractiveness.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else {
        act("\t\t`WStat Report:`xYou\n\tYou have mesmerizing powers of attractiveness.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has mesmerizing powers of attractiveness.(3)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_ARMORED:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou have normal skin.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has normal skin.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else {
        act("\t\t`WStat Report:`xYou\n\tYou have mystically armored skin.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has mystically armored skin.(3)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_GUARDEDMIND:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou have an unguarded mind.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has an unguarded mind.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else {
        act("\t\t`WStat Report:`xYou\n\tYou have a mystically guarded mind.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a mysticall guarded mind.(3)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_ILLUSIONS:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou cannot create illusions.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e cannot create illusions.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou can create illusions.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e can create illusions.(2)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_AGELESS:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou age normally.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e ages normally.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou do not age.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e does not age.(4)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_ALLIES:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou don't have any allies.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e doesn't have any allies.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou have a few, not particularly powerful, allies.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a few, not particularly powerful, allies.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou have several not particularly powerful allies.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has several not particularly powerful allies.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou have a few powerful allies.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a few powerful allies.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou have several powerful allies.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has several powerful allies.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou have a lot of very powerful allies.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a lot of very powerful allies.(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case SKILL_MINIONS:
      if (get_skill(ch, val) == 0) {
        act("\t\t`WStat Report:`xYou\n\tYou don't have any minions.(0)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e doesn't have any minions.(0)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 1) {
        act("\t\t`WStat Report:`xYou\n\tYou have a few, not particularly powerful, minions.(1)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a few, not particularly powerful, minions.(1)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 2) {
        act("\t\t`WStat Report:`xYou\n\tYou have several not particularly powerful minions.(2)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has several not particularly powerful minions.(2)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 3) {
        act("\t\t`WStat Report:`xYou\n\tYou have a few powerful minions.(3)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a few powerful minions.(3)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 4) {
        act("\t\t`WStat Report:`xYou\n\tYou have several powerful minions.(4)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has several powerful minions.(4)", ch, NULL, NULL, TO_ROOM);
      }
      else if (get_skill(ch, val) == 5) {
        act("\t\t`WStat Report:`xYou\n\tYou have a lot of very powerful minions.(5)", ch, NULL, NULL, TO_CHAR);
        act("\t\t`WStat Report:`x$n\n\t$e has a lot of very powerful minions.(5)", ch, NULL, NULL, TO_ROOM);
      }
      break;
    }
  }

  _DOFUN(do_hide) {
    if (is_ghost(ch) || is_dead(ch)) {
      send_to_char("You are already hidden from sight.\n\r", ch);
    }
    if (guestmonster(ch))
    return;

    if (ch->pcdata->patrol_status != 0) {
      char buf[MSL];
      if (ch->pcdata->patrol_target == NULL)
      sprintf(buf, "PATROLPRED HIDE: Ch, %s, Status: %d", ch->name, ch->pcdata->patrol_status);
      else
      sprintf(buf, "PATROLPRED HIDE: Ch, %s, Status: %d, Target: %s", ch->name, ch->pcdata->patrol_status, ch->pcdata->patrol_target->name);
      log_string(buf);
    }

    if (ch->pcdata->patrol_status == PATROL_DECURSING || ch->pcdata->patrol_status == PATROL_HOLDING_ARTIFACT || ch->pcdata->patrol_status == PATROL_GHOST_FOCUS || (ch->pcdata->patrol_status >= PATROL_WARMOVINGATTACK && ch->pcdata->patrol_status <= PATROL_WAGINGWAR)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }

    if (in_fight(ch) || is_helpless(ch) || room_hostile(ch->in_room)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }

    if (IS_FLAG(ch->act, PLR_HIDE)) {
      send_to_char("You are already hidden.\n\r", ch);
      return;
    }

    for (CharList::iterator it = ch->in_room->people->begin();
    it != ch->in_room->people->end(); ++it) {
      CHAR_DATA *rch = *it;

      if (IS_NPC(rch))
      continue;

      if (can_see(rch, ch)) {
        if (rch->pcdata->cansee == NULL || rch->pcdata->cansee->in_room != rch->in_room || !IS_FLAG(rch->pcdata->cansee->act, PLR_HIDE))
        rch->pcdata->cansee = ch;
        else if (rch->pcdata->cansee2 == NULL || rch->pcdata->cansee2->in_room != rch->in_room || !IS_FLAG(rch->pcdata->cansee->act, PLR_HIDE))
        rch->pcdata->cansee2 = ch;
        else if (rch->pcdata->cansee3 == NULL || rch->pcdata->cansee3->in_room != rch->in_room || !IS_FLAG(rch->pcdata->cansee->act, PLR_HIDE))
        rch->pcdata->cansee3 = ch;
        act("$n finds a place to hide $mself.", ch, NULL, rch, TO_VICT);
      }
    }

    send_to_char("You find a place to hide yourself.\n\r", ch);
    SET_FLAG(ch->act, PLR_HIDE);
  }

  _DOFUN(do_unhide) {
    if (safe_strlen(argument) < 2) {
      if (!IS_FLAG(ch->act, PLR_HIDE)) {
        send_to_char("You aren't hiding.\n\r", ch);
        return;
      }

      send_to_char("You come out of hiding.\n\r", ch);
      act("$n emerges from hiding.", ch, NULL, NULL, TO_ROOM);
      REMOVE_FLAG(ch->act, PLR_HIDE);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
    }
    else {
      CHAR_DATA *victim;

      if ((victim = get_char_room(ch, NULL, argument)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }

      if (!IS_FLAG(victim->act, PLR_HIDE)) {
        send_to_char("They're not hiding.\n\r", ch);
        return;
      }

      act("You pull $N from hiding.", ch, NULL, victim, TO_CHAR);
      act("$n pulls you from hiding.", ch, NULL, victim, TO_VICT);
      act("$n pulls $N from hiding.", ch, NULL, victim, TO_NOTVICT);
      REMOVE_FLAG(victim->act, PLR_HIDE);
      WAIT_STATE(victim, PULSE_PER_SECOND * 10);
    }
  }

  void clear_flags(CHAR_DATA *target) {
    if (IS_FLAG(target->affected_by, AFF_STAKED))
    REMOVE_FLAG(target->affected_by, AFF_STAKED);
    if (IS_FLAG(target->comm, COMM_FEEDING))
    REMOVE_FLAG(target->comm, COMM_FEEDING);
    if (IS_FLAG(target->act, PLR_SHROUD))
    REMOVE_FLAG(target->act, PLR_SHROUD);
    if (IS_FLAG(target->act, PLR_DEEPSHROUD))
    REMOVE_FLAG(target->act, PLR_DEEPSHROUD);
    if (IS_FLAG(target->act, PLR_DEMONPACT))
    REMOVE_FLAG(target->act, PLR_DEMONPACT);
    if (IS_FLAG(target->act, PLR_VILLAIN))
    REMOVE_FLAG(target->act, PLR_VILLAIN);
    if (IS_FLAG(target->act, PLR_INVIS))
    REMOVE_FLAG(target->act, PLR_INVIS);
    if (IS_FLAG(target->act, PLR_TYRANT))
    REMOVE_FLAG(target->act, PLR_TYRANT);
    if (IS_FLAG(target->act, PLR_ASCENDING))
    REMOVE_FLAG(target->act, PLR_ASCENDING);
    if (IS_FLAG(target->comm, COMM_RESEARCHED))
    REMOVE_FLAG(target->comm, COMM_RESEARCHED);
    if (IS_FLAG(target->comm, COMM_FORCEDPACIFIST))
    REMOVE_FLAG(target->comm, COMM_FORCEDPACIFIST);
    if (IS_FLAG(target->comm, COMM_CLEANSED))
    REMOVE_FLAG(target->comm, COMM_CLEANSED);
    if (IS_FLAG(target->comm, COMM_EMPOWERED))
    REMOVE_FLAG(target->comm, COMM_EMPOWERED);
    if (IS_FLAG(target->comm, COMM_SHADOWCLOAK))
    REMOVE_FLAG(target->comm, COMM_SHADOWCLOAK);
    if (IS_FLAG(target->comm, COMM_MANDRAKE))
    REMOVE_FLAG(target->comm, COMM_MANDRAKE);
    if (IS_FLAG(target->comm, COMM_NOFRIGID))
    REMOVE_FLAG(target->comm, COMM_NOFRIGID);
    if (IS_FLAG(target->act, PLR_MADERELIC))
    REMOVE_FLAG(target->act, PLR_MADERELIC);
    if (IS_FLAG(target->act, PLR_BOUND))
    REMOVE_FLAG(target->act, PLR_BOUND);
    if (IS_FLAG(target->act, PLR_BOUNDFEET))
    REMOVE_FLAG(target->act, PLR_BOUNDFEET);
  }

  _DOFUN(do_reroll) {
    DESCRIPTOR_DATA d;
    int i;
    char strsave[MSL];
    char arg1[MSL], arg2[MSL];
    OBJ_DATA *obj;
    argument = one_argument_nouncap(argument, arg2);
    int colours, bandaids, renames;
    CHAR_DATA *target;

    if (IS_FLAG(ch->act, PLR_NOSAVE))
    return;

    if (is_gm(ch) && !IS_IMMORTAL(ch)) {
      send_to_char("You're a storyrunner.\n\r", ch);
      return;
    }
    if (IS_FLAG(ch->act, PLR_GUEST))
    return;
    if (IS_FLAG(ch->act, PLR_STASIS))
    return;

    if(higher_power(ch))
    return;


    if (get_rosterchar(ch->name) != NULL && !str_cmp(get_rosterchar(ch->name)->owner, "Daed")) {
      send_to_char("This character cannot be rerolled.\n\r", ch);
      return;
    }

    sprintf(arg1, "%s", capitalize(arg2));

    argument = one_argument_nouncap(argument, arg2);

    if (is_roster_char(ch)) {
      send_to_char("You can't delete a character fresh off the roster.\n\r", ch);
      return;
    }

    if (!immaccount_name(ch->pcdata->account->name)) {
      if (character_account_count(ch->pcdata->account) >= 7) {
        send_to_char("You already have 6 characters, delete one first.\n\r", ch);
        return;
      }

      if (total_account_count(ch->pcdata->account) >= 11) {
        send_to_char("You already have 10 characters, delete one first.\n\r", ch);
        return;
      }
    }

    if (!immaccount_name(ch->pcdata->account->name)) {
      if (character_account_count(ch->pcdata->account) >= 7) {
        send_to_char("You already have 6 characters, delete one first.\n\r", ch);
        return;
      }

      if (total_account_count(ch->pcdata->account) >= 11) {
        send_to_char("You already have 10 characters, delete one first.\n\r", ch);
        return;
      }
    }

    if (IS_IMMORTAL(ch)) {
      if ((target = get_char_world(ch, arg1)) == NULL || IS_NPC(target)) {
        send_to_char("Can't locate player.  Searching for a stat or discipline...\n\r", ch);
        target = ch;
      }
      else {
        strcpy(arg1, arg2);
      }
    }
    else {
      target = ch;
    }

    if (arg1[0] == '\0') {
      send_to_char("reroll as who?\n\r", ch);
      if (IS_FLAG(target->act, PLR_REROLL)) {
        REMOVE_FLAG(target->act, PLR_REROLL);
        send_to_char("Reroll cleared.\n\r", ch);
      }
      return;
    }
    if (!str_cmp(arg1, "self")) {
      send_to_char("Did you mean reroll reset?\n\r", ch);
      return;
    }
    if (!str_cmp(arg1, "reset")) {
      if (!IS_FLAG(target->act, PLR_REROLL)) {
        SET_FLAG(target->act, PLR_REROLL);
        send_to_char("Type reroll reset again to continue, reroll by itself to clear.\n\r", ch);
        return;
      }
      REMOVE_FLAG(target->act, PLR_REROLL);
      ch->pcdata->training_disc = 0;
      ch->pcdata->training_stat = 0;
      if (IS_IMMORTAL(ch)) {
        if (IS_FLAG(target->act, PLR_DEAD)) {
          REMOVE_FLAG(target->act, PLR_DEAD);
          target->pcdata->final_death_date = 0; // resetting death date - Discordance
        }
        target->pcdata->account->xp += target->spentexp;
        target->pcdata->account->rpxp += target->spentrpexp;
      }
      else {
        target->pcdata->rerollselftime = current_time;
        if (target->spentexp > 350000) {
          target->spentexp -= 350000;
          target->pcdata->account->xp += 350000;
          target->pcdata->account->xp += target->spentexp * 8 / 10;
        }
        else
        target->pcdata->account->xp += target->spentexp;
        if (target->spentrpexp > 350000) {
          target->spentrpexp -= 350000;
          target->pcdata->account->rpxp += 350000;
          target->pcdata->account->rpxp += target->spentrpexp * 8 / 10;
        }
        else
        target->pcdata->account->rpxp += target->spentrpexp;
      }
      //      target->pcdata->account->rpxp += target->pcdata->dexp/5;
      //      target->pcdata->dexp = 0;
      target->spentexp = 0;
      target->spentrpexp = 0;
      for (i = 0; i <= DIS_USED; i++) {
        target->disciplines[i] = 0;
      }
      for (i = 0; i <= SKILL_USED; i++) {
        target->skills[i] = 0;
      }
      for (int x = 0; x < 300; x++) {
        int point = x;
        target->pcdata->stat_log_stat[point] = 0;
        target->pcdata->stat_log_from[point] = 0;
        target->pcdata->stat_log_to[point] = 0;
        target->pcdata->stat_log_cost[point] = 0;
        target->pcdata->stat_log_method[point] = 0;
        free_string(target->pcdata->stat_log_string[point]);
        target->pcdata->stat_log_string[point] = str_dup("");
      }

      target->newexp = STARTING_EXP;
      target->newrpexp = STARTING_RPEXP;
      target->spentnewexp = 0;
      target->spentnewrpexp = 0;
      for (int x = 0; x < 10; x++)
      target->pcdata->previous_focus_vnum[x] = 0;
      send_to_char("Done.\n\r", ch);
      return;
    }

    if (target->pcdata->account != NULL && target->pcdata->account->newcharcount <= 0) {
      send_to_char("You made a new character too recently, you should play your existing character for a while longer.\n\r", ch);
      return;
    }

    log_string("DESCRIPTOR: Reroll");

    d.original = NULL;
    if (load_char_obj(&d, arg1)) {
      send_to_char("A character with that name already exists.\n\r", ch);
      if (IS_FLAG(target->act, PLR_REROLL)) {
        REMOVE_FLAG(target->act, PLR_REROLL);
        send_to_char("Reroll cleared.\n\r", ch);
      }
      return;
    }

    if (!IS_FLAG(target->act, PLR_REROLL)) {
      SET_FLAG(target->act, PLR_REROLL);
      send_to_char("Type reroll <name> again to continue, reroll by itself to clear.\n\r", ch);
      return;
    }
    if (IS_FLAG(target->act, PLR_GUEST))
    return;
    if (IS_FLAG(target->act, PLR_GM))
    return;

    stop_fighting(target, TRUE);
    REMOVE_FLAG(target->act, PLR_REROLL);

    target->abomination = 0;

    target->pcdata->account->pkarmaspent -= ch->spentpkarma;
    target->pcdata->account->pkarmaspent =
    UMAX(target->pcdata->account->pkarmaspent, 0);

    if (target->played / 3600 > 100)
    retire_character(target);

    if (target->pcdata->account != NULL) {
      for (int i = 0; i < 25; i++) {
        if (!str_cmp(target->pcdata->account->characters[i], target->name)) {
          free_string(target->pcdata->account->characters[i]);
          target->pcdata->account->characters[i] = str_dup(capitalize(arg1));
        }
      }
    }

    if (IS_FLAG(target->act, PLR_DEAD)) {
      REMOVE_FLAG(target->act, PLR_DEAD);
      target->pcdata->final_death_date = 0; // resetting death date - Discordance
    }

    if (IS_IMMORTAL(ch)) {
      target->pcdata->account->xp += target->spentexp;
      target->pcdata->account->rpxp += target->spentrpexp;
    }
    else {
      if (target->spentexp > 350000) {
        target->spentexp -= 350000;
        target->pcdata->account->xp += 350000;
        target->pcdata->account->xp += target->spentexp * 8 / 10;
      }
      else
      target->pcdata->account->xp += target->spentexp;
      if (target->spentrpexp > 350000) {
        target->spentrpexp -= 350000;
        target->pcdata->account->rpxp += 350000;
        target->pcdata->account->rpxp += target->spentrpexp * 8 / 10;
      }
      else
      target->pcdata->account->rpxp += target->spentrpexp;
    }
    target->pcdata->account->karmabank += target->spentkarma;
    target->pcdata->account->rpxp += target->pcdata->dexp / 5;

    target->spentexp = 0;
    target->spentrpexp = 0;
    target->spentkarma = 0;
    colours = target->pcdata->colours;
    bandaids = target->pcdata->bandaids;
    renames = target->pcdata->renames;
    for (i = 0; i <= DIS_USED; i++) {
      target->disciplines[i] = 0;
    }
    for (i = 0; i <= SKILL_USED; i++) {
      target->skills[i] = 0;
    }
    target->newexp = STARTING_EXP;
    target->newrpexp = STARTING_RPEXP;
    target->spentnewexp = 0;
    target->spentnewrpexp = 0;
    target->spentpkarma = 0;
    remove_from_vassalroster(target->name, target->vassal);
    target->vassal = 0;
    room_purge(target);
    remove_from_clanroster(target->name, target->faction);
    remove_from_clanroster(target->name, target->factiontwo);
    target->faction = 0;
    target->factiontwo = 0;

    char buf[MSL];
    sprintf(buf, "rm haven/prp/%s.txt", target->name);
    system(buf);
    sprintf(buf, "rm haven/ptm/%s.txt", target->name);
    system(buf);


    sr_reroll(target, arg1);
    sprintf(strsave, "%s%s", PLAYER_DIR, capitalize(target->name));
    wiznet("$N rerolls.", target, NULL, 0, 0, 0);

    char_from_room(target);
    char_to_room(target, get_room_index(ROOM_INDEX_GENESIS));

    arg1[0] = UPPER(arg1[0]);

    int p = 0;
    for (ObjList::iterator it = object_list.begin();
    it != object_list.end() && p < 500000; p++) {
      obj = *it;
      ++it;

      if (obj == NULL)
      continue;

      if (obj->carried_by == target) {
        obj_from_char(obj);
        extract_obj(obj);
      }
    }

    if (target->pcdata->account != NULL) {
      for (int i = 0; i < 25; i++) {
        if (!str_cmp(target->pcdata->account->characters[i], target->name)) {
          free_string(target->pcdata->account->characters[i]);
          target->pcdata->account->characters[i] = str_dup(arg1);
        }
      }
    }
    ACCOUNT_TYPE *account = target->pcdata->account;
    char *temp;
    temp = str_dup(target->pcdata->storyrunner);
    target->shape = SHAPE_HUMAN;
    target->wounds = 0;
    target->heal_timer = 0;
    target->death_timer = 0;
    set_pcdata_default(target->pcdata);
    VALIDATE(target->pcdata);
    free_string(target->pcdata->storyrunner);
    target->pcdata->storyrunner = str_dup(temp);
    free_string(target->name);
    target->name = str_dup(arg1);
    target->id = get_pc_id();
    target->played = 0;
    target->pcdata->account = account;
    free_string(target->short_descr);
    target->short_descr = str_dup(arg1);
    free_string(target->long_descr);
    target->long_descr = str_dup(arg1);
    target->money = 0;
    target->pcdata->total_money = 0;
    target->pcdata->colours = colours;
    target->pcdata->bandaids = bandaids;
    target->pcdata->renames = renames;

    clear_flags(target);

    unlink(strsave);

    target->desc->connected = CON_PLAYING;
    do_function(target, &do_save, "");
    save_account(target->pcdata->account, FALSE);
    page_to_char(help_story, ch);
  }

  _DOFUN(do_storyrunner) {
    if (ch->pcdata->ci_editing == 12) {
      ch->pcdata->ci_absorb = 1;
      free_string(ch->pcdata->ci_taste);
      ch->pcdata->ci_taste = str_dup(argument);
      send_to_char("Done.\n\r", ch);
      return;
    }

    if (is_gm(ch) && !IS_IMMORTAL(ch)) {
      if (in_fight(ch) || room_hostile(ch->in_room) || is_pinned(ch)) {
        send_to_char("Not now.\n\r", ch);
        return;
      }
      revert_from_sr(ch);
      return;
    }
    else {
      if (!can_logoff(ch)) {
        send_to_char("You can't sleep here, you should try getting a house, renting a room at the Antlers or sleeping at the Longhouse.\n\r", ch);
        return;
      }

      if (in_fight(ch) || room_hostile(ch->in_room) || is_pinned(ch)) {
        send_to_char("Not now.\n\r", ch);
        return;
      }
      if (ch->played / 3600 < 48 && !higher_power(ch)) {
        send_to_char("You need to get to 50 hours first.\n\r", ch);
        return;
      }

      if (ch->in_room->area->vnum == 0) {
        send_to_char("You can't SR from Chargen.\n\r", ch);
        return;
      }
      if (ch->pcdata->account != NULL && IS_FLAG(ch->pcdata->account->flags, ACCOUNT_NOSR)) {
        send_to_char("You can't SR due to previous problems.\n\r", ch);
        return;
      }
      convert_to_sr(ch);
      char_from_room(ch);
      char_to_room(ch, get_room_index(60));
      if (ch->pcdata->account->haven_books > 0)
      send_to_char("You can create a new entry in the Haven book, set in Haven Township, somewhere else in earth, or somewhere offworld.\n\r", ch);
      if (ch->pcdata->account->earth_books > 0)
      send_to_char("You can create a new entry in the Haven book, set somewhere else in earth, or somewhere offworld.\n\r", ch);
      if (ch->pcdata->account->world_books > 0)
      send_to_char("You can create a new entry in the Haven book, set somewhere offworld.\n\r", ch);
      return;
    }
  }

  _DOFUN(do_guest) {
    DESCRIPTOR_DATA d;
    char arg[MSL];
    OBJ_DATA *obj;
    char strsave[MSL];
    char tempname[MSL];
    char arg1[MSL];
    char buf[MSL];
    if (ch->pcdata->next_henchman == 0)
    return;


    argument = one_argument_nouncap(argument, arg1);
    one_argument(argument, buf);
    sprintf(arg, "%s", capitalize(buf));
    int type = 0;
    if (higher_power(ch))
    return;
    if (!str_cmp(arg1, "plot")) {
      if (!is_gm(ch) || !has_plot(ch)) {
        send_to_char("Only a storyrunner with a plot can do that.\n\r", ch);
        return;
      }
      type = GUEST_PLOT;
    }
    else if (!str_cmp(arg1, "cardinal") && IS_IMMORTAL(ch)) {
      type = GUEST_CARDINAL;
    }
    else if (!str_cmp(arg1, "henchman")) {
      if (is_gm(ch) || higher_power(ch)) {
        send_to_char("SRs cannot have henchmen.\n\r", ch);
        return;
      }
      if (get_tier(ch) < 3) {
        send_to_char("You're too low a tier to have this type of guest.\n\r", ch);
        return;
      }
      if (ch->pcdata->next_henchman > current_time) {
        send_to_char("You can't do that yet.\n\r", ch);
        return;
      }
      type = GUEST_HENCHMAN;
    }
    else if (!str_cmp(arg1, "enemy")) {
      if (is_gm(ch) || higher_power(ch)) {
        send_to_char("SRs cannot have enemies.\n\r", ch);
        return;
      }

      if (get_tier(ch) < 2) {
        send_to_char("You're too low a tier to have this type of guest.\n\r", ch);
        return;
      }
      if (ch->pcdata->next_enemy > current_time) {
        send_to_char("You can't do that yet.\n\r", ch);
        return;
      }
      type = GUEST_ENEMY;
    }
    else if (!str_cmp(arg1, "monster")) {
      if (!IS_IMMORTAL(ch)) {
        if (is_gm(ch)) {
          send_to_char("SRs cannot herald monsters.\n\r", ch);
          return;
        }

        if (get_tier(ch) < 2) {
          send_to_char("You're too low a tier to have this type of guest.\n\r", ch);
          return;
        }
        if (ch->pcdata->next_monster > current_time) {
          send_to_char("You can't do that yet.\n\r", ch);
          return;
        }

        if (fetch_guestmonster() != NULL) {
          send_to_char("There is already a monster in Haven.\n\r", ch);
          return;
        }
      }
      type = GUEST_MONSTER;
    }
    else if (!str_cmp(arg1, "nightmare")) {
      if (is_gm(ch)) {
        send_to_char("SRs cannot have enemies.\n\r", ch);
        return;
      }
      if (!IS_FLAG(ch->pcdata->account->flags, ACCOUNT_NIGHTMARE)) {
        send_to_char("You need a monster to have previously survived long enough to become a living nightmare.\n\r", ch);
        return;
      }
      type = GUEST_NIGHTMARE;
    }
    else {
      send_to_char("Syntax: Guest Plot/Henchman/Enemy/Monster/Nightmare (name)\n\r", ch);
      return;
    }

    if (arg[0] == '\0') {
      send_to_char("Syntax: guest (name)?\n\r", ch);
      if (IS_FLAG(ch->act, PLR_REROLL)) {
        REMOVE_FLAG(ch->act, PLR_REROLL);
        send_to_char("Guest cleared.\n\r", ch);
      }
      return;
    }

    if (!str_cmp(ch->name, arg)) {
      send_to_char("A character with that name already exists.\n\r", ch);
      if (IS_FLAG(ch->act, PLR_REROLL)) {
        REMOVE_FLAG(ch->act, PLR_REROLL);
        send_to_char("Guest cleared.\n\r", ch);
      }
      return;
    }
    log_string("DESCRIPTOR: Guest");

    d.original = NULL;
    if (load_char_obj(&d, arg)) {
      send_to_char("A character with that name already exists.\n\r", ch);
      if (IS_FLAG(ch->act, PLR_REROLL)) {
        REMOVE_FLAG(ch->act, PLR_REROLL);
        send_to_char("Guest cleared.\n\r", ch);
      }
      return;
    }

    if (!IS_FLAG(ch->act, PLR_REROLL)) {
      SET_FLAG(ch->act, PLR_REROLL);
      send_to_char("Type guest (type) <name> again to continue, guest by itself to clear.\n\r", ch);
      return;
    }
    int tier = 0;
    if (type == GUEST_PLOT || type == GUEST_STAFF)
    tier = 3;
    if (type == GUEST_CARDINAL)
    tier = 5;
    if (type == GUEST_HENCHMAN)
    tier = get_tier(ch) - 1;
    if (type == GUEST_ENEMY)
    tier = get_tier(ch);
    if (type == GUEST_MONSTER)
    tier = 5;
    if (type == GUEST_NIGHTMARE)
    tier = 5;

    int starttier = get_tier(ch);
    if (IS_IMMORTAL(ch))
    starttier = 3;

    if (type == GUEST_HENCHMAN)
    ch->pcdata->next_henchman = 0;
    if (type == GUEST_ENEMY)
    ch->pcdata->next_enemy = 0;
    if (type == GUEST_MONSTER)
    ch->pcdata->next_monster = 0;

    stop_fighting(ch, TRUE);
    REMOVE_FLAG(ch->act, PLR_REROLL);
    if (type != GUEST_PLOT && type != GUEST_CARDINAL && !IS_IMMORTAL(ch) && type != GUEST_NIGHTMARE && type != GUEST_MONSTER)
    SET_FLAG(ch->act, PLR_FREEZE);
    save_char_obj(ch, FALSE, FALSE);
    sprintf(tempname, "%s", ch->name);

    sprintf(strsave, "%s", capitalize(arg));
    ch->faction = 0;
    free_string(ch->name);
    ch->name = str_dup(strsave);

    wiznet("$N makes a guest.", ch, NULL, 0, 0, 0);

    char_from_room(ch);
    char_to_room(ch, get_room_index(ROOM_INDEX_GENESIS));

    arg[0] = UPPER(arg[0]);

    int p = 0;
    for (ObjList::iterator it = object_list.begin();
    it != object_list.end() && p < 500000; p++) {
      obj = *it;
      ++it;

      if (obj == NULL)
      continue;

      if (obj->carried_by == ch) {
        obj_from_char(obj);
        extract_obj(obj);
      }
    }
    ACCOUNT_TYPE *account = ch->pcdata->account;
    if (IS_FLAG(ch->act, PLR_GM))
    REMOVE_FLAG(ch->act, PLR_GM);
    if (IS_FLAG(ch->act, PLR_NOSAVE))
    REMOVE_FLAG(ch->act, PLR_NOSAVE);
    if (IS_FLAG(ch->act, PLR_STASIS))
    REMOVE_FLAG(ch->act, PLR_STASIS);
    if (IS_FLAG(ch->act, PLR_DEAD))
    REMOVE_FLAG(ch->act, PLR_DEAD);

    if (type == GUEST_NIGHTMARE) {
      if (IS_FLAG(ch->pcdata->account->flags, ACCOUNT_NIGHTMARE))
      REMOVE_FLAG(ch->pcdata->account->flags, ACCOUNT_NIGHTMARE);
    }

    do_newbieoutfit(ch, ch->name);
    ch->level = 1;
    ch->trust = 1;
    ch->wounds = 0;
    ch->faction = 0;
    ch->fcore = 0;
    ch->fsect = 0;
    ch->fcult = 0;
    ch->factiontwo = 0;
    ch->modifier = 0;
    ch->spentexp = 0;
    ch->spentrpexp = 0;
    for (int i = 0; i <= DIS_USED; i++) {
      ch->disciplines[i] = 0;
    }
    for (int i = 0; i <= SKILL_USED; i++) {
      ch->skills[i] = 0;
    }
    ch->spentnewexp = 0;
    ch->spentnewrpexp = 0;
    for (int x = 0; x < 10; x++)
    ch->pcdata->previous_focus_vnum[x] = 0;

    SET_FLAG(ch->act, PLR_GUEST);
    set_pcdata_default(ch->pcdata);
    VALIDATE(ch->pcdata);
    ch->id = get_pc_id();
    ch->played = 0;
    free_string(ch->short_descr);
    ch->short_descr = str_dup(arg);
    free_string(ch->long_descr);
    ch->long_descr = str_dup(arg);
    ch->pcdata->account = account;
    ch->exp = 0;
    ch->rpexp = 0;

    ch->spentexp = 0;
    ch->spentrpexp = 0;
    ch->pcdata->dtrains = 0;
    ch->pcdata->strains = 0;

    if (IS_FLAG(ch->act, PLR_FREEZE))
    REMOVE_FLAG(ch->act, PLR_FREEZE);

    ch->pcdata->guest_type = type;
    ch->pcdata->guest_tier = tier;
    ch->newexp = tier * 200000;
    ch->newrpexp = tier * 200000;

    if (type == GUEST_MONSTER) {
      ch->newexp = starttier * 500000;
      ch->newrpexp = starttier * 500000;
    }
    if (type != GUEST_PLOT && type != GUEST_MONSTER)
    ch->pcdata->scheme_influence = 25000 * tier;

    free_string(ch->pcdata->guest_of);
    ch->pcdata->guest_of = str_dup(tempname);

    clear_flags(ch);

    ch->desc->connected = CON_PLAYING;
    do_function(ch, &do_save, "");
    page_to_char(help_story, ch);
  }

  _DOFUN(do_transfer) {
    ROOM_INDEX_DATA *location;
    char arg1[MAX_INPUT_LENGTH];
    char arg2[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;

    argument = one_argument(argument, arg1);
    argument = one_argument(argument, arg2);

    // Limiting viability of temporary characters for grinding - Discordance
    if (ch->played / 3600 < 45) {
      printf_to_char(ch, "You require 50 hours before being able to use the transfer command.`x\n\r");
      return;
    }

    if (ch->pcdata->translocked > current_time) {
      send_to_char("You can't manage to do that.\n\r", ch);
      return;
    }

    if (arg1[0] == '\0') {
      send_to_char("Transfer whom (and where)?\n\r", ch);
      return;
    }

    if (!str_cmp(arg1, "all")) {
      for (DescList::iterator it = descriptor_list.begin();
      it != descriptor_list.end(); ++it) {
        DESCRIPTOR_DATA *d = *it;

        victim = d->character;
        if (d->connected == CON_PLAYING && d->character != ch && d->character->in_room != NULL && can_see(ch, d->character) && (ch->level >= victim->level) && (d->character->in_room->vnum != ROOM_INDEX_GENESIS)) {
          char buf[MAX_STRING_LENGTH];
          sprintf(buf, "%s %s", d->character->name, arg2);
          do_function(ch, &do_transfer, buf);
        }
      }
      return;
    }
    location = ch->in_room;

    if ((victim = get_char_world(ch, arg1)) == NULL) {
      send_to_char("They aren't here.\n\r", ch);
      return;
    }

    if (victim->in_room == NULL) {
      send_to_char("They are in limbo.\n\r", ch);
      return;
    }

    if (victim->level > ch->level) {
      send_to_char("Now, Now, just use immtalk.\n\r", ch);
      return;
    }

    act("$n disappears in a mushroom cloud.", victim, NULL, NULL, TO_ROOM);
    char_from_room(victim);
    char_to_room(victim, location);

    act("$n arrives from a puff of smoke.", victim, NULL, NULL, TO_ROOM);

    if (ch != victim)
    act("$n has transferred you.", ch, NULL, victim, TO_VICT);

    do_function(victim, &do_look, "auto");
    send_to_char("Ok.\n\r", ch);
  }

  _DOFUN(do_messages) {
    char arg1[MSL];
    struct stat sb;
    char buf[MSL];
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    CHAR_DATA *victim;
    //    int number = 0;
    //    int count = 0;

    if (ch->pcdata->ci_editing == 20) {
      ANNIVERSARY_TYPE *ann;
      for (vector<ANNIVERSARY_TYPE *>::iterator it = AnniversaryVect.begin();
      it != AnniversaryVect.end(); ++it) {
        if ((*it)->id == ch->pcdata->ci_discipline) {
          ann = *it;
          break;
        }
      }
      if(ann != NULL)
      {
        ch->pcdata->ci_absorb = 1;
        string_append(ch, &ann->messages);
        send_to_char("Write messages that will occur on the anniversary of this event, one per line.\n\r", ch);
      }
      return;
    }


    if (ch->pcdata->ci_editing == 19) {
      ch->pcdata->ci_absorb = 1;
      string_append(ch, &ch->pcdata->ci_message);
      send_to_char("Write the differnet messages that can occur during the attempt to banish the spirit, one message per line.\n\r", ch);
      return;
    }

    smash_vector(argument);

    if (!IS_NPC(ch) && (ch->pcdata->ci_editing == 7 || ch->pcdata->ci_editing == 8)) {
      string_append(ch, &ch->pcdata->ci_desc);
      return;
    }
    /*    if(is_dreaming(ch))
    number = number_argument( argument, arg1 );
    else
    */
    argument = one_argument_nouncap(argument, arg1);

    if (!str_cmp(arg1, "view")) {
      printf_to_char(ch, "\n\r`WYou have the following messages:`x\n%s\n\r", ch->pcdata->messages);
      return;
    }
    else if (!str_cmp(arg1, "clear")) {
      free_string(ch->pcdata->messages);
      ch->pcdata->messages = str_dup("");
      send_to_char("Messages cleared.\n\r", ch);
      return;
    }
    else {
      bool dream_message = FALSE;
      if (in_fantasy(ch) != NULL) {
        FANTASY_TYPE *fant = in_fantasy(ch);
        for (int x = 0; x < 200; x++) {
          if (safe_strlen(fant->participant_names[x]) < 2)
          continue;
          if (!is_name(arg1, fant->participant_names[x]) && str_cmp(arg1, fant->participant_names[x]))
          continue;

          dream_message = TRUE;
          sprintf(arg1, "%s", fant->participants[x]);
        }
      }
      if (is_helpless(ch) && !dream_message) {
        send_to_char("You can't do that.\n\r", ch);
        return;
      }

      if (IS_FLAG(ch->comm, COMM_NOMESSAGE)) {
        send_to_char("Due to abuse, you can no longer use messages.\n\r", ch);
        return;
      }

      bool mod_flagged = FALSE;
      if (ch->played / 3600 < 50)
      mod_flagged = isTextFlagged(argument);

      d.original = NULL;
      if ((victim = get_char_world(ch, arg1)) != NULL && !IS_NPC(victim)) // Victim is online.
      online = TRUE;
      else {
        if ((victim = get_char_world_pc(arg1)) != NULL) // Victim is online.
        online = TRUE;
        else {
          log_string("DESCRIPTOR: Player Message");

          if (!load_char_obj(&d, arg1)) {
            printf_to_char(ch, "\n\r%s is not a character!\n\r", capitalize(arg1));
            return;
          }

          sprintf(buf, "%s%s", PLAYER_DIR, capitalize(arg1));
          stat(buf, &sb);
          victim = d.character;
        }
      }
      if (IS_NPC(victim)) {
        if (!online)
        free_char(victim);

        send_to_char("\n\rYou can't target mobiles!\n\r", ch);
        return;
      }

      // ghostie check for messages -Discordance
      if (is_dead(ch)) {
        send_to_char("Communing with the dead requires a more personal approach.\n\r", ch);
        return;
      }

      smash_tilde(argument);
      if (silenced(ch) && ch->in_room != victim->in_room && !dream_message)
      return;
      if (is_helpless(ch) && ch->in_room != victim->in_room && !dream_message)
      return;
      if (is_town_blackout())
      return;

      if (!spammer(ch) || same_player(ch, victim)) {
        if (IS_IMMORTAL(ch) || ((ch->in_room->vnum > 300 || ch->in_room->vnum == 60) && ch->played / 3600 > 10 && mod_flagged == FALSE)) {
          if (!IS_IMMORTAL(ch)) {
            if (dream_message)
            sprintf(buf, "%s\n(%s):%s", victim->pcdata->messages, dream_name(ch), argument);
            else
            sprintf(buf, "%s\n(%s):%s", victim->pcdata->messages, ch->name, argument);
          }
          else
          sprintf(buf, "%s\n%s", victim->pcdata->messages, argument);

          free_string(victim->pcdata->messages);
          victim->pcdata->messages = str_dup(buf);
          save_char_obj(victim, FALSE, FALSE);

          if (online && !institute_room(ch->in_room))
          printf_to_char(victim, "You get a new message: %s\n\r", argument);
        }
      }

      if (!online)
      free_char(victim);

      send_to_char("Message sent. (Remember when sending a message to include details about the type and source of the message)\n\r", ch);
    }
  }

  void feedback_to_char(CHAR_DATA *ch, char *message, int type) {
    if (IS_FLAG(ch->act, PLR_GM)) {
      CHAR_DATA *victim;
      struct stat sb;
      char buf[MSL];
      DESCRIPTOR_DATA d;
      bool online = FALSE;

      d.original = NULL;
      if ((victim = get_char_world_pc(ch->pcdata->storyrunner)) !=
          NULL) // Victim is online.
      online = TRUE;
      else {
        log_string("DESCRIPTOR: Feedback to char");

        if (!load_char_obj(&d, ch->pcdata->storyrunner)) {
          return;
        }

        sprintf(buf, "%s%s", PLAYER_DIR, capitalize(ch->pcdata->storyrunner));
        stat(buf, &sb);
        victim = d.character;
      }
      if (IS_NPC(victim)) {
        if (!online)
        free_char(victim);

        return;
      }
      feedback_to_char(victim, message, type);
      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      return;
    }

    int i;
    if (type == 1) {
      for (i = 0; i < 10; i++) {
        if (ch->pcdata->feedbacktim[i] != 0 && ch->pcdata->feedbackbon[i] > 0) {
          ch->pcdata->feedbackbon[i]++;
        }
      }
      for (i = 0; i < 10; i++) {
        if (ch->pcdata->feedbacktim[i] == 0) {
          ch->pcdata->feedbacktim[i] = number_range(1000, 25000);
          free_string(ch->pcdata->feedbackinc[i]);
          ch->pcdata->feedbackinc[i] = str_dup(message);
          ch->pcdata->feedbackbon[i] = 1;
          return;
        }
      }
    }
    else if (type == -1) {
      for (i = 0; i < 10; i++) {
        if (ch->pcdata->feedbacktim[i] != 0 && ch->pcdata->feedbackbon[i] < 0) {
          ch->pcdata->feedbackbon[i]--;
        }
      }
      for (i = 0; i < 10; i++) {
        if (ch->pcdata->feedbacktim[i] == 0) {
          ch->pcdata->feedbacktim[i] = number_range(1000, 25000);
          free_string(ch->pcdata->feedbackinc[i]);
          ch->pcdata->feedbackinc[i] = str_dup(message);
          ch->pcdata->feedbackbon[i] = -1;
          return;
        }
      }
    }
    else {
      for (i = 0; i < 10; i++) {
        if (ch->pcdata->feedbacktim[i] == 0) {
          ch->pcdata->feedbacktim[i] = number_range(1000, 25000);
          free_string(ch->pcdata->feedbackinc[i]);
          ch->pcdata->feedbackinc[i] = str_dup(message);
          ch->pcdata->feedbackbon[i] = 0;
          return;
        }
      }
    }
  }

  void change_identity(CHAR_DATA *ch, char *newname) {
    char iden[MSL];
    sprintf(iden, "%s", capitalize(newname));
    char strsave[MSL];
    sprintf(strsave, "%s%s", PLAYER_DIR, capitalize(ch->name));
    if (ch->faction != 0)
    remove_from_clanroster(ch->name, ch->faction);
    if (ch->factiontwo != 0)
    remove_from_clanroster(ch->name, ch->factiontwo);
    ch->faction = 0;
    ch->esteem_faction = 0;
    ch->factiontwo = 0;
    ch->esteem_cult = 0;
    ch->esteem_sect = 0;
    ch->pcdata->base_standing = 150;
    free_string(ch->pcdata->mentor);
    ch->pcdata->mentor = str_dup("");
    ch->pcdata->mentor_of = 0;
    if (ch->vassal != 0) {
      remove_from_vassalroster(ch->name, ch->vassal);
      ch->vassal = 0;
    }
    for (int i = 0; i < 10; i++) {
      if (safe_strlen(ch->pcdata->relationship[i]) > 2) {
        if (ch->pcdata->relationship_type[i] != REL_SIRE && ch->pcdata->relationship_type[i] != REL_SIRELING) {
          free_string(ch->pcdata->relationship[i]);
          ch->pcdata->relationship[i] = str_dup("");
          ch->pcdata->relationship_type[i] = 0;
        }
      }
    }

    if (ch->pcdata->account != NULL) {
      for (int i = 0; i < 25; i++) {
        if (!str_cmp(ch->pcdata->account->characters[i], ch->name)) {
          free_string(ch->pcdata->account->characters[i]);
          ch->pcdata->account->characters[i] = str_dup(iden);
        }
      }
    }
    free_string(ch->name);
    ch->name = str_dup(iden);
    ch->played = (3600 * 5);
    free_string(ch->short_descr);
    ch->short_descr = str_dup(iden);
    free_string(ch->long_descr);
    ch->long_descr = str_dup(iden);
    ch->pcdata->lastidentity = current_time;
    unlink(strsave);
    return;
  }

  bool illegal_creation_name(char * argument)
  {
    if(!str_cmp(argument, "headquarters"))
    return TRUE;

    if(!str_cmp(argument, "ritualist"))
    return TRUE;

    if(!str_cmp(argument, "ouroboros"))
    return TRUE;

    if(!str_cmp(argument, "tyr"))
    return TRUE;

    if(!str_cmp(argument, "daed"))
    return TRUE;

    if(!str_cmp(argument, "discordance"))
    return TRUE;

    return FALSE;
  }

  _DOFUN(do_change) {
    bool found = FALSE;
    DESCRIPTOR_DATA d;
    char arg1[MSL], arg2[MSL], arg3[MSL];
    argument = one_argument_nouncap(argument, arg1);

    if (IS_FLAG(ch->act, PLR_TYRANT)) {
      send_to_char("Tyrants cannot change.\n\r", ch);
      return;
    }

    if (ch->in_room->vnum != ROOM_INDEX_GENESIS && higher_power(ch))
    return;

    if (is_dead(ch) && str_cmp(arg1, "ghost")) {
      send_to_char("You are as the day you died.", ch);
      return;
    }
    /*
    if (is_roster_char(ch) && ch->played / 3600 < 75) {
    send_to_char("You cannot alter a character recently taken from the roster.\n\r", ch);
    return;
    }
    */
    if (is_gm(ch)) {
      return;
    }

    if (ch->race == RACE_WIGHT) {
      send_to_char("Wights cannot change.\n\r", ch);
      return;
    }

    if (!str_cmp(arg1, "name") && ch->in_room->vnum == ROOM_INDEX_GENESIS) {
      if (safe_strlen(argument) < 1) {
        send_to_char("Change to what?\n\r", ch);
        return;
      }

      log_string("DESCRIPTOR: Creation Name");

      DESCRIPTOR_DATA d;
      d.original = NULL;
      if (load_char_obj(&d, argument)) {
        send_to_char("A character with that name already exists.\n\r", ch);
        return;
      }

      argument[0] = UPPER(argument[0]);
      if (!check_parse_name(argument)) {
        send_to_char("Illegal name.\n\r", ch);
        return;
      }

      for (int a = 0; a < MAX_INAME; a++) {
        if (iname_table[a][0] == '\0') {
          break;
        }
        if (!strcmp(iname_table[a], argument)) {
          send_to_char("Illegal name.\n\r", ch);
          return;
        }
      }

      if (!string_alphanum(argument)) {
        send_to_char("Illegal name.\n\r", ch);
        return;
      }
      if(illegal_creation_name(argument)) {
        send_to_char("Illegal name.\n\r", ch);
        return;
      }


      change_identity(ch, argument);
      ch->pcdata->lastidentity = 0;
      ch->played = 0;
      do_function(ch, &do_save, "");
      printf_to_char(ch, "You are now known as %s.\n\r", ch->name);
      remove_from_roster(ch->name);
      return;
    }
    if (!str_cmp(arg1, "lastname")) {
      if (ch->played / 3600 > 5 && ch->in_room->vnum != ROOM_INDEX_GENESIS) {
        if (ch->money < 20000) {
          send_to_char("Name changes cost $200.\n\r", ch);
          return;
        }
        if(ff_surname(argument))
        {
          send_to_char("That name is not allowed.\n\r", ch);
          return;
        }
        ch->money -= 20000;
      }
      free_string(ch->pcdata->last_name);
      ch->pcdata->last_name = str_dup(argument);
      printf_to_char(ch, "You are now known as %s %s.\n\r", ch->name, ch->pcdata->last_name);
      return;
    }
    if (!str_cmp(arg1, "identity")) {
      if (safe_strlen(argument) < 3) {
        send_to_char("Syntax: Change identity (name)\n\r", ch);
        return;
      }
      log_string("DESCRIPTOR:Identity Change");

      d.original = NULL;
      if (load_char_obj(&d, argument)) {
        send_to_char("A character with that name already exists.\n\r", ch);
        return;
      }
      if (ch->pcdata->lastidentity != 0 && (current_time - ch->pcdata->lastidentity) / 3600 / 24 < 45) {
        send_to_char("You did that too recently\n\r", ch);
        return;
      }
      if (ch->money < 250000) {
        send_to_char("Identity changes cost $2500.\n\r", ch);
        return;
      }

      ch->money -= 250000;
      change_identity(ch, capitalize(argument));
      send_to_char("Done.\n\r", ch);
      return;
    }
    // Added do_procedure to sex.c to cover changes after the 5 hour mark - Discordance
    if (!str_cmp(arg1, "eyecolor")) {
      if (ch->played / 3600 <= 5 || ch->pcdata->eyes_genetic == 0 || ch->in_room->vnum == ROOM_INDEX_GENESIS || str_cmp(ch->in_room->subarea, "creation")) {
        set_natural_eyes(ch, argument);
        return;
      }
      else {
        send_to_char("Your eye color has already been set.\n\r", ch);
        return;
      }
    }
    if (!str_cmp(arg1, "haircolor")) {
      if (ch->played / 3600 <= 5 || ch->pcdata->hair_genetic == 0 || ch->in_room->vnum == ROOM_INDEX_GENESIS || str_cmp(ch->in_room->subarea, "creation")) {
        set_natural_hair(ch, argument);
        return;
      }
      else {
        send_to_char("Your hair color has already been set.\n\r", ch);
        return;
      }
    }
    if (!str_cmp(arg1, "divinefocus") && is_demigod(ch)) {
      if (ch->pcdata->divine_focus > 0 && ch->pcdata->divine_focus < 1000 && ch->played / 3600 > 5) {
        send_to_char("You've already set that.\n\r", ch);
        return;
      }
      if (!str_cmp(argument, "messenger")) {
        ch->pcdata->divine_focus = CAFF_AMESSENGER;
        send_to_char("You make the aspect of the messenger your divine focus.\n\r", ch);
      }
      else if (!str_cmp(argument, "sun")) {
        ch->pcdata->divine_focus = CAFF_ASUN;
        send_to_char("You make the aspect of the sun your divine focus.\n\r", ch);
      }
      else if (!str_cmp(argument, "warrior")) {
        ch->pcdata->divine_focus = CAFF_AWARRIOR;
        send_to_char("You make the aspect of the warrior your divine focus.\n\r", ch);
      }
      else if (!str_cmp(argument, "smith")) {
        ch->pcdata->divine_focus = CAFF_ASMITH;
        send_to_char("You make the aspect of the smith your divine focus.\n\r", ch);
      }
      else if (!str_cmp(argument, "healer")) {
        ch->pcdata->divine_focus = CAFF_AHEALER;
        send_to_char("You make the aspect of the healer your divine focus.\n\r", ch);
      }
      else if (!str_cmp(argument, "underworld")) {
        ch->pcdata->divine_focus = CAFF_AUNDERWORLD;
        send_to_char("You make the aspect of the underworld your divine focus.\n\r", ch);
      }
      else if (!str_cmp(argument, "moon")) {
        ch->pcdata->divine_focus = CAFF_AMOON;
        send_to_char("You make the aspect of the moon your divine focus.\n\r", ch);
      }
      else if (!str_cmp(argument, "thunder")) {
        ch->pcdata->divine_focus = CAFF_ATHUNDER;
        send_to_char("You make the aspect of thunder your divine focus.\n\r", ch);
      }
      else if (!str_cmp(argument, "wind")) {
        ch->pcdata->divine_focus = CAFF_AWIND;
        send_to_char("You make the aspect of the wind your divine focus.\n\r", ch);
      }
      else if (!str_cmp(argument, "hunter")) {
        ch->pcdata->divine_focus = CAFF_AHUNTER;
        send_to_char("You make the aspect of the hunter your divine focus.\n\r", ch);
      }
      else {
        send_to_char("Options are: Messenger, Sun, Warrior, Smith, Healer, Underworld, Moon, Thunder, Wind, Hunter.\n\r", ch);
      }

      return;
    }
    if (!str_cmp(arg1, "hairdye")) {
      free_string(ch->pcdata->hair_dyed);
      ch->pcdata->hair_dyed = str_dup(argument);
      printf_to_char(ch, "You now have %s hair.\n\r", argument);
      act("$n dyes $s hair.", ch, NULL, NULL, TO_ROOM);
      return;
    }
    if (!str_cmp(arg1, "skin")) {
      free_string(ch->pcdata->skin);
      ch->pcdata->skin = str_dup(argument);
      printf_to_char(ch, "You now have %s.\n\r", ch->pcdata->skin);
      return;
    }
    if (!str_cmp(arg1, "ageless")) {
      do_function(ch, &do_ageless, argument);
      return;
    }
    if (!str_cmp(arg1, "length")) {
      do_function(ch, &do_scroll, argument);
      return;
    }
    if (!str_cmp(arg1, "width")) {
      do_function(ch, &do_width, argument);
      return;
    }
    if (!str_cmp(arg1, "intro")) {
      do_function(ch, &do_intro, argument);
      return;
    }
    if (!str_cmp(arg1, "archetype") && ch->in_room->vnum == ROOM_INDEX_GENESIS) {
      if (ch->skills[SKILL_MENTALDISCIPLINE] > 0) {
        send_to_char("You can't do that while you have mental discipline.\n\r", ch);
        return;
      }
      if (safe_strlen(argument) < 3) {
        send_to_char("That's not a valid archetype, possible options:\n\r", ch);
        for (int i = 0; i < MAX_RACES; i++) {
          if (race_table[i].pc_race == TRUE && race_table[i].creatable == TRUE)
          printf_to_char(ch, "%s, ", from_color(race_table[i].who_name));
        }
        send_to_char("\n\r", ch);
        return;
      }
      int race = race_lookup(argument);

      if (guestmonster(ch)) {
        if (!str_cmp(argument, "land monster")) {
          race = RACE_LANDMONSTER;
        }
        else if (!str_cmp(argument, "sea monster")) {
          race = RACE_SEAMONSTER;
        }
        else {
          send_to_char("Valid types: Land monster, sea monster.\n\r", ch);
          return;
        }
      }
      else {
        found = FALSE;
        for (int i = 0; i < MAX_RACES; i++) {
          if (!str_cmp(argument, from_color(race_table[i].who_name))) {
            race = i;
            if (race_table[race].pc_race == TRUE && race_table[race].creatable == TRUE) {
              found = TRUE;
            }
          }
        }
        if (found == FALSE) {
          send_to_char("That's not a valid archetype, possible options:\n\r", ch);
          for (int i = 0; i < MAX_RACES; i++) {
            if (race_table[i].pc_race == TRUE && race_table[i].creatable == TRUE) {
              printf_to_char(ch, "%s, ", from_color(race_table[i].who_name));
            }
          }
          send_to_char("\n\r", ch);
          return;
        }
      }
      ch->race = race;
      ch->modifier = 0;
      if (get_skill(ch, SKILL_AGELESS) < 1) {
        ch->pcdata->apparant_age = 0;
      }
      send_to_char("Archetype set.\n\r", ch);
      return;
    }

    if (!str_cmp(arg1, "modifier") && ch->in_room->vnum == ROOM_INDEX_GENESIS) {
      int mod = 0;
      for (int i = 0; i < MAX_MODIFIER; i++) {
        if (!str_cmp(argument, modifier_table[i].name)) {
          mod = i;

          if (elligible_modifier(ch, mod)) {
            ch->modifier = mod;
            printf_to_char(ch, "You are now %s.\n\r", modifier_table[mod].name);
            if (ch->modifier == MODIFIER_FLESHFORMED)
            ch->pcdata->fleshformed = current_time;

            return;
          }
          else {
            send_to_char("That archetype can't take that modifier.\n\r", ch);
            return;
          }
        }
      }
      send_to_char("No such modifier.\n\r", ch);
      return;
    }
    if (!str_cmp(arg1, "archetype") && ch->in_room->vnum != ROOM_INDEX_GENESIS) {
      if (ch->skills[SKILL_MENTALDISCIPLINE] > 0) {
        send_to_char("You can't do that while you have mental discipline.\n\r", ch);
        return;
      }
      if (ch->race == RACE_FACULTY) {
        send_to_char("The Institute will not release its hold.\n\r", ch);
        return;
      }

      char buf[MSL];
      char arg2[MSL];
      char arg3[MSL];

      if (IS_FLAG(ch->act, PLR_GUEST)) {
        return;
      }
      if (safe_strlen(argument) < 2) {
        send_to_char("Change into what?\n\r", ch);
        return;
      }

      argument = one_argument_nouncap(argument, arg1);
      argument = one_argument_nouncap(argument, arg2);
      argument = one_argument_nouncap(argument, arg3);
      char name[MSL];
      // This parses three arguments to compare with race_table.
      // It's repeated with two and then one argument.  Leaving it be. - Discordance
      sprintf(buf, "%s %s %s", arg1, arg2, arg3);
      int race = race_lookup(buf);
      for (int i = 0; i < MAX_RACES; i++) {
        if (!str_cmp(buf, from_color(race_table[i].who_name))) {
          race = i;
        }
        if (!str_cmp(buf, race_table[i].who_name)) {
          race = i;
        }
      }

      if (race < 1 || race > MAX_RACES) {
        sprintf(buf, "%s %s", arg1, arg2);
        race = race_lookup(buf);

        for (int i = 0; i < MAX_RACES; i++) {
          if (!str_cmp(from_color(buf), from_color(race_table[i].who_name))) {
            race = i;
          }
          if (!str_cmp(buf, race_table[i].who_name)) {
            race = i;
          }
        }
      }

      if (race < 1 || race > MAX_RACES) {
        sprintf(buf, "%s", arg1);
        race = race_lookup(buf);
        for (int i = 0; i < MAX_RACES; i++) {
          sprintf(name, "%s", race_table[i].who_name);
          if (!str_cmp(from_color(buf), from_color(name))) {
            race = i;
          }
          if (!str_cmp(arg1, name)) {
            race = i;
          }
        }
      }

      // This should be able to be used to determine if a race can be changed into
      // without the race ranges that need to be incremented - Discordance
      if (race_table[race].pc_race == FALSE) {
        send_to_char("That's not a valid archetype.\n\r", ch);
        return;
      }
      if (ch->race != race) {
        if (ch->race != RACE_FANTASY || race_table[race].vnum != RACE_DREAMCHILD) {
          if (race_table[race].change_to == FALSE || ch->race == RACE_FANTASY) {
            send_to_char("You cannot change to that archetype.\n\r", ch);
            return;
          }
        }
        if (get_rosterchar(ch->name) != NULL && !str_cmp(get_rosterchar(ch->name)->owner, "Daed")) {
          send_to_char("This character's archetype cannot be changed.\n\r", ch);
          return;
        }
      }

      bool werewolf = FALSE;
      bool vampire = FALSE;
      werewolf = is_werewolf(ch);
      vampire = is_vampire(ch);

      int orig = ch->race;
      ch->race = race;
      int mod = -1;
      sprintf(buf, "%s %s %s", arg2, arg3, argument);
      for (int i = 0; i < MAX_MODIFIER; i++) {
        sprintf(name, "%s", modifier_table[i].name);
        if (!str_cmp(nospaces(buf), nospaces(name))) {
          mod = i;
        }
      }
      if (mod == -1) {
        sprintf(buf, "%s %s", arg3, argument);
        for (int i = 0; i < MAX_MODIFIER; i++) {
          sprintf(name, "%s", modifier_table[i].name);
          if (!str_cmp(nospaces(buf), nospaces(name))) {
            mod = i;
          }
        }
      }
      if (mod == -1) {
        sprintf(buf, "%s", argument);
        for (int i = 0; i < MAX_MODIFIER; i++) {
          sprintf(name, "%s", modifier_table[i].name);
          if (!str_cmp(nospaces(buf), nospaces(name))) {
            mod = i;
          }
        }
      }
      if (mod == -1)
      mod = 0;

      if (!elligible_modifier(ch, mod)) {
        printf_to_char(ch, "Archetype: %d\n\r", race);
        printf_to_char(ch, "Modifier: %d\n\r", mod);
        send_to_char("That archetype can't take that modifier.\n\r", ch);
        ch->race = orig;
        return;
      }

      if (werewolf == TRUE && !is_werewolf(ch)) {
        send_to_char("The cure for lycanthropy is not so simple.\n\r", ch);
        ch->race = orig;
        return;
      }
      if (vampire == TRUE && !is_vampire(ch)) {
        send_to_char("The cure for undeath is not so simple.\n\r", ch);
        ch->race = orig;
        return;
      }

      ch->race = orig;
      if (mod == -1) {
        send_to_char("Syntax: Change archetype (new archetype) (modifier)\n\r", ch);
        return;
      }

      if (ch->race == race && ch->modifier == mod) {
        send_to_char("You already are that.\n\r", ch);
        return;
      }
      tm *ptm;
      time_t east_time;
      east_time = current_time;
      ptm = gmtime(&east_time);
      int year = ptm->tm_year + 1900;
      int origmod = ch->modifier;
      int origtier = get_tier(ch);
      int origcost = charcost(ch);
      int origsyear = ch->pcdata->sire_year;
      int origsday = ch->pcdata->sire_day;
      int origsmonth = ch->pcdata->sire_month;
      ch->race = race;
      ch->modifier = mod;
      ch->pcdata->sire_year = year;
      ch->pcdata->sire_month = ptm->tm_mon + 1;
      ch->pcdata->sire_day = ptm->tm_mday;
      int newtier = get_tier(ch);
      int newcost = charcost(ch);
      bool badage = FALSE;
      int newfocus = focus_point_per_tier(ch);
      if (get_true_age(ch) < min_age(ch) || get_true_age(ch) > max_age(ch) || get_age(ch) < min_aage(ch) || get_age(ch) > max_aage(ch)) {
        if (ch->race != orig) {
          badage = TRUE;
        }
      }
      int refund = 0;
      if (newtier < origtier) {
        refund = origcost - newcost;
      }
      sprintf(buf, "REFUND: %s: Newtier %d, Origtier %d, newcost %d, origcost %d, refund %d.", ch->name, newtier, origtier, newcost, origcost, refund);
      log_string(buf);
      ch->race = orig;
      ch->modifier = origmod;
      ch->pcdata->sire_year = origsyear;
      ch->pcdata->sire_month = origsmonth;
      ch->pcdata->sire_day = origsday;
      if (newtier >= 3 && safe_strlen(ch->pcdata->account->lasttierchar) > 1 && str_cmp(ch->name, ch->pcdata->account->lasttierchar) && ch->pcdata->account->hightiercooldown > current_time) {
        send_to_char("You had a high tier character too recently.\n\r", ch);
        return;
      }
      if (badage == TRUE) {
        send_to_char("You aren't the right age for that.\n\r", ch);
        return;
      }
      if (ch->modifier == mod && ch->race == race) {
        send_to_char("You wouldn't be changing anything.\n\r", ch);
        return;
      }
      int cost = newcost - origcost;
      cost = UMAX(1000, cost);
      if (ch->race != race) {
        if (race == RACE_LOCAL) {
          cost = UMAX(cost, 2000);
        }
        else if (race == RACE_VISITOR) {
          cost = UMAX(cost, 2000);
        }
        else if (race == RACE_STUDENT) {
          cost = UMAX(cost, 2000);
        }
        else if (race == RACE_BROWN) {
          cost = UMAX(cost, 2000);
        }
        else if (race == RACE_IMPORTANT) {
          cost = UMAX(cost, 2000);
        }
        else if (race == RACE_DABBLER) {
          cost = UMAX(cost, 2000);
        }
        else if (race == RACE_DEPUTY) {
          cost = UMAX(cost, 2000);
        }
        else if (race == RACE_NEWVAMPIRE) {
          if (is_vampire(ch) || is_werewolf(ch)) {
            send_to_char("You are already a monster.\n\r", ch);
            return;
          }
          cost = UMAX(cost, 2000);
        }
        else if (race == RACE_NEWWEREWOLF) {
          if (is_vampire(ch) || is_werewolf(ch)) {
            send_to_char("You are already a monster.\n\r", ch);
            return;
          }
          cost = UMAX(cost, 2000);
        }
        else if (race == RACE_NEWFAEBORN) {
          if (is_demonborn(ch) || is_angelborn(ch) || is_demigod(ch)) {
            send_to_char("Only humans with no other ancenstry can activate.\n\r", ch);
            return;
          }
          cost = UMAX(cost, 2000);
        }
        else if (race == RACE_NEWANGELBORN) {
          if (is_demonborn(ch) || is_faeborn(ch) || is_demigod(ch)) {
            send_to_char("Only humans with no other ancenstry can activate.\n\r", ch);
            return;
          }
          cost = UMAX(cost, 2000);
        }
        else if (race == RACE_NEWDEMONBORN) {
          if (is_faeborn(ch) || is_faeborn(ch) || is_demigod(ch)) {
            send_to_char("Only humans with no other ancenstry can activate.\n\r", ch);
            return;
          }
          cost = UMAX(cost, 2000);
        }
        else if (race == RACE_NEWDEMIGOD) {
          if (is_demonborn(ch) || is_faeborn(ch) || is_angelborn(ch)) {
            send_to_char("Only humans with no other ancenstry can activate.\n\r", ch);
            return;
          }
          cost = UMAX(cost, 2000);
        }
        else if (race == RACE_GIFTED) {
          if (is_super(ch)) {
            send_to_char("Only humans can become gifted.\n\r", ch);
            return;
          }
          cost = UMAX(cost, 2000);
        }
        else {
          cost = UMAX(cost, 2000);
        }
      }
      if (cost <= 2000 && ch->played / 3600 < 50) {
        cost = 0;
      }
      if (cost > available_karma(ch) + available_pkarma(ch) && refund == 0) {
        printf_to_char(ch, "That change would cost %d karma, you have %d.\n\r", cost, available_karma(ch) + available_pkarma(ch));
        return;
      }
      if (!IS_FLAG(ch->comm, COMM_STORY) && mod == MODIFIER_PACT) {
        send_to_char("You can't take a demonic pact with story off.\n\r", ch);
        return;
      }
      if (refund > 0) {
        if (combat_focus(ch) + arcane_focus(ch) + prof_focus(ch) > newfocus) {
          send_to_char("You must negtrain more of your focuses first.\n\r", ch);
          return;
        }
        char lstr[MSL];
        sprintf(lstr, "REFUND: Refund: %d, spentkarma: %d, karmabank: %d, spentpkarma: %d, accountpakrmaspent: %d", refund, ch->spentkarma, ch->pcdata->account->karmabank, ch->spentpkarma, ch->pcdata->account->pkarmaspent);
        log_string(lstr);
        if (ch->spentkarma > refund) {
          ch->spentkarma -= refund;
          ch->pcdata->account->karmabank += refund;
        }
        else {
          refund -= ch->spentkarma;
          ch->pcdata->account->karmabank += ch->spentkarma;
          ch->spentkarma = 0;
          ch->spentpkarma -= refund;
          ch->pcdata->account->pkarmaspent -= refund;
        }
        sprintf(lstr, "REFUND: Refund: %d, spentkarma: %d, karmabank: %d, spentpkarma: %d, accountpakrmaspent: %d", refund, ch->spentkarma, ch->pcdata->account->karmabank, ch->spentpkarma, ch->pcdata->account->pkarmaspent);
        log_string(lstr);
      }
      else {
        int deduct = UMIN(cost, available_pkarma(ch));
        cost -= deduct;
        ch->pcdata->account->pkarma -= deduct;
        if (deduct > 5000) {
          ch->spentpkarma += deduct;
          ch->pcdata->account->pkarmaspent += deduct;
        }
        if (cost > 0) {
          ch->pcdata->account->karma -= cost;
          ch->spentkarma += cost;
        }
      }
      if (mod == MODIFIER_FLESHFORMED && ch->modifier != MODIFIER_FLESHFORMED) {
        if (ch->pcdata->fleshformed == 0) {
          free_string(ch->pcdata->maim);
          ch->pcdata->maim = str_dup("");
        }
        ch->pcdata->maim = str_dup("");
      }
      if (mod == MODIFIER_PACT && ch->modifier != MODIFIER_PACT) {
        ch->pcdata->emotes[EMOTE_PACTANTAG] = 25;
      }
      if (ch->modifier != MODIFIER_FLESHFORMED && mod == MODIFIER_FLESHFORMED && ch->pcdata->fleshformed == 0) {
        ch->pcdata->fleshformed = current_time;
      }
      if (ch->modifier == MODIFIER_PACT && mod != MODIFIER_PACT && !IS_FLAG(ch->act, PLR_DEMONPACT)) {
        SET_FLAG(ch->act, PLR_DEMONPACT);
      }
      if (mod == MODIFIER_LUNACY && ch->modifier != MODIFIER_LUNACY) {
        ch->pcdata->last_outside_fullmoon = current_time;
      }
      char lstr[MSL];
      sprintf(lstr, "CHANGE: %s cost: %d, oldrace: %d, newrace: %d, mod: %d", ch->name, cost, ch->race, race, mod);
      log_string(lstr);

      int oldrace = ch->race;
      ch->race = race;
      ch->modifier = mod;
      printf_to_char(ch, "You become %s modified by %s.\n\r", race_table[ch->race].who_name, modifier_table[ch->modifier].name);
      if (race == RACE_FACULTY) {
        return;
      }
      if (race == RACE_DREAMCHILD && oldrace == RACE_FANTASY) {
        wake_char(ch);
        if (IS_FLAG(ch->act, PLR_SHROUD))
        REMOVE_FLAG(ch->act, PLR_SHROUD);
        char_from_room(ch);
        char_to_room(ch, get_room_index(50));
      }
      if (race == RACE_NEWVAMPIRE && oldrace != RACE_NEWVAMPIRE) {
        ch->pcdata->sire_year = year;
        ch->pcdata->sire_month = ptm->tm_mon + 1;
        ch->pcdata->sire_day = ptm->tm_mday;
        ch->pcdata->coma = current_time + (3600 * 5);
      }
      return;
    }
    else if (!str_cmp(arg1, "modifier") && ch->in_room->vnum != ROOM_INDEX_GENESIS) {
      char buf[MSL];
      sprintf(buf, "archetype %s %s", from_color(race_table[ch->race].who_name), argument);
      do_function(ch, &do_change, buf);

      return;
    }
    if (!str_cmp(arg1, "breasts") || !str_cmp(arg1, "bust")) {
      if (ch->played / 3600 > 5 && ch->in_room->vnum != ROOM_INDEX_GENESIS && str_cmp(ch->in_room->subarea, "creation")) {
        send_to_char("It's been over five hours since you created.  Please use the procedure command instead.\n\r", ch);
        return;
      }
      if (!str_cmp(argument, "Larger")) {
        if (ch->pcdata->bust > 20) {
          send_to_char("Your breasts can't get any bigger than that.\n\r", ch);
          return;
        }
        ch->pcdata->bust++;
      }
      else if (!str_cmp(argument, "Smaller")) {
        if (ch->pcdata->bust == 1) {
          send_to_char("Your breasts can't get any smaller than that.\n\r", ch);
          return;
        }
        ch->pcdata->bust--;
      }
      else {
        send_to_char("Syntax: change breasts larger/smaller.\n\r", ch);
        return;
      }
      if (ch->pcdata->bust < 0)
      ch->pcdata->bust = 0;
      if (ch->pcdata->bust > 0)
      printf_to_char(ch, "You now have %s sized breasts.\n\r", cup_size[get_bust(ch)]);
      else
      send_to_char("Done.\n\r", ch);
      return;
    }
    if (!str_cmp(arg1, "sex") || !str_cmp(arg1, "gender")) {
      if (ch->played / 3600 < 5 || ch->in_room->vnum == ROOM_INDEX_GENESIS || str_cmp(ch->in_room->subarea, "creation")) {
        if (ch->pcdata->penis > 0) {
          ch->pcdata->penis = 0;
          ch->pcdata->bust += 3;
          ch->sex = SEX_FEMALE;
        }
        else {
          ch->pcdata->penis = 10;
          ch->pcdata->bust = 0;
          ch->sex = SEX_MALE;
        }
        send_to_char("Done.\n\r", ch);
        return;
      }
      else {
        send_to_char("It's been over five hours since you created.  Please use the procedure command instead.`x\n\r", ch);
        return;
      }
    }
    if (!str_cmp(arg1, "feet") && ch->in_room->vnum == ROOM_INDEX_GENESIS && str_cmp(ch->in_room->subarea, "creation")) {
      if (guestmonster(ch) || change_feet(ch, argument)) {
        ch->pcdata->height_feet = atoi(argument);
        printf_to_char(ch, "You are now %d'%d\n\r", ch->pcdata->height_feet, ch->pcdata->height_inches);
      }
      return;
    }
    if (!str_cmp(arg1, "inches") && ch->in_room->vnum == ROOM_INDEX_GENESIS && str_cmp(ch->in_room->subarea, "creation")) {
      ch->pcdata->height_inches = atoi(argument);
      printf_to_char(ch, "You are now %d'%d\n\r", ch->pcdata->height_feet, ch->pcdata->height_inches);
      return;
    }
    if (!str_cmp(arg1, "age") && ch->in_room->vnum == ROOM_INDEX_GENESIS) {
      tm *ptm;
      ptm = gmtime(&current_time);
      int val = atoi(argument);

      if (val < 8) {
        send_to_char("Your character must be at least 8.\n\r", ch);
        return;
      }
      if (val < min_age(ch)) {
        printf_to_char(ch, "Your character must be at least %d.\n\r", min_age(ch));
        return;
      }
      if (val > max_age(ch)) {
        printf_to_char(ch, "Your character must be at most %d.\n\r", max_age(ch));
        return;
      }

      int year = ptm->tm_year + 1900;

      ch->pcdata->birth_year = year - val;
      ch->pcdata->birth_month = number_range(1, 12);
      ch->pcdata->birth_day = number_range(1, 28);

      int age = year - ch->pcdata->birth_year;
      if (ptm->tm_mon < ch->pcdata->birth_month)
      age--;
      if (ptm->tm_mon == ch->pcdata->birth_month && ptm->tm_mday < ch->pcdata->birth_day)
      age--;
      if (age > val)
      ch->pcdata->birth_year++;
      else if (age < val)
      ch->pcdata->birth_year--;

      if (get_true_age(ch) > val)
      ch->pcdata->birth_year++;
      else if (get_true_age(ch) < val)
      ch->pcdata->birth_year--;

      if (get_true_age(ch) > val)
      ch->pcdata->birth_year++;
      else if (get_true_age(ch) < val)
      ch->pcdata->birth_year--;

      printf_to_char(ch, "You are now %d.\n\r", get_true_age(ch));
      if (get_true_age(ch) < 30)
      printf_to_char(
      ch, "You should know some stats and concepts are age-locked. Specifically veterans need to be around 30 and you need to be at least 25 to take the mental discipline ability.\n\r");

      return;
    }
    if (!str_cmp(arg1, "email")) {
      free_string(ch->pcdata->email);
      ch->pcdata->email = str_dup(argument);
      send_to_char("Email set.\n\r", ch);
      return;
    }
    if (!str_cmp(arg1, "birthday") && ch->in_room->vnum == ROOM_INDEX_GENESIS) {
      tm *ptm;
      ptm = gmtime(&current_time);
      char arg2[MSL];
      char arg3[MSL];
      argument = one_argument_nouncap(argument, arg2);
      argument = one_argument_nouncap(argument, arg3);

      int val = atoi(arg2);
      int year = ptm->tm_year + 1900;
      int day = atoi(argument);
      int month = atoi(arg3);

      if (day > 100) {
        if (val > 12 || month > 12) {
          if (val > 12) {
            int tmp = day;
            day = val;
            val = tmp;
          }
          else if (month > 12) {
            int tmp = day;
            day = month;
            month = tmp;
            tmp = day;
            day = val;
            val = tmp;
          }
        }
      }

      if (val > year - min_age(ch)) {
        printf_to_char(ch, "Your character must be at least %d.\n\r", min_age(ch));
        return;
      }
      if (val < year - max_age(ch)) {
        printf_to_char(ch, "Your character must be at most %d.\n\r", max_age(ch));
        return;
      }
      if (month < 1 || month > 12) {
        send_to_char("Please select a month between 1 and 12.\n\r", ch);
        return;
      }
      if (day < 1 || day > 28) {
        send_to_char("Please select a day between 1 and 28.\n\r", ch);
        return;
      }

      ch->pcdata->birth_year = val;
      ch->pcdata->birth_month = month;
      ch->pcdata->birth_day = day;

      ch->pcdata->height_feet = extract_feet(ch);
      ch->pcdata->height_inches = extract_inches(ch);
      printf_to_char(
      ch, "Birthday is now %d %d %d, you are %d.\nYou are now %d'%d tall.\n\r", ch->pcdata->birth_year, ch->pcdata->birth_month, ch->pcdata->birth_day, get_true_age(ch), ch->pcdata->height_feet, ch->pcdata->height_inches);
      if (get_true_age(ch) < 30)
      printf_to_char(
      ch, "You should know some stats and concepts are age-locked. Specifically veterans need to be around 30 and you need to be at least 25 to take the mental discipline ability.\n\r");

      return;
    }
    if (!str_cmp(arg1, "deathday") && ch->in_room->vnum == ROOM_INDEX_GENESIS && is_vampire(ch)) {
      tm *ptm;
      ptm = gmtime(&current_time);
      char arg2[MSL];
      char arg3[MSL];
      argument = one_argument_nouncap(argument, arg2);
      argument = one_argument_nouncap(argument, arg3);

      int val = atoi(arg2);

      if (val - ch->pcdata->birth_year < min_aage(ch)) {
        printf_to_char(ch, "Your char must look at least %d\n\r", min_aage(ch));
        return;
      }
      if (val - ch->pcdata->birth_year > max_aage(ch)) {
        printf_to_char(ch, "Your char must look at most %d\n\r", max_aage(ch));
        return;
      }
      int year = ptm->tm_year + 1900;
      int yearsired = year - val;
      if (ch->race == RACE_NEWVAMPIRE && (yearsired > 20)) {
        send_to_char("You have to be a vampire for 0-20 years.\n\r", ch);
        return;
      }
      if (ch->race == RACE_VETVAMPIRE && (yearsired < 50 || yearsired > 150)) {
        send_to_char("You have to be a vampire for 50-150 years.\n\r", ch);
        return;
      }
      if (ch->race == RACE_OLDVAMPIRE && (yearsired < 200 || yearsired > 800)) {
        send_to_char("You have to be a vampire for 200-800 years.\n\r", ch);
        return;
      }
      if (ch->race == RACE_ANCIENTVAMPIRE && (yearsired < 1000)) {
        send_to_char("You have to be a vampire for 1000+ years.\n\r", ch);
        return;
      }

      int month = atoi(arg3);
      if (month < 1 || month > 12) {
        send_to_char("Please select a month between 1 and 12.\n\r", ch);
        return;
      }
      int day = atoi(argument);
      if (day < 1 || day > 28) {
        send_to_char("Please select a day between 1 and 28.\n\r", ch);
        return;
      }

      ch->pcdata->sire_year = val;
      ch->pcdata->sire_month = month;
      ch->pcdata->sire_day = day;

      printf_to_char(ch, "Deathday is now %d %d %d, you look to be %d.\n\r", ch->pcdata->sire_year, ch->pcdata->sire_month, ch->pcdata->sire_day, get_age(ch));
      return;
    }
    if (!str_cmp(arg1, "height")) {

      argument = one_argument_nouncap(argument, arg2);
      argument = one_argument_nouncap(argument, arg3);

      if (ch->played / 3600 > 5 && ch->in_room->vnum != ROOM_INDEX_GENESIS) {
        send_to_char("It's been over five hours since you created.  Please use the procedure command instead.\n\r", ch);
        return;
      }

      if (!str_cmp(arg2, "feet")) {
        if (change_feet(ch, arg3) == TRUE) {
          int orig = ch->pcdata->height_feet;
          ch->pcdata->height_feet = atoi(arg3);
          char buf[MSL];
          sprintf(buf, "%d", ch->pcdata->height_inches);
          if (!change_inches(ch, buf)) {
            send_to_char("That's not a valid height.\n\r", ch);
            ch->pcdata->height_feet = orig;
            return;
          }
        }
        else {
          return;
        }
      }
      else if (!str_cmp(arg2, "inches")) {
        if (change_inches(ch, arg3) == TRUE) {
          ch->pcdata->height_inches = atoi(arg3);
        }
        else {
          return;
        }
      }
      else {
        send_to_char("`cSyntax`g: `Wchange height `g(`Wfeet`g/`Winches`g) (`Wvalue)`x .\n\r", ch);
      }

      printf_to_char(ch, "You are %d'%d tall.\n\n\r", ch->pcdata->height_feet, ch->pcdata->height_inches);
      return;
    }
    // player ghosts - Discordance
    else if (!str_cmp(arg1, "ghost")) {

      if (IS_FLAG(ch->act, PLR_DEAD)) {
        if (ch->in_room->vnum == 98 && ch->pcdata->ghost_banishment == 0) {
          if (available_donated(ch) >= 1500 && !IS_FLAG(ch->act, PLR_GUEST)) {
            if (ch->pcdata->final_death_date + (3600 * 24 * 3) < current_time) {
              SET_FLAG(ch->act, PLR_GHOST);
              refresh_ghost_abilities(ch);
              char_from_room(ch);
              ROOM_INDEX_DATA *location = get_room_index(11311);
              char_to_room(ch, location);
              do_function(ch, &do_look, "auto");
              send_to_char("The obsession with the person you once were grips and guides you to walk again amoungst the living.\n\r", ch);
            }
            else {
              send_to_char("Not even Jesus Christ was reported to rise in less than three days nor shall you.\n\r", ch);
            }
          }
          else {
            send_to_char("You don't have enough community credit to walk again amoungst the living.\n\r", ch);
          }
        }
        else {
          send_to_char("You already walk amoungst the living.\n\r", ch);
        }
      }
      else {
        send_to_char("What's your rush now?  Everyone will have his day to die.\n\r", ch);
      }
    }
    send_to_char("Syntax: Change (field) (variable)\n\r", ch);
  }

  _DOFUN(do_bind) {
    CHAR_DATA *victim;
    char arg1[MSL];
    argument = one_argument_nouncap(argument, arg1);

    if ((victim = get_char_world_pc(arg1)) != NULL && victim->pcdata->ghost_room == ch->in_room->vnum && (IS_FLAG(victim->act, PLR_GHOSTWALKING) || victim->pcdata->spectre > 0)) {
      if (ch->played / 3600 < 75 && ch->pcdata->account->maxhours < 100 && is_dreaming(victim))
      do_function(victim, &do_wake, "");

      if (is_helpless(ch)) {
        send_to_char("You can't do that.\n\r", ch);
        return;
      }
      if (IS_FLAG(victim->act, PLR_BOUND) && IS_FLAG(victim->act, PLR_BOUNDFEET)) {
        send_to_char("They're already bound.\n\r", ch);
        return;
      }
      if (is_ghost(ch)) {
        send_to_char("You can't get a grip on them.\n\r", ch);
        return;
      }
      if (IS_FLAG(ch->act, PLR_SHROUD) != IS_FLAG(victim->act, PLR_SHROUD)) {
        send_to_char("You can't get a grip on them.\n\r", ch);
        return;
      }

      if (higher_power(ch) && power_bound(ch) && !IS_NPC(victim) && str_cmp(ch->pcdata->place, victim->pcdata->place)) {
        send_to_char("Your power is bound.\n\r", ch);
        return;
      }

      if (!IS_NPC(victim) && victim->pcdata->trance > 0)
      victim->pcdata->trance = -20;

      if (!str_cmp(argument, "hands")) {
        if (IS_FLAG(victim->act, PLR_BOUND)) {
          send_to_char("Their hands are already tied.\n\r", ch);
          return;
        }
        SET_FLAG(victim->act, PLR_BOUND);
        act("You bind $N's hands securely.", ch, NULL, victim, TO_CHAR);
        act("You feel something happen to your body.", ch, NULL, victim, TO_VICT);
        act("$n binds $N's hands securely.", ch, NULL, victim, TO_NOTVICT);
        return;
      }
      if (!str_cmp(argument, "feet")) {
        if (IS_FLAG(victim->act, PLR_BOUNDFEET)) {
          send_to_char("Their feet are already tied.\n\r", ch);
          return;
        }
        SET_FLAG(victim->act, PLR_BOUNDFEET);
        act("You bind $N's feet securely.", ch, NULL, victim, TO_CHAR);
        act("You feel something happen to your body.", ch, NULL, victim, TO_VICT);
        act("$n binds $N's feet securely.", ch, NULL, victim, TO_NOTVICT);
        return;
      }
      SET_FLAG(victim->act, PLR_BOUNDFEET);
      SET_FLAG(victim->act, PLR_BOUND);
      act("You bind $N securely.", ch, NULL, victim, TO_CHAR);
      act("You feel something happen to your body.", ch, NULL, victim, TO_VICT);
      act("$n binds $N securely.", ch, NULL, victim, TO_NOTVICT);
      return;
    }

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (ch->played / 3600 < 75 && ch->pcdata->account->maxhours < 100 && is_dreaming(victim))
    do_function(victim, &do_wake, "");

    if (is_helpless(ch) || IS_FLAG(ch->act, PLR_BOUNDFEET)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (is_ghost(ch)) {
      send_to_char("You can't get a good grip on it.\n\r", ch);
      return;
    }
    if (higher_power(ch) && power_bound(ch) && !IS_NPC(victim) && str_cmp(ch->pcdata->place, victim->pcdata->place)) {
      send_to_char("Your power is bound.\n\r", ch);
      return;
    }

    if (IS_FLAG(victim->act, PLR_BOUND) && IS_FLAG(victim->act, PLR_BOUNDFEET)) {
      send_to_char("They're already bound.\n\r", ch);
      return;
    }
    if (in_fight(ch) && ch != victim) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (is_animal(ch) && get_animal_genus(ch, ANIMAL_ACTIVE) != GENUS_HYBRID)
    return;
    if (room_hostile(ch->in_room) && ch != victim) {
      start_hostilefight(ch);
      return;
    }

    if (!IS_NPC(victim) && victim->pcdata->trance > 0)
    victim->pcdata->trance = -20;

    if (!is_helpless(victim) && ch != victim && !IS_FLAG(victim->act, PLR_BOUNDFEET) && (!is_prisoner(victim) || is_prisoner(ch))) {
      send_to_char("They probably aren't going to let you do that.\n\r", ch);
      return;
    }

    if (ch == victim && !room_hostile(ch->in_room) && !in_fight(ch)) {
      victim->pcdata->selfbondage = 1;
    }

    // ghostie check and limit for bind -Discordance
    if (is_ghost(ch)) {
      if (is_manifesting(ch)) {
        if (deplete_ghostpool(ch, GHOST_MANIFESTATION) == FALSE) {
          send_to_char("You can't muster the strength to project your thoughts any more today.\n\r", ch);
          return;
        }
      }
      else {
        send_to_char("You must be prepared to manifest your will.\n\r", ch);
        return;
      }
    }

    if (!str_cmp(argument, "hands")) {
      if (IS_FLAG(victim->act, PLR_BOUND)) {
        send_to_char("Their hands are already tied.\n\r", ch);
        return;
      }
      SET_FLAG(victim->act, PLR_BOUND);
      act("You bind $N's hands securely.", ch, NULL, victim, TO_CHAR);
      act("$n binds your hands securely.", ch, NULL, victim, TO_VICT);
      act("$n binds $N's hands securely.", ch, NULL, victim, TO_NOTVICT);
      return;
    }

    if (!str_cmp(argument, "feet")) {
      if (IS_FLAG(victim->act, PLR_BOUNDFEET)) {
        send_to_char("Their feet are already tied.\n\r", ch);
        return;
      }
      SET_FLAG(victim->act, PLR_BOUNDFEET);
      act("You bind $N's feet securely.", ch, NULL, victim, TO_CHAR);
      act("$n binds your feet securely.", ch, NULL, victim, TO_VICT);
      act("$n binds $N's hands securely.", ch, NULL, victim, TO_NOTVICT);
      return;
    }
    if (!IS_FLAG(victim->act, PLR_BOUND))
    SET_FLAG(victim->act, PLR_BOUND);
    if (!IS_FLAG(victim->act, PLR_BOUNDFEET))
    SET_FLAG(victim->act, PLR_BOUNDFEET);
    act("You bind $N securely.", ch, NULL, victim, TO_CHAR);
    act("$n binds $N securely.", ch, NULL, victim, TO_NOTVICT);
    act("$n binds you securely.", ch, NULL, victim, TO_VICT);
  }
  _DOFUN(do_untie) {
    CHAR_DATA *victim;
    char arg1[MSL];
    argument = one_argument_nouncap(argument, arg1);

    if (is_gm(ch) && lair_room(ch->in_room)) {
      send_to_char("Does that seem even remotely like something you should be doing?\n\r", ch);
      return;
    }
    if (IS_FLAG(ch->act, PLR_BOUNDFEET)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }

    if ((victim = get_char_world_pc(arg1)) != NULL && victim->pcdata->ghost_room == ch->in_room->vnum && (IS_FLAG(victim->act, PLR_GHOSTWALKING) || victim->pcdata->spectre > 0)) {
      if (is_helpless(ch)) {
        send_to_char("You can't do that.\n\r", ch);
        return;
      }
      if (!IS_FLAG(victim->act, PLR_BOUND) && !IS_FLAG(victim->act, PLR_BOUNDFEET)) {
        send_to_char("They're not tied up.\n\r", ch);
        return;
      }
      if (is_ghost(ch)) {
        send_to_char("You can't get a grip on them.\n\r", ch);
        return;
      }
      if (room_hostile(ch->in_room)) {
        start_hostilefight(ch);
        return;
      }
      if (higher_power(ch) && power_bound(ch) && !IS_NPC(victim) && str_cmp(ch->pcdata->place, victim->pcdata->place)) {
        send_to_char("Your power is bound.\n\r", ch);
        return;
      }

      if (ch->pcdata->account != NULL && victim->pcdata->account != NULL) {
        if (!strcmp(ch->pcdata->account->name, victim->pcdata->account->name)) {
          send_to_char("You can't do that.\n\r", ch);
          return;
        }
      }

      if (clinic_patient(victim) && (clinic_patient(ch) || college_student(ch, TRUE))) {
        send_to_char("Their straight-jacket is locked on.\n\r", ch);
        return;
      }

      if (!str_cmp(argument, "hands")) {
        if (IS_FLAG(victim->act, PLR_BOUND))
        REMOVE_FLAG(victim->act, PLR_BOUND);
        act("You untie $N's hands.", ch, NULL, victim, TO_CHAR);
        act("You feel something happen to your body.", ch, NULL, victim, TO_VICT);
        act("$n unties $N's hands.", ch, NULL, victim, TO_NOTVICT);
        victim->hit = 0;
        if (victim->in_room != NULL && (victim->in_room->area->vnum >= OUTER_NORTH_FOREST && victim->in_room->area->vnum <= OUTER_WEST_FOREST))
        victim->pcdata->spawned_monsters = 400;
        return;
      }
      if (!str_cmp(argument, "feet")) {
        if (IS_FLAG(victim->act, PLR_BOUNDFEET))
        REMOVE_FLAG(victim->act, PLR_BOUNDFEET);
        act("You untie $N's feet.", ch, NULL, victim, TO_CHAR);
        act("You feel something happen to your body.", ch, NULL, victim, TO_VICT);
        act("$n unties $N's feet.", ch, NULL, victim, TO_NOTVICT);
        victim->hit = 0;
        if (victim->in_room != NULL && (victim->in_room->area->vnum >= OUTER_NORTH_FOREST && victim->in_room->area->vnum <= OUTER_WEST_FOREST))
        victim->pcdata->spawned_monsters = 400;
        return;
      }
      if (IS_FLAG(victim->act, PLR_BOUNDFEET))
      REMOVE_FLAG(victim->act, PLR_BOUNDFEET);
      if (IS_FLAG(victim->act, PLR_BOUND))
      REMOVE_FLAG(victim->act, PLR_BOUND);

      act("You untie $N.", ch, NULL, victim, TO_CHAR);
      act("You feel something happen to your body.", ch, NULL, victim, TO_VICT);
      act("$n unties $N.", ch, NULL, victim, TO_NOTVICT);
      victim->hit = 0;
      if (victim->in_room != NULL && (victim->in_room->area->vnum >= OUTER_NORTH_FOREST && victim->in_room->area->vnum <= OUTER_WEST_FOREST))
      victim->pcdata->spawned_monsters = 400;
      return;
    }

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (is_animal(ch) && get_animal_genus(ch, ANIMAL_ACTIVE) != GENUS_HYBRID)
    return;
    if (clinic_patient(victim) && (clinic_patient(ch) || college_student(ch, TRUE))) {
      send_to_char("Their straight-jacket is locked on.\n\r", ch);
      return;
    }

    if (higher_power(ch) && power_bound(ch) && !IS_NPC(victim) && str_cmp(ch->pcdata->place, victim->pcdata->place)) {
      send_to_char("Your power is bound.\n\r", ch);
      return;
    }

    if (!IS_FLAG(victim->act, PLR_BOUND) && !IS_FLAG(victim->act, PLR_BOUNDFEET)) {
      send_to_char("They're not tied up bound.\n\r", ch);
      return;
    }

    if (is_ghost(ch)) {
      send_to_char("You can't get a good grip on it.\n\r", ch);
      return;
    }

    // ghostie check and limit for untie -Discordance
    if (is_ghost(ch)) {
      if (is_manifesting(ch)) {
        if (deplete_ghostpool(ch, GHOST_MANIFESTATION) == FALSE) {
          send_to_char("You can't muster the strength to project your thoughts any more today.\n\r", ch);
          return;
        }
      }
      else {
        send_to_char("You must be prepared to manifest this power.\n\r", ch);
        return;
      }
    }
    if (room_hostile(ch->in_room)) {
      act("$n moves to untie $N.", ch, NULL, victim, TO_ROOM);
      start_hostilefight(ch);
      return;
    }

    if (!str_cmp(argument, "hands")) {
      if (IS_FLAG(victim->act, PLR_BOUND))
      REMOVE_FLAG(victim->act, PLR_BOUND);
      act("You untie $N's hands.", ch, NULL, victim, TO_CHAR);
      act("$n unties your hands.", ch, NULL, victim, TO_VICT);
      act("$n unties $N's hands.", ch, NULL, victim, TO_NOTVICT);
      victim->hit = 0;
      if (victim->in_room != NULL && (victim->in_room->area->vnum >= OUTER_NORTH_FOREST && victim->in_room->area->vnum <= OUTER_WEST_FOREST))
      victim->pcdata->spawned_monsters = 400;
      return;
    }
    if (!str_cmp(argument, "feet")) {
      if (IS_FLAG(victim->act, PLR_BOUNDFEET))
      REMOVE_FLAG(victim->act, PLR_BOUNDFEET);
      act("You untie $N's feet.", ch, NULL, victim, TO_CHAR);
      act("$n unties your feet.", ch, NULL, victim, TO_VICT);
      act("$n unties $N's feet.", ch, NULL, victim, TO_NOTVICT);
      victim->hit = 0;
      if (victim->in_room != NULL && (victim->in_room->area->vnum >= OUTER_NORTH_FOREST && victim->in_room->area->vnum <= OUTER_WEST_FOREST))
      victim->pcdata->spawned_monsters = 400;
      return;
    }

    if (IS_FLAG(victim->act, PLR_BOUND))
    REMOVE_FLAG(victim->act, PLR_BOUND);
    if (IS_FLAG(victim->act, PLR_BOUNDFEET))
    REMOVE_FLAG(victim->act, PLR_BOUNDFEET);

    act("You untie $N.", ch, NULL, victim, TO_CHAR);
    act("$n unties you.", ch, NULL, victim, TO_VICT);
    act("$n unties $N.", ch, NULL, victim, TO_NOTVICT);
    victim->hit = 0;
    if (victim->in_room != NULL && (victim->in_room->area->vnum >= OUTER_NORTH_FOREST && victim->in_room->area->vnum <= OUTER_WEST_FOREST))
    victim->pcdata->spawned_monsters = 400;
  }

  _DOFUN(do_execute) {
    CHAR_DATA *victim;

    if (ch->played / 3600 < 30)
    return;
    if (is_animal(ch))
    return;
    if (guestmonster(ch) && ch->played / 3600 < 100)
    return;
    if (higher_power(ch))
    return;

    if ((victim = get_char_world_pc(argument)) != NULL && victim->pcdata->ghost_room == ch->in_room->vnum && (IS_FLAG(victim->act, PLR_GHOSTWALKING) || victim->pcdata->spectre > 0)) {
      if (!IS_NPC(victim) && victim->pcdata->trance > 0)
      victim->pcdata->trance = -20;

      if (is_helpless(ch)) {
        send_to_char("You can't do that.\n\r", ch);
        return;
      }

      if (room_hostile(ch->in_room)) {
        start_hostilefight(ch);
        return;
      }

      if (in_fight(ch)) {
        send_to_char("You're a bit busy.\n\r", ch);
        return;
      }

      if (under_understanding(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }
      if (under_limited(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }

      if (is_griefer(ch)) {
        send_to_char("You can't do that.\n\r", ch);
        return;
      }

      if (!IS_NPC(victim) && victim->pcdata->trance > 0)
      victim->pcdata->trance = -20;

      if (!IS_NPC(victim) && get_skill(victim, SKILL_IMMORTALITY) < 1)
      killplayer(ch, victim);

      act("You execute $N.", ch, NULL, victim, TO_CHAR);
      act("$n executes $N.", ch, NULL, victim, TO_NOTVICT);

      if (get_skill(victim, SKILL_IMMORTALITY) < 1) {
        act("Your body dies.", ch, NULL, victim, TO_VICT);
        real_kill(victim, ch);
        free_string(victim->pcdata->deathcause);
        victim->pcdata->deathcause = str_dup("An execution style killing.");

        if (IS_FLAG(victim->act, PLR_BOUND))
        REMOVE_FLAG(victim->act, PLR_BOUND);
        if (IS_FLAG(victim->act, PLR_BOUNDFEET))
        REMOVE_FLAG(victim->act, PLR_BOUNDFEET);
      }

      return;
    }

    if ((victim = get_char_room(ch, NULL, argument)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (is_ghost(ch)) {
      send_to_char("Slaying the living is no longer so simple./n/r", ch);
      return;
    }

    if (is_ghost(victim)) {
      send_to_char("Slaying a ghost is not so simple./n/r", ch);
      return;
    }
    if (!IS_NPC(victim) && victim->pcdata->trance > 0)
    victim->pcdata->trance = -20;

    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (!is_helpless(victim)) {
      send_to_char("You'd have to subdue them first.\n\r", ch);
      return;
    }
    if (higher_power(victim) || higher_power(ch))
    return;

    if (under_understanding(victim, ch)) {
      send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
      return;
    }
    if (under_limited(victim, ch)) {
      send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
      return;
    }

    if (higher_power(victim))
    return;

    if (!IS_NPC(victim) && get_skill(victim, SKILL_IMMORTALITY) < 1)
    killplayer(ch, victim);

    act("You execute $N.", ch, NULL, victim, TO_CHAR);
    act("$n executes you.", ch, NULL, victim, TO_VICT);
    act("$n executes $N.", ch, NULL, victim, TO_NOTVICT);

    if (get_skill(victim, SKILL_IMMORTALITY) < 1) {
      real_kill(victim, ch);
      free_string(victim->pcdata->deathcause);
      victim->pcdata->deathcause = str_dup("An execution style killing.");

      if (IS_FLAG(victim->act, PLR_BOUND))
      REMOVE_FLAG(victim->act, PLR_BOUND);
      if (IS_FLAG(victim->act, PLR_BOUNDFEET))
      REMOVE_FLAG(victim->act, PLR_BOUNDFEET);
    }
  }

  _DOFUN(do_behead) {
    CHAR_DATA *victim;

    if (ch->played / 3600 < 30)
    return;

    if (is_animal(ch))
    return;
    if (guestmonster(ch))
    return;
    if (higher_power(ch))
    return;

    if (!holding_lweapon(ch)) {
      send_to_char("You'll need a sword or axe first.\n\r", ch);
      return;
    }

    if ((victim = get_char_world_pc(argument)) != NULL && victim->pcdata->ghost_room == ch->in_room->vnum && (IS_FLAG(victim->act, PLR_GHOSTWALKING) || victim->pcdata->spectre > 0)) {
      if (!IS_NPC(victim) && victim->pcdata->trance > 0)
      victim->pcdata->trance = -20;

      if (is_helpless(ch)) {
        send_to_char("You can't do that.\n\r", ch);
        return;
      }

      if (room_hostile(ch->in_room)) {
        start_hostilefight(ch);
        return;
      }
      if (under_understanding(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }
      if (under_limited(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }

      if (higher_power(victim))
      return;
      if (higher_power(ch))
      return;

      if (!IS_NPC(victim) && victim->pcdata->trance > 0)
      victim->pcdata->trance = -20;

      if (!IS_NPC(victim))
      killplayer(ch, victim);

      act("You behead $N.", ch, NULL, victim, TO_CHAR);
      act("Your behead dies.", ch, NULL, victim, TO_VICT);
      act("$n beheads $N.", ch, NULL, victim, TO_NOTVICT);
      real_kill_headless(victim, ch);
      free_string(victim->pcdata->deathcause);
      victim->pcdata->deathcause = str_dup("A beheading.");

      if (IS_FLAG(victim->act, PLR_BOUND))
      REMOVE_FLAG(victim->act, PLR_BOUND);
      if (IS_FLAG(victim->act, PLR_BOUNDFEET))
      REMOVE_FLAG(victim->act, PLR_BOUNDFEET);

      return;
    }

    if ((victim = get_char_room(ch, NULL, argument)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }
    if (!IS_NPC(victim) && victim->pcdata->trance > 0)
    victim->pcdata->trance = -20;

    if (is_ghost(ch)) {
      send_to_char("Slaying the living is no longer so simple./n/r", ch);
      return;
    }

    if (is_ghost(victim)) {
      send_to_char("Slaying a ghost is not so simple./n/r", ch);
      return;
    }

    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (!is_helpless(victim)) {
      send_to_char("You'd have to subdue them first.\n\r", ch);
      return;
    }

    if (under_understanding(victim, ch)) {
      send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
      return;
    }
    if (under_limited(victim, ch)) {
      send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
      return;
    }
    if (higher_power(victim))
    return;
    if (higher_power(ch))
    return;

    if (!IS_NPC(victim))
    killplayer(ch, victim);

    act("You behead $N.", ch, NULL, victim, TO_CHAR);
    act("$n beheads you.", ch, NULL, victim, TO_VICT);
    act("$n beheads $N.", ch, NULL, victim, TO_NOTVICT);
    real_kill_headless(victim, ch);
    free_string(victim->pcdata->deathcause);
    victim->pcdata->deathcause = str_dup("A beheading.");
    if (IS_FLAG(victim->act, PLR_BOUND))
    REMOVE_FLAG(victim->act, PLR_BOUND);
    if (IS_FLAG(victim->act, PLR_BOUNDFEET))
    REMOVE_FLAG(victim->act, PLR_BOUNDFEET);
  }

  void message_to_char(char *name, char *message) {
    struct stat sb;
    char buf[MSL];
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    CHAR_DATA *victim;

    d.original = NULL;
    if ((victim = get_char_world_pc(name)) != NULL) // Victim is online.
    online = TRUE;
    else {
      log_string("DESCRIPTOR: Message to char");

      if (!load_char_obj(&d, name)) {
        return;
      }

      sprintf(buf, "%s%s", PLAYER_DIR, capitalize(name));
      stat(buf, &sb);
      victim = d.character;
    }
    if (IS_NPC(victim)) {
      if (!online)
      free_char(victim);

      return;
    }
    sprintf(buf, "%s\n%s", victim->pcdata->messages, message);
    free_string(victim->pcdata->messages);
    victim->pcdata->messages = str_dup(buf);

    save_char_obj(victim, FALSE, FALSE);

    if (online)
    printf_to_char(victim, "You get a new message: %s\n\r", message);

    if (!online)
    free_char(victim);
  }

  _DOFUN(do_timeswept) {
    if (!is_number(argument)) {
      send_to_char("Syntax: timeswept (number of years)\n\r", ch);
      return;
    }
    if (get_skill(ch, SKILL_TIMESWEPT) < 1 && ch->race != RACE_TIMESWEPT) {
      send_to_char("You need to get the timeswept blood stat first\n\r", ch);
      return;
    }
    if (ch->in_room->vnum == ROOM_INDEX_GENESIS) {
      send_to_char("Wait until you're finished with genesis.\n\r", ch);
      return;
    }
    if (ch->pcdata->birth_year - atoi(argument) > 2010) {
      send_to_char("Timeswept characters can only be from the past.\n\r", ch);
      return;
    }

    int val = atoi(argument);
    if (val + ch->pcdata->timeswept > 3000 && is_super(ch)) {
      send_to_char("Supernaturals did not exist at that point of history.\n\r", ch);
      return;
    }
    if (ch->pcdata->birth_year - val < -2000 && is_super(ch)) {
      send_to_char("Supernaturals did not exist at that point of history.\n\r", ch);
      return;
    }

    ch->pcdata->timeswept += atoi(argument);
    ch->pcdata->birth_year -= atoi(argument);
    if (is_vampire(ch)) {
      ch->pcdata->sire_year -= atoi(argument);
    }

    printf_to_char(ch, "You've been out of time for %d years.\n\r", ch->pcdata->timeswept);
  }

  _DOFUN(do_minion) {
    if (!str_cmp(argument, "info")) {
      int i = 0;
      printf_to_char(
      ch, "[%d] %s\nShort: %s\nDesc: %s\n%s: %d\n%s: %d\n%s: %d\n\r", i, ch->pcdata->monster_names[0][i], ch->pcdata->monster_names[1][i], ch->pcdata->monster_names[2][i], get_disc_string(ch->pcdata->monster_discs[0][i]), ch->pcdata->monster_discs[1][i], get_disc_string(ch->pcdata->monster_discs[2][i]), ch->pcdata->monster_discs[3][i], get_disc_string(ch->pcdata->monster_discs[4][i]), ch->pcdata->monster_discs[5][i]);
    }
  }
  _DOFUN(do_ally) {
    if (!str_cmp(argument, "info")) {
      int i = 1;
      printf_to_char(
      ch, "[%d] %s\nShort: %s\nDesc: %s\n%s: %d\n%s: %d\n%s: %d\n\r", i, ch->pcdata->monster_names[0][i], ch->pcdata->monster_names[1][i], ch->pcdata->monster_names[2][i], get_disc_string(ch->pcdata->monster_discs[0][i]), ch->pcdata->monster_discs[1][i], get_disc_string(ch->pcdata->monster_discs[2][i]), ch->pcdata->monster_discs[3][i], get_disc_string(ch->pcdata->monster_discs[4][i]), ch->pcdata->monster_discs[5][i]);
    }
  }

  void shroudescape(CHAR_DATA *ch) {
    if (ch->pcdata->patrol_status != PATROL_WAGINGWAR) {
      return;
    }
    logevent_check(ch, logact("`r$n fades out of the nightmare.`x", ch, ch));

    int pop = 0;
    for (CharList::iterator it = char_list.begin(); it != char_list.end(); ++it) {
      CHAR_DATA *victim = *it;

      if (victim == NULL || IS_IMMORTAL(victim))
      continue;
      if (ch == victim)
      continue;
      if (same_fight(ch, victim) || (ch->in_room == victim->in_room && IS_FLAG(victim->act, PLR_SHROUD))) {
        pop++;
      }
    }
    int amount = 600;
    pop = UMAX(1, pop);
    amount /= pop;
    for (CharList::iterator it = char_list.begin(); it != char_list.end(); ++it) {
      CHAR_DATA *victim = *it;

      if (victim == NULL || IS_IMMORTAL(victim))
      continue;
      if (ch == victim)
      continue;
      if (same_fight(ch, victim) || (ch->in_room == victim->in_room && IS_FLAG(victim->act, PLR_SHROUD))) {
        int give = amount * victim->hit / max_hp(victim);
        use_lifeforce(ch, give / 4, "shroud escape");
        give *= 2;
        give_lifeforce(victim, (give + 100), "shroud escape");
        WAIT_STATE(victim, PULSE_PER_SECOND * 10);
      }
    }
    act("$n fades out of the nightmare.", ch, NULL, NULL, TO_ROOM);
    act("You fade out of the nightmare.", ch, NULL, NULL, TO_CHAR);
    dact("$n fades out of the nightmare.", ch, NULL, NULL, DISTANCE_MEDIUM);
    if (IS_FLAG(ch->act, PLR_SHROUD))
    REMOVE_FLAG(ch->act, PLR_SHROUD);
    if (IS_FLAG(ch->act, PLR_DEEPSHROUD))
    REMOVE_FLAG(ch->act, PLR_DEEPSHROUD);
    ch->fighting = FALSE;
    ch->attacking = 0;
    if (fight_over(ch->in_room) == TRUE) {
      end_fight(ch->in_room);
    }
    wake_char(ch);
    act("You awaken.", ch, NULL, NULL, TO_CHAR);
    act("$n wakes up.", ch, NULL, NULL, TO_ROOM);
  }

  void shroud_deja(ROOM_INDEX_DATA *room) {
    for (CharList::iterator it = room->people->begin(); it != room->people->end();
    ++it) {
      CHAR_DATA *rch = *it;
      if (IS_NPC(rch) || can_shroud(rch))
      continue;
      if (IS_FLAG(rch->act, PLR_SHROUD))
      continue;
      if (number_percent() % 3 == 0)
      send_to_char("You space out for a moment.\n\r", rch);
      else if (number_percent() % 2 == 0)
      send_to_char("You forget what you were just about to do.\n\r", rch);
      else
      send_to_char("You have a moment of deja vu.\n\r", rch);
    }
  }

  int recent_dreamworld(void) {
    int max = 0;
    int point = 0;
    int count = 0;

    for (vector<FANTASY_TYPE *>::iterator it = FantasyVect.begin();
    it != FantasyVect.end(); ++it) {
      if ((*it)->valid == FALSE)
      continue;
      if ((*it)->active == FALSE)
      continue;

      if (safe_strlen((*it)->elevator) < 3)
      continue;

      if ((*it)->lastused > max) {
        point = count;
        max = (*it)->lastused;
      }
      count++;
    }
    return point;
  }

  _DOFUN(do_shroud) {
    if (IS_FLAG(ch->act, PLR_DEAD)) {
      send_to_char("Haven holds your spirit fast.\n\r", ch);
      return;
    }

    if (institute_room(ch->in_room)) {
      send_to_char("The nightmare seems too disturbed in this location for that to work.\n\r", ch);
      return;
    }

    char arg1[MSL];
    argument = one_argument(argument, arg1);

    if (battleground(ch->in_room) && !str_cmp(arg1, "pull")) {
      action_prep(ch, 1, argument);
      return;
    }
    if (!can_shroud(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (higher_power(ch) && power_bound(ch)) {
      send_to_char("Your power is bound.\n\r", ch);
      return;
    }

    if (ch->pcdata->travel_time > -1) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }

    if (ch->pcdata->spectre > 0) {
      send_to_char("Use wake instead.\n\r", ch);
      return;
    }

    if (!is_gm(ch) && in_fight(ch)) {
      send_to_char("The nightmare is too chaotic right now for you to do that\n\r", ch);
      return;
    }
    if (is_helpless(ch)) {
      send_to_char("You don't have the freedom to do that.\n\r", ch);
      return;
    }

    if (!str_cmp(arg1, "pull")) {
      CHAR_DATA *victim = get_char_fight(ch, argument);
      if (victim == NULL || is_gm(victim)) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (guestmonster(ch)) {
        send_to_char("You can't do that.\n\r", ch);
        return;
      }

      if (ch->pcdata->overworked > 0) {
        send_to_char("You are too tired.\n\r", ch);
        return;
      }

      if (IS_NPC(victim)) {
        if (victim->pIndexData->vnum < 160 || victim->pIndexData->vnum > 162) {
          send_to_char("They're not here.\n\r", ch);
          return;
        }
      }

      if (in_lodge(victim->in_room)) {
        send_to_char("You can't reach them with the nightmare.\n\r", ch);
        return;
      }
      if (!IS_FLAG(victim->comm, COMM_MANDRAKE) && prop_from_room(victim->in_room) != NULL && prop_from_room(victim->in_room)->shroudshield >= 50) {
        send_to_char("You can't reach them with the nightmare.\n\r", ch);
        return;
      }
      if (has_weakness(ch, victim) || is_helpless(victim) || in_fight(victim)) {
        send_to_char("You can't reach them with the nightmare.\n\r", ch);
        return;
      }

      if (nearby_deep(ch->in_room)) {
        send_to_char("The deep nightmare seems too disturbed in this location for that to work.\n\r", ch);
        return;
      }
      if (pc_pop(ch->in_room) < 4)
      villain_mod(ch, 40, "Shroud snipe");
      if (IS_FLAG(ch->act, PLR_HIDE))
      REMOVE_FLAG(ch->act, PLR_HIDE);

      act("You release an arc of near-invisible lightning through the nightmare to strike $N.", ch, NULL, victim, TO_CHAR);
      act("$n releases an arc of near-invisible lightning through the nightmare to strike $N, sucking $M in.", ch, NULL, victim, TO_NOTVICT);
      act("$n releases an arc of near-invisible lightning through the nightmare to strike you, sucking you in.", ch, NULL, victim, TO_VICT);
      dact("$n releases an arc of near-invisible lightning through the nightmare to strike $N, sucking $M in.", ch, NULL, victim, DISTANCE_NEAR);
      if (IS_NPC(victim)) {
        CHAR_DATA *newchar = victim->your_car;
        act("The vehicle is struck by an unseen force.", newchar, ch, NULL, TO_ROOM);
        act("The vehicle is struck by an unseen force.", newchar, ch, NULL, TO_CHAR);
        force_park(victim);
        victim = newchar;
      }
      int amount = 500;
      if (IS_FLAG(victim->comm, COMM_MANDRAKE))
      amount /= 4;
      if (!can_shroud(victim))
      amount *= 2;
      if (is_weakness(ch, victim))
      amount /= 3;
      use_lifeforce(ch, amount, "shroud snipe.");
      if (!IS_FLAG(victim->act, PLR_SHROUD))
      SET_FLAG(victim->act, PLR_SHROUD);
      if (!IS_FLAG(ch->act, PLR_SHROUD))
      SET_FLAG(ch->act, PLR_SHROUD);
      if (!IS_FLAG(victim->act, PLR_DEEPSHROUD))
      SET_FLAG(victim->act, PLR_DEEPSHROUD);
      if (!IS_FLAG(ch->act, PLR_DEEPSHROUD))
      SET_FLAG(ch->act, PLR_DEEPSHROUD);
      shroud_deja(ch->in_room);

      if (IS_FLAG(victim->act, PLR_HIDE))
      REMOVE_FLAG(victim->act, PLR_HIDE);

      victim->pcdata->nightmare_dragged = 1;
      for (DescList::iterator it = descriptor_list.begin();
      it != descriptor_list.end(); ++it) {
        DESCRIPTOR_DATA *d = *it;
        CHAR_DATA *to;
        if (d->character != NULL && d->connected == CON_PLAYING) {
          to = d->character;
          if (IS_NPC(to) || to->in_room == NULL)
          continue;

          if (IS_FLAG(to->act, PLR_DEEPSHROUD))
          continue;
          if (in_lodge(to->in_room))
          continue;
          if (to == victim || to == ch)
          continue;

          if (combat_distance(victim, to, FALSE) <= 200) {
            if (is_infused(to)) {
              if (!IS_FLAG(to->act, PLR_SHROUD))
              SET_FLAG(to->act, PLR_SHROUD);
              if (IS_FLAG(to->act, PLR_SHROUD) && !IS_FLAG(to->act, PLR_DEEPSHROUD))
              SET_FLAG(to->act, PLR_DEEPSHROUD);
              if (IS_FLAG(to->act, PLR_HIDE))
              REMOVE_FLAG(to->act, PLR_HIDE);

            }
            else if (can_shroud(to)) {
              to->pcdata->shroud_dragging = 30;
              to->pcdata->shroud_drag_depth = 2;
              send_to_char("A wave of invisible force washes over you, pulling you towards the nightmare.(Type nightmare to follow the wave and enter the nightmare and join the ensuing fight)\n\r", to);
            }
            if (to->in_room != victim->in_room)
            shroud_deja(to->in_room);
          }
        }
      }
      start_fight(ch, victim);
      return;
    }

    if (in_fight(ch)) {
      send_to_char("You're still in combat.\n\r", ch);
      return;
    }
    if (room_hostile(ch->in_room)) {
      start_hostilefight(ch);
      return;
    }

    if (IS_FLAG(ch->act, PLR_HIDE))
    REMOVE_FLAG(ch->act, PLR_HIDE);

    if (IS_FLAG(ch->act, PLR_SHROUD)) {
      if (guestmonster(ch) && ch->played / 3600 < time_info.monster_hours) {
        send_to_char("You can't do that.\n\r", ch);
        return;
      }

      if (!IS_FLAG(ch->act, PLR_DEEPSHROUD) && ch->pcdata->shroud_dragging > 0 && ch->pcdata->shroud_drag_depth == 2) {
        send_to_char("You step deeper into the nightmare.\n\r", ch);
        SET_FLAG(ch->act, PLR_DEEPSHROUD);

        if (!in_fight(ch) && check_fight(ch)) {
          if (next_fight_member(ch) != NULL) {
            ch->fight_fast = next_fight_member(ch)->fight_fast;
            ch->fight_speed = next_fight_member(ch)->fight_speed;
            ch->fight_current = next_fight_member(ch)->fight_current;
            ch->fight_next = next_fight_member(ch)->fight_next;
          }
          else
          ch->fight_fast = FALSE;

          join_to_fight(ch);
          ch->in_fight = TRUE;
          ch->attacking = 1;
          ch->hadturn = TRUE;
        }
        return;
      }
      if (!mirror_room(ch->in_room)) {
        send_to_char("You need a mirror to leave the nightmare.\n\r", ch);
        return;
      }
      act("$n leaves the nightmare.", ch, NULL, NULL, TO_ROOM);
      send_to_char("You leave the nightmare.\n\r", ch);
      shroud_deja(ch->in_room);
      REMOVE_FLAG(ch->act, PLR_SHROUD);
      if (IS_FLAG(ch->act, PLR_DEEPSHROUD))
      REMOVE_FLAG(ch->act, PLR_DEEPSHROUD);

      if (!in_fight(ch) && check_fight(ch)) {
        if (next_fight_member(ch) != NULL) {
          ch->fight_fast = next_fight_member(ch)->fight_fast;
          ch->fight_speed = next_fight_member(ch)->fight_speed;
          ch->fight_current = next_fight_member(ch)->fight_current;
          ch->fight_next = next_fight_member(ch)->fight_next;
        }
        else
        ch->fight_fast = FALSE;

        ch->in_fight = TRUE;
        ch->attacking = 1;
        join_to_fight(ch);
        ch->hadturn = TRUE;
      }
      shroud_deja(ch->in_room);
      for (CharList::iterator it = ch->in_room->people->begin();
      it != ch->in_room->people->end();) {
        CHAR_DATA *fch = *it;
        ++it;

        if (fch == NULL || IS_NPC(fch) || fch == ch)
        continue;

        if (in_fight(fch))
        continue;
        if (fch->master == ch && !in_fight(ch) && IS_FLAG(fch->act, PLR_SHROUD) && !guestmonster(fch)) {
          act("You follow $N.", fch, NULL, ch, TO_CHAR);
          REMOVE_FLAG(fch->act, PLR_SHROUD);
          if (IS_FLAG(fch->act, PLR_DEEPSHROUD))
          REMOVE_FLAG(fch->act, PLR_DEEPSHROUD);
          if (!in_fight(fch) && check_fight(fch)) {
            if (next_fight_member(fch) != NULL) {
              fch->fight_fast = next_fight_member(fch)->fight_fast;
              fch->fight_speed = next_fight_member(fch)->fight_speed;
              fch->fight_current = next_fight_member(fch)->fight_current;
              fch->fight_next = next_fight_member(fch)->fight_next;
            }
            else
            fch->fight_fast = FALSE;
            fch->in_fight = TRUE;
            fch->attacking = 1;
            join_to_fight(fch);
            fch->hadturn = TRUE;
          }
        }
        else if (ch->dragging == fch && is_helpless(fch) && IS_FLAG(fch->act, PLR_SHROUD)) {
          act("$N drags you with $M.", fch, NULL, ch, TO_CHAR);
          REMOVE_FLAG(fch->act, PLR_SHROUD);
          if (IS_FLAG(fch->act, PLR_DEEPSHROUD))
          REMOVE_FLAG(fch->act, PLR_DEEPSHROUD);
          if (!in_fight(fch) && check_fight(fch)) {
            if (next_fight_member(fch) != NULL) {
              fch->fight_fast = next_fight_member(fch)->fight_fast;
              fch->fight_speed = next_fight_member(fch)->fight_speed;
              fch->fight_current = next_fight_member(fch)->fight_current;
              fch->fight_next = next_fight_member(fch)->fight_next;
            }
            else
            fch->fight_fast = FALSE;
            fch->in_fight = TRUE;
            fch->attacking = 1;
            join_to_fight(fch);
            fch->hadturn = TRUE;
          }
        }
        else if (ch->lifting == fch && is_helpless(fch) && IS_FLAG(fch->act, PLR_SHROUD)) {
          act("$N carries you with $M.", fch, NULL, ch, TO_CHAR);
          REMOVE_FLAG(fch->act, PLR_SHROUD);
          if (IS_FLAG(fch->act, PLR_DEEPSHROUD))
          REMOVE_FLAG(fch->act, PLR_DEEPSHROUD);
          if (!in_fight(fch) && check_fight(fch)) {
            if (next_fight_member(fch) != NULL) {
              fch->fight_fast = next_fight_member(fch)->fight_fast;
              fch->fight_speed = next_fight_member(fch)->fight_speed;
              fch->fight_current = next_fight_member(fch)->fight_current;
              fch->fight_next = next_fight_member(fch)->fight_next;
            }
            else
            fch->fight_fast = FALSE;
            fch->in_fight = TRUE;
            fch->attacking = 1;
            join_to_fight(fch);
            fch->hadturn = TRUE;
          }
        }
      }
      do_function(ch, &do_look, "auto");
    }
    else {
      if (event_cleanse == 1) {
        send_to_char("You can't seem to do that.\n\r", ch);
        return;
      }
      if (crisis_noshroud == 1) {
        send_to_char("You can't seem to do that.\n\r", ch);
        return;
      }

      if (ch->in_room != NULL && IS_SET(ch->in_room->room_flags, ROOM_NOSHROUD)) {
        send_to_char("You can't do that here.\n\r", ch);
        return;
      }

      if (is_helpless(ch)) {
        send_to_char("You're not free to do that.\n\r", ch);
        return;
      }

      if (in_lodge(ch->in_room)) {
        send_to_char("The nightmare seems too far away to access.\n\r", ch);
        return;
      }
      if (in_prop(ch) && prop_from_room(ch->in_room)->shroudshield >= 50 && ch->pcdata->shroud_dragging <= 0) {
        send_to_char("The nightmare seems too far away to access.\n\r", ch);
        return;
      }
      if (in_world(ch) != WORLD_EARTH && ch->in_room != NULL && ch->in_room->sector_type == SECT_FOREST) {
        send_to_char("You cannot reach the nightmare from here.\n\r", ch);
        return;
      }
      if (ch->pcdata->blood_potency > 50)
      ch->pcdata->blood_potency--;

      ch->pcdata->last_dreamworld = recent_dreamworld();
      send_to_char("You step into the nightmare.\n\r", ch);
      SET_FLAG(ch->act, PLR_SHROUD);
      if (ch->pcdata->shroud_dragging > 0 && ch->pcdata->shroud_drag_depth == 2 && !IS_FLAG(ch->act, PLR_DEEPSHROUD)) {
        SET_FLAG(ch->act, PLR_DEEPSHROUD);
      }

      if (!in_fight(ch) && check_fight(ch)) {
        if (next_fight_member(ch) != NULL) {
          ch->fight_fast = next_fight_member(ch)->fight_fast;
          ch->fight_speed = next_fight_member(ch)->fight_speed;
          ch->fight_current = next_fight_member(ch)->fight_current;
          ch->fight_next = next_fight_member(ch)->fight_next;
        }
        else
        ch->fight_fast = FALSE;
        ch->in_fight = TRUE;
        ch->attacking = 1;
        join_to_fight(ch);
        ch->hadturn = TRUE;
      }
      act("$n enters the nightmare.", ch, NULL, NULL, TO_ROOM);
      shroud_deja(ch->in_room);

      for (CharList::iterator it = ch->in_room->people->begin();
      it != ch->in_room->people->end();) {
        CHAR_DATA *fch = *it;
        ++it;

        if (fch == NULL || IS_NPC(fch) || fch == ch)
        continue;
        if (in_fight(fch))
        continue;

        if (fch->master == ch && !in_fight(ch) && !IS_FLAG(fch->act, PLR_SHROUD) && !guestmonster(fch) 
        && fetch_guestmonster() == NULL) {
          act("You follow $N.", fch, NULL, ch, TO_CHAR);
          SET_FLAG(fch->act, PLR_SHROUD);
          if (fch->pcdata->shroud_dragging > 0 && fch->pcdata->shroud_drag_depth == 2 && !IS_FLAG(fch->act, PLR_DEEPSHROUD)) {
            SET_FLAG(fch->act, PLR_DEEPSHROUD);
          }
          if (!IS_NPC(fch) && is_helpless(fch))
          fch->pcdata->nightmare_dragged = 1;
          if (!in_fight(fch) && check_fight(fch)) {
            if (next_fight_member(fch) != NULL) {
              fch->fight_fast = next_fight_member(fch)->fight_fast;
              fch->fight_speed = next_fight_member(fch)->fight_speed;
              fch->fight_current = next_fight_member(fch)->fight_current;
              fch->fight_next = next_fight_member(fch)->fight_next;
            }
            else
            fch->fight_fast = FALSE;
            fch->in_fight = TRUE;
            fch->attacking = 1;
            join_to_fight(fch);
            fch->hadturn = TRUE;
          }
        }
        else if (ch->dragging == fch && is_helpless(fch) && !IS_FLAG(fch->act, PLR_SHROUD)) {
          act("$N drags you with $M.", fch, NULL, ch, TO_CHAR);
          SET_FLAG(fch->act, PLR_SHROUD);
          if (fch->pcdata->shroud_dragging > 0 && fch->pcdata->shroud_drag_depth == 2 && !IS_FLAG(fch->act, PLR_DEEPSHROUD)) {
            SET_FLAG(fch->act, PLR_DEEPSHROUD);
          }
          if (!IS_NPC(fch) && is_helpless(fch))
          fch->pcdata->nightmare_dragged = 1;

          if (!in_fight(fch) && check_fight(fch)) {
            if (next_fight_member(fch) != NULL) {
              fch->fight_fast = next_fight_member(fch)->fight_fast;
              fch->fight_speed = next_fight_member(fch)->fight_speed;
              fch->fight_current = next_fight_member(fch)->fight_current;
              fch->fight_next = next_fight_member(fch)->fight_next;
            }
            else
            fch->fight_fast = FALSE;
            fch->in_fight = TRUE;
            fch->attacking = 1;
            join_to_fight(fch);
            fch->hadturn = TRUE;
          }
        }
        else if (ch->lifting == fch && is_helpless(fch) && !IS_FLAG(fch->act, PLR_SHROUD)) {
          act("$N carries you with $M.", fch, NULL, ch, TO_CHAR);
          SET_FLAG(fch->act, PLR_SHROUD);
          if (fch->pcdata->shroud_dragging > 0 && fch->pcdata->shroud_drag_depth == 2 && !IS_FLAG(fch->act, PLR_DEEPSHROUD)) {
            SET_FLAG(fch->act, PLR_DEEPSHROUD);
          }
          if (!IS_NPC(fch) && is_helpless(fch))
          fch->pcdata->nightmare_dragged = 1;

          if (!in_fight(fch) && check_fight(fch)) {
            if (next_fight_member(fch) != NULL) {
              fch->fight_fast = next_fight_member(fch)->fight_fast;
              fch->fight_speed = next_fight_member(fch)->fight_speed;
              fch->fight_current = next_fight_member(fch)->fight_current;
              fch->fight_next = next_fight_member(fch)->fight_next;
            }
            else
            fch->fight_fast = FALSE;
            fch->in_fight = TRUE;
            fch->attacking = 1;
            join_to_fight(fch);
            fch->hadturn = TRUE;
          }
        }
      }
      do_function(ch, &do_look, "auto");
    }
  }

  int base_standing(CHAR_DATA *ch) {
    int start = 50;

    int cost = 0;
    if (ch->in_room != NULL) {
      if (in_prop(ch) != NULL) {
        cost = in_prop(ch)->price;
        int residents = UMAX(in_prop(ch)->logoffs, 1);
        cost /= residents;
        if (get_decor(ch->in_room) == 0 || safe_strlen(ch->in_room->description) < 80)
        cost = cost * 8 / 10;
        else
        cost = cost * (10 + get_decor(ch->in_room)) / 10;
        if (!IS_SET(ch->in_room->room_flags, ROOM_BEDROOM))
        cost /= 5;
        if (in_prop(ch)->realhouse == 0)
        cost /= 2;
      }
      else if(!college_student(ch, FALSE))
      cost = -4000;
    }
    int standpoints = 0;
    for (int i = 0; i < MAX_CONTACTS; i++) {
      if (ch->pcdata->contact_jobs[i] == CJOB_REPUTATION && safe_strlen(ch->pcdata->contact_names[i]) > 2
      && safe_strlen(ch->pcdata->contact_descs[i]) > 2)
      standpoints += skillpoint(get_skill(ch, contacts_table[i]));
    }
    start += standpoints * 10 * (10 + get_skill(ch, SKILL_SOCIALFOCUS)) / 10;
    start += prom_mod(ch) * 4;                      // up to -40
    start += status_bonus(ch) * 10;                 // up to +50
    start += get_tier(ch) * 10;                     // Up to +50
    start += prof_focus(ch) * 5;                    // Up to +35
    start += get_skill(ch, SKILL_SOCIALFOCUS) * 15; // Up to +80
    start += UMIN(ch->pcdata->social_praise / 100, 100);
    if (shopowner(ch))
    start += 10;

    if (get_skill(ch, SKILL_FAMOUS) > 0)
    start += 30;

    if(is_ffamily(ch))
    start += 10;

    start += UMIN(start * 2, UMIN(cost / 20, 100)); // Up to +100

    char buf[MSL];
    sprintf(buf, "LOGONINFLUENCE %s: Result: %d, Cost: %d, Room: %d, standpoints: %d, prom: %d, luxury car %d, tier %d, prof %d, social %d, praise %d", ch->name, start, cost / 20, ch->in_room->vnum, standpoints * 10, prom_mod(ch) * 4, status_bonus(ch) * 10, get_tier(ch) * 10, prof_focus(ch) * 5, get_skill(ch, SKILL_SOCIALFOCUS) * 15, ch->pcdata->social_praise / 100);
    log_string(buf);
    start = UMAX(50, start);

    return start;
  }

  void influence_update(CHAR_DATA *ch) {
    int base = base_standing(ch);

    if (ch->pcdata->base_standing > base) {
      ch->pcdata->base_standing = UMAX(base, ch->pcdata->base_standing * 9 / 10);
    }
    else if (ch->pcdata->base_standing < base) {
      ch->pcdata->base_standing = UMIN(base, ch->pcdata->base_standing * 11 / 10);
    }
    if (ch->pcdata->social_praise > 0)
    ch->pcdata->social_praise =
    UMIN(ch->pcdata->social_praise - 1, ch->pcdata->social_praise * 8 / 10);
    else if (ch->pcdata->social_praise < 0)
    ch->pcdata->social_praise =
    UMAX(ch->pcdata->social_praise + 1, ch->pcdata->social_praise * 8 / 10);

    if (ch->pcdata->social_behave > 0)
    ch->pcdata->social_behave =
    UMIN(ch->pcdata->social_behave - 1, ch->pcdata->social_behave * 9 / 10);
    else if (ch->pcdata->social_behave < 0)
    ch->pcdata->social_behave =
    UMAX(ch->pcdata->social_behave + 1, ch->pcdata->social_behave * 9 / 10);
  }

  bool social_abom(CHAR_DATA *ch) { return TRUE; }

  bool nonevil_abom(CHAR_DATA *ch) { return FALSE; }

  int average_solidity(ROOM_INDEX_DATA *room) {
    if (room == NULL)
    return 0;
    CHAR_DATA *victim;
    int total = 80;
    int count = 1;
    int max = 0;

    for (CharList::iterator it = room->people->begin(); it != room->people->end();
    ++it) {
      victim = *it;

      if (victim == NULL)
      continue;

      if (victim->in_room == NULL)
      continue;

      if (victim->in_room != room)
      continue;

      if (IS_NPC(victim))
      continue;

      if (is_gm(victim) || IS_FLAG(victim->act, PLR_GUEST))
      continue;
      if (solidity(victim) > max)
      max = solidity(victim);
      total += solidity(victim);
      count++;
    }
    total /= count;
    total = total + max;
    total /= 2;
    return total;
  }

  void give_karma(CHAR_DATA *ch, int amount, int type) {

    if (ch == NULL || ch->in_room == NULL)
    return;


    if (!other_players(ch) && type == KARMA_AMBIANT && !battleground(ch->in_room) && !has_mystery(ch))
    return;

    if (IS_FLAG(ch->comm, COMM_PRIVATE) && !IS_FLAG(ch->act, PLR_AFTERGLOW)) {
      if (is_gm(ch))
      return;

      ch->privatekarma += amount;
    }

    if(type == KARMA_DREAM && ch->pcdata->account->dream_karma >= 2500
    && ch->pcdata->account->dream_karma >= ch->pcdata->account->karmaearned/5)
    return;


    if (ch->pcdata->scheme_running != NULL) {
      if (ch->pcdata->account != NULL && !str_cmp(ch->pcdata->account->name, ch->pcdata->scheme_running->account)) {
        ch->pcdata->scheme_running->karma_battery_author += amount / 2;
        ch->pcdata->scheme_running->karma_battery_storyrunner += amount / 2;
        ch->pcdata->scheme_running->karma_battery_author =
        UMIN(ch->pcdata->scheme_running->karma_battery_author, 2000);
        ch->pcdata->scheme_running->karma_battery_storyrunner =
        UMIN(ch->pcdata->scheme_running->karma_battery_storyrunner, 2000);
      }
      else {
        ch->pcdata->scheme_running->karma_battery_author += amount;
        ch->pcdata->scheme_running->karma_battery_storyrunner += amount;
        ch->pcdata->scheme_running->karma_battery_author =
        UMIN(ch->pcdata->scheme_running->karma_battery_author, 2000);
        ch->pcdata->scheme_running->karma_battery_storyrunner =
        UMIN(ch->pcdata->scheme_running->karma_battery_storyrunner, 3000);
      }
      return;
    }
    int ramount = amount;

    if (ch->pcdata->account != NULL) {
      if (is_gm(ch)) {
        ch->pcdata->account->award_progress += amount;
        if (ch->pcdata->account->award_progress >= 10000) {
          ch->pcdata->account->awards++;
          ch->pcdata->account->award_progress -= 10000;
        }
      }


      int bonus = UMIN(ch->pcdata->account->award_karma, amount);
      ch->pcdata->account->karma += amount;
      ch->pcdata->account->karma += bonus;

      ramount += bonus;

      ch->pcdata->account->award_karma -= bonus;
      if (ch->karma > 0)
      ch->pcdata->account->karma += ch->karma;
      ch->karma = 0;

      if (ch->pcdata->account->karmabank > 0) {
        ch->pcdata->account->karma +=
        UMIN(ch->pcdata->account->karmabank, amount * 4);
        ch->pcdata->account->karmabank -=
        UMIN(ch->pcdata->account->karmabank, amount * 4);
      }
    }
    else if (!is_gm(ch))
    ch->karma += amount;

    PLOT_TYPE *plot = get_karma_plot(ch);

    if (is_gm(ch) && plot != NULL && (!in_haven(ch->in_room) || plot->type == PLOT_MYSTERY)) {
      plot->earnedkarma += amount;

      if (plot->karmacap == 0 && plot->earnedkarma >= 2000) {
        int cap = average_solidity(ch->in_room);
        cap *= 80;
        cap = UMIN(cap, 15000);
        if (plot->sponsored == 1)
        cap = cap * 3 / 2;
        if (plot->type == PLOT_QUEST)
        cap /= 2;
        if (plot->type == PLOT_MYSTERY)
        cap = 10000;
        if (plot->type == PLOT_OTHER)
        cap = 10000;

        plot->karmacap = cap;
      }
    }
    else if (is_gm(ch) && ch->pcdata->karma_battery > 0) {
      ch->pcdata->karma_battery -= amount;
    }
    if (type == KARMA_ENCOUNTER)
    ch->pcdata->account->encounter_karma += ramount;
    else if (type == KARMA_ADVENTURE)
    ch->pcdata->account->adventure_karma += ramount;
    else if (type == KARMA_MYSTERY)
    ch->pcdata->account->mystery_karma += ramount;
    else if (type == KARMA_AMBIANT)
    ch->pcdata->account->ambiant_karma += ramount;
    else if (type == KARMA_MONSTER)
    ch->pcdata->account->monster_karma += ramount;
    else if (type == KARMA_SCHEME)
    ch->pcdata->account->scheme_karma += ramount;
    else if( type == KARMA_DREAM)
    ch->pcdata->account->dream_karma += ramount;
    else
    ch->pcdata->account->misc_karma += ramount;

    int initial = ch->pcdata->account->karmaearned;
    ch->pcdata->account->karmaearned += ramount;

    if ((initial - (initial % 30000)) <
        (ch->pcdata->account->karmaearned -
          (ch->pcdata->account->karmaearned % 30000)))
    bookadd(ch, -1);

    if ((in_world(ch) != WORLD_EARTH && in_world(ch) != WORLD_ELSEWHERE) || battleground(ch->in_room)) {
      initial = ch->pcdata->account->offworld_karma;
      ch->pcdata->account->offworld_karma += amount;
      if ((initial - (initial % 5000)) <
          (ch->pcdata->account->offworld_karma -
            (ch->pcdata->account->offworld_karma % 5000)))
      bookadd(ch, WORLD_OTHER);
    }
  }

  void give_influence(CHAR_DATA *ch, int amount) {

    if (is_gm(ch))
    return;

    if (amount == 0)
    amount = 1;

    if (ch->pcdata->job_type_one == JOB_EMPLOYEE)
    return;

    amount = amount * 2 / 3;

    if (!IS_FLAG(ch->comm, COMM_CARDINAL))
    amount = amount * 4 / 5;
    if (ch->pcdata->availability == AVAIL_LOW)
    amount = amount / 2;

    if (event_occurance > 0 && event_occurance != ch->faction)
    amount = amount / 2;
    else if (event_occurance > 0 && event_occurance == ch->faction)
    amount = amount * 3 / 2;

    if (!IS_FLAG(ch->act, PLR_WHOINVIS) && amount > 0)
    amount = amount * 12 / 10;

    if (IS_FLAG(ch->act, PLR_SHROUD))
    amount = 0;

    if (get_tier(ch) <= 1)
    amount /= 5;

    if (ch->pcdata->influence > 15000 && get_tier(ch) < 3)
    amount /= 2;

    if (ch->pcdata->patrol_habits[PATROL_RECKLESSHABIT] > 0)
    amount = amount * 12 / 10;

    if (ch->faction == 0)
    ch->pcdata->influence += amount;
    else {
      ch->pcdata->influence += amount * 2 / 3;
      ch->pcdata->super_influence += amount * 2 / 3;
    }

    if (ch->hit >= max_hp(ch) && ch->pcdata->fatigue > 100 && ch->pcdata->fatigue_temp < 100) {
      ch->pcdata->fatigue -= 50;
      ch->pcdata->fatigue_temp += 5;
    }
  }

  char *const hypno_names[] = {
    "", "Lust", "Generosity", "Logic", "Guilt", "Anger", "PeerPressure", "Fear",
    "Gratitude", "Curiosity", "Jealousy", "Pity"
  };

  int hypno_resist_cost(CHAR_DATA *imprinter, CHAR_DATA *victim, int resistone, int resisttwo, int resistthree, int pressureone, int pressuretwo, int pressurethree, int type) {
    int base = 100;

    if (pressureone == resistone || pressuretwo == resistone || pressurethree == resistone)
    base += 300;

    if (pressureone == resisttwo || pressuretwo == resisttwo || pressurethree == resisttwo)
    base += 150;

    if (pressureone == resistthree || pressuretwo == resistthree || pressurethree == resistthree)
    base += 100;

    if (resistone == 0)
    base += 100;
    if (resisttwo == 0)
    base += 100;
    if (resistthree == 0)
    base += 100;

    if (imprinter != NULL && !IS_NPC(imprinter) && imprinter->in_room != NULL) {
      if (under_understanding(victim, imprinter))
      base += 500;

      base += get_tier(imprinter) * get_tier(imprinter) * 5;
      if (get_skill(imprinter, SKILL_SEDUCE) > 0 && (resistone == HYPNO_LUST || resisttwo == HYPNO_LUST
      || resistthree == HYPNO_LUST)) {
        base = base * 3 / 2;
      }
      if (resistone == HYPNO_LUST || resisttwo == HYPNO_LUST || resistthree == HYPNO_LUST) {
        base += get_attract(imprinter, victim) * 2;
        base -= get_attract(victim, imprinter) * 2;
      }
      if (get_skill(imprinter, SKILL_ENRAGE) > 0 && (resistone == HYPNO_ANGER || resisttwo == HYPNO_ANGER
      || resistthree == HYPNO_ANGER)) {
        base = base * 3 / 2;
      }
      if (is_sire(imprinter, victim))
      base = base * 15 / 10;

      if (event_dominance == 1 && !is_super(victim) && is_super(imprinter))
      base *= 2;
    }

    if (type == IMPRINT_BODYINSTRUCTION || type == IMPRINT_BODYCOMPULSION || type == IMPRINT_TRIGGEREDBODYINSTRUCTION
    || type == IMPRINT_TRIGGEREDBODYCOMPULSION)
    base = base * 3 / 2;

    base -= get_tier(victim) * get_tier(victim) * 5;

    if (is_angelborn(victim))
    base = base * 12 / 10;

    if (victim->modifier == MODIFIER_CHEMICAL)
    base = base * 12 / 10;

    if (IS_AFFECTED(victim, AFF_SUNG))
    base = base * 13 / 10;

    if (IS_AFFECTED(victim, AFF_VBLOOD))
    base *= 2;

    if (is_weakness(imprinter, victim))
    base *= 2;
    else if (has_weakness(imprinter, victim))
    base /= 2;

    if (mindbroken(victim))
    base *= 2;

    base = UMAX(0, base);
    return base;
  }

  int persuade_resist_cost(CHAR_DATA *imprinter, CHAR_DATA *victim, int resistone, int resisttwo, int resistthree, int pressureone, int pressuretwo, int pressurethree) {
    int base = 0;

    if (pressureone == resistone)
    base += 250;
    else if (pressureone == resistone || pressuretwo == resistone || pressurethree == resistone)
    base += 100;

    if (pressureone == resisttwo || pressuretwo == resisttwo || pressurethree == resisttwo)
    base += 50;

    if (pressureone == resistthree || pressuretwo == resistthree || pressurethree == resistthree)
    base += 50;

    if (resistone == 0)
    base += 50;
    if (resisttwo == 0)
    base += 50;
    if (resistthree == 0)
    base += 50;

    if (imprinter != NULL && !IS_NPC(imprinter) && imprinter->in_room != NULL) {
      base += get_tier(imprinter) * get_tier(imprinter) * 2;
      if (resistone == HYPNO_FEAR || resisttwo == HYPNO_FEAR || resistthree == HYPNO_FEAR) {
        base += get_tier(imprinter) * 25;
        base -= get_tier(victim) * 25;
      }
      if (resistone == HYPNO_LUST || resisttwo == HYPNO_LUST || resistthree == HYPNO_LUST) {
        base += get_attract(imprinter, victim) * 3;
        base -= get_attract(victim, imprinter) * 3;
      }
      if (resistone == HYPNO_PEERPRESSURE || resisttwo == HYPNO_PEERPRESSURE || resistthree == HYPNO_PEERPRESSURE) {
        base += social_standing(imprinter);
        base -= social_standing(victim);
      }
      if (resistone == HYPNO_JEALOUSY || resisttwo == HYPNO_JEALOUSY || resistthree == HYPNO_JEALOUSY) {
        if (victim->pcdata->habit[HABIT_SELFESTEEM] == 3)
        base += 100;
        else if (victim->pcdata->habit[HABIT_SELFESTEEM] == 1)
        base += 50;
        else if (victim->pcdata->habit[HABIT_SELFESTEEM] == 2)
        base -= 50;
        else if (victim->pcdata->habit[HABIT_SELFESTEEM] == 4)
        base -= 50;
      }

      if (get_skill(imprinter, SKILL_ENRAGE) > 0 && (resistone == HYPNO_ANGER || resisttwo == HYPNO_ANGER || resistthree == HYPNO_ANGER)) {
        base = base * 3 / 2;
      }
      if (get_skill(imprinter, SKILL_SEDUCE) > 0 && (resistone == HYPNO_LUST || resisttwo == HYPNO_LUST || resistthree == HYPNO_LUST)) {
        base = base * 3 / 2;
      }
      if (is_sire(imprinter, victim))
      base = base * 15 / 10;

      if (event_dominance == 1 && !is_super(victim) && is_super(imprinter))
      base *= 2;
    }

    base -= get_tier(victim) * get_tier(victim) * 3;
    if (IS_AFFECTED(victim, AFF_VBLOOD))
    base = base * 3 / 2;

    if (victim->modifier == MODIFIER_CHEMICAL)
    base = base * 14 / 10;

    if (is_angelborn(victim))
    base = base * 2;

    base += get_drunk(victim) * 2;

    if (is_weakness(imprinter, victim))
    base *= 2;
    else if (has_weakness(imprinter, victim))
    base /= 2;

    if (mindbroken(victim))
    base *= 2;

    base = UMAX(0, base);
    return base;
  }

  _DOFUN(do_imprint) {
    if (ch->pcdata->ci_editing == 1) {
      string_append(ch, &ch->pcdata->ci_imprint);
      return;
    }
    char arg1[MSL];
    argument = one_argument_nouncap(argument, arg1);
    if (!str_cmp(arg1, "accept")) {
      for (int i = 0; i < 25; i++) {
        if (ch->pcdata->imprint_type[i] != 0 && ch->pcdata->imprint_pending[i] < 0) {
          ch->pcdata->imprint_pending[i] = 0;
          ch->pcdata->imprint_resist_cost = 0;
          if (ch->pcdata->imprinter != NULL && ch->pcdata->imprinter->in_room != NULL) {
            send_to_char("You feel the imprint take hold.\n\r", ch->pcdata->imprinter);
          }
          ch->pcdata->imprinter = NULL;
          if (ch->pcdata->imprint_type[i] == IMPRINT_TRIGGEREDINSTRUCTION || ch->pcdata->imprint_type[i] == IMPRINT_TRIGGEREDCOMPULSION || ch->pcdata->imprint_type[i] == IMPRINT_TRIGGEREDBODYINSTRUCTION || ch->pcdata->imprint_type[i] == IMPRINT_TRIGGEREDBODYCOMPULSION)
          send_to_char("The imprint sinks deep down into your subconcious, waiting to be activated.\n\r", ch);
          else
          send_to_char("The imprint takes hold, to get rid of it you will have to satiate this desire by roleplaying it out and then typing satiate (instruction)\n\r", ch);
          return;
        }
      }
      return;
    }
    if (!str_cmp(arg1, "resist")) {
      if (ch->pcdata->imprint_resist_cost > 0) {
        printf_to_char(ch, "Your subconcious successfully rejects the instruction, although it costs you %01f life force to do so.\n\r", (double)(ch->pcdata->imprint_resist_cost) / 100);
        take_lifeforce(ch, ch->pcdata->imprint_resist_cost, "Resist imprint.");
        if (ch->pcdata->imprinter != NULL && ch->pcdata->imprinter->in_room != NULL) {
          use_lifeforce(ch->pcdata->imprinter, ch->pcdata->imprint_resist_cost / 2, "target resisted imprint.");
          send_to_char("A pain pulses through your head as the imprint fails to take and some of the energy backlashes against you.\n\r", ch->pcdata->imprinter);
        }
        ch->pcdata->trance = -180;
        ch->pcdata->imprinter = NULL;
        for (int i = 0; i < 25; i++) {
          if (ch->pcdata->imprint_type[i] != 0 && ch->pcdata->imprint_pending[i] < 0) {
            ch->pcdata->imprint_type[i] = 0;
          }
        }
        ch->pcdata->imprint_resist_cost = 0;
        return;
      }
      char arg2[MSL], arg3[MSL], arg4[MSL];
      argument = one_argument_nouncap(argument, arg2);
      argument = one_argument_nouncap(argument, arg3);
      argument = one_argument_nouncap(argument, arg4);
      int pone = -1, ptwo = -1, pthree = -1;
      for (int i = 1; i <= HYPNO_PITY; i++) {
        if (!str_cmp(arg2, hypno_names[i]))
        pone = i;
        if (!str_cmp(arg3, hypno_names[i]))
        ptwo = i;
        if (!str_cmp(arg4, hypno_names[i]))
        pthree = i;
      }
      if (pone == -1 || ptwo == -1 || pthree == -1) {
        send_to_char("Syntax: Imprint resist (pressure one) (pressure two) (pressure three)\n\rPossible pressures:", ch);
        for (int i = 1; i <= HYPNO_PITY; i++)
        printf_to_char(ch, ", %s", hypno_names[i]);
        send_to_char(".\n\r", ch);
        return;
      }
      for (int i = 0; i < 25; i++) {
        if (ch->pcdata->imprint_type[i] != 0 && ch->pcdata->imprint_pending[i] < 0) {
          if (pone == ch->pcdata->imprint_pressure_one[i] && (ptwo == ch->pcdata->imprint_pressure_two[i]
          || ptwo == ch->pcdata->imprint_pressure_three[i]) && (pthree == ch->pcdata->imprint_pressure_three[i]
          || pthree == ch->pcdata->imprint_pressure_two[i])) {
            if (ch->pcdata->imprint_type[i] == IMPRINT_COMPULSION) {
              ch->pcdata->imprint_pending[i] = 0;
              ch->pcdata->imprint_resist_cost = 0;
              if (ch->pcdata->imprinter != NULL && ch->pcdata->imprinter->in_room != NULL) {
                send_to_char("You feel the imprint take hold perfectly.\n\r", ch->pcdata->imprinter);
              }
              ch->pcdata->imprinter = NULL;
              send_to_char("The imprint slips straight past your defenses and takes hold.\n\r", ch);
              ch->pcdata->imprint_type[i] = IMPRINT_LOCKEDCOMPULSION;
              return;
            }
            if (ch->pcdata->imprint_type[i] == IMPRINT_BODYCOMPULSION) {
              ch->pcdata->imprint_pending[i] = 0;
              ch->pcdata->imprint_resist_cost = 0;
              if (ch->pcdata->imprinter != NULL && ch->pcdata->imprinter->in_room != NULL) {
                send_to_char("You feel the imprint take hold perfectly.\n\r", ch->pcdata->imprinter);
              }
              ch->pcdata->imprinter = NULL;
              send_to_char("The imprint slips straight past your defenses and takes hold.\n\r", ch);
              ch->pcdata->imprint_type[i] = IMPRINT_LOCKEDBODYCOMPULSION;
              return;
            }
          }
          int cost;
          if (ch->pcdata->imprint_type[i] == IMPRINT_PERSUADE)
          cost =
          persuade_resist_cost(ch->pcdata->imprinter, ch, pone, ptwo, pthree, ch->pcdata->imprint_pressure_one[i], ch->pcdata->imprint_pressure_two[i], ch->pcdata->imprint_pressure_three[i]);
          else
          cost = hypno_resist_cost(ch->pcdata->imprinter, ch, pone, ptwo, pthree, ch->pcdata->imprint_pressure_one[i], ch->pcdata->imprint_pressure_two[i], ch->pcdata->imprint_pressure_three[i], ch->pcdata->imprint_type[i]);
          if (cost <= 0) {
            printf_to_char(
            ch, "Your subconcious successfully rejects the instruction.\n\r");
            if (ch->pcdata->imprinter != NULL && ch->pcdata->imprinter->in_room != NULL) {
              if (ch->pcdata->imprint_type[i] == IMPRINT_PERSUADE)
              send_to_char("The supernatural persuasion doesn't take hold.\n\r", ch->pcdata->imprinter);
              else {
                use_lifeforce(ch->pcdata->imprinter, 100, "Target resisted persuasion.");
                send_to_char("A pain pulses through your head as the imprint fails to take and some of the energy backlashes against you.\n\r", ch->pcdata->imprinter);
              }
            }

            ch->pcdata->trance = -60;
            ch->pcdata->imprinter = NULL;
            ch->pcdata->imprint_type[i] = 0;
            ch->pcdata->imprint_resist_cost = 0;
            return;
          }
          printf_to_char(
          ch, "It would cost %01f life force to resist that imprint, type imprint resist to go through with it, or imprint accept to change your mind and accept the instruction.\n\r", (double)(cost) / 100);
          ch->pcdata->imprint_resist_cost = cost;
          return;
        }
      }
      return;
    }
    show_imprints(ch);
    for (int i = 0; i < 25; i++) {
      if (safe_strlen(ch->pcdata->memories[i]) > 2)
      printf_to_char(ch, "You have a vivid recollection of %s.\n\r", ch->pcdata->memories[i]);
      if (safe_strlen(ch->pcdata->repressions[i]) > 2)
      printf_to_char(ch, "You cannot remember %s.\n\r", ch->pcdata->repressions[i]);
    }

    if (safe_strlen(ch->pcdata->enthralled) > 2)
    printf_to_char(ch, "You have to obey your master.\n\r");
    if (safe_strlen(ch->pcdata->enraptured) > 2)
    printf_to_char(ch, "You have to make your adored happy.\n\r");

    if (IS_FLAG(ch->comm, COMM_CLEANSED))
    send_to_char("You've had a happy life, with no memories of bad events or dark desires.\n\r", ch);
    if (IS_FLAG(ch->comm, COMM_FORCEDPACIFIST))
    send_to_char("You don't commit violence against others.\n\r", ch);
    if (safe_strlen(ch->pcdata->brainwash_loyalty) > 2)
    printf_to_char(ch, "You are completely loyal to %s.\n\r", ch->pcdata->brainwash_loyalty);
    if (safe_strlen(ch->pcdata->brainwash_reidentity) > 2) {
      printf_to_char(ch, "You believe you are %s.\n\r", ch->pcdata->brainwash_reidentity);
    }
    if (IS_AFFECTED(ch, AFF_TRIGGERED))
    printf_to_char(
    ch, "You are currently entirely without morality, remorse or compassion, and are indifferent to the health and happiness of others. Feelings like love and affection are shadows of what they used to be, the only enjoyment others can provide is as targets for cruelty or manipulation.\n\r");
    if (ch->pcdata->dream_identity_timer > 0 && safe_strlen(ch->pcdata->identity_world) > 1) {
      if (safe_strlen(ch->pcdata->dream_identity) > 1) {
        printf_to_char(ch, "You believe you are %s from the world of %s.\n\r", ch->pcdata->dream_identity, ch->pcdata->identity_world);
      }
      else if (safe_strlen(dream_detail(ch, ch->pcdata->identity_world, DREAM_DETAIL_NAME)) > 1) {
        printf_to_char(
        ch, "You believe you are %s from the world of %s.\n\r", dream_detail(ch, ch->pcdata->identity_world, DREAM_DETAIL_NAME), ch->pcdata->identity_world);
      }
    }
    if (ch->pcdata->deluded_duration > current_time)
    printf_to_char(ch, "You are suffering cognitive dissonance because of your belief that, %s\n\r", ch->pcdata->deluded_reason);
  
    return;
  }

  void make_flower(CHAR_DATA *ch, int number) {
    OBJ_DATA *obj;

    switch (number) {
    case 1:
      obj = create_object(get_obj_index(70), 0);
      free_string(obj->short_descr);
      free_string(obj->description);
      free_string(obj->name);

      if (number_percent() % 3 == 0) {
        obj->short_descr = str_dup("bouquet of red roses");
        obj->description = str_dup("A natural bouquet of red roses");
        obj->name = str_dup("bouquet red roses");
      }
      else if (number_percent() % 2 == 0) {
        obj->short_descr = str_dup("bouquet of pink roses");
        obj->description = str_dup("A natural bouquet of pink roses");
        obj->name = str_dup("bouquet pink roses");
      }
      else {
        obj->short_descr = str_dup("bouquet of white roses");
        obj->description = str_dup("A natural bouquet of white roses");
        obj->name = str_dup("bouquet white roses");
      }
      obj_to_room(obj, ch->in_room);
      break;
    case 2:
      obj = create_object(get_obj_index(70), 0);
      free_string(obj->short_descr);
      free_string(obj->description);
      free_string(obj->name);

      if (number_percent() % 3 == 0) {
        obj->short_descr = str_dup("bouquet of red orchids");
        obj->description = str_dup("A natural bouquet of red orchids");
        obj->name = str_dup("bouquet red orchids");
      }
      else if (number_percent() % 2 == 0) {
        obj->short_descr = str_dup("bouquet of pink orchids");
        obj->description = str_dup("A natural bouquet of pink orchids");
        obj->name = str_dup("bouquet pink orchids");
      }
      else {
        obj->short_descr = str_dup("bouquet of white orchids");
        obj->description = str_dup("A natural bouquet of white orchids");
        obj->name = str_dup("bouquet white orchids");
      }
      obj_to_room(obj, ch->in_room);
      break;
    case 3:
      obj = create_object(get_obj_index(70), 0);
      free_string(obj->short_descr);
      free_string(obj->description);
      free_string(obj->name);

      obj->short_descr = str_dup("bouquet of white gardenias");
      obj->description = str_dup("A natural bouquet of white gardenias");
      obj->name = str_dup("bouquet white gardenias");

      obj_to_room(obj, ch->in_room);
      break;
    case 4:
      obj = create_object(get_obj_index(70), 0);
      free_string(obj->short_descr);
      free_string(obj->description);
      free_string(obj->name);

      if (number_percent() % 3 == 0) {
        obj->short_descr = str_dup("bouquet of white lilies");
        obj->description = str_dup("A natural bouquet of white lilies");
        obj->name = str_dup("bouquet white lilies");
      }
      else if (number_percent() % 2 == 0) {
        obj->short_descr = str_dup("bouquet of pink lilies");
        obj->description = str_dup("A natural bouquet of pink lilies");
        obj->name = str_dup("bouquet pink orchids");
      }
      else {
        obj->short_descr = str_dup("bouquet of champagne lilies");
        obj->description = str_dup("A natural bouquet of champagne lilies");
        obj->name = str_dup("bouquet champagne lilies");
      }
      obj_to_room(obj, ch->in_room);
      break;
    case 5:
      obj = create_object(get_obj_index(70), 0);
      free_string(obj->short_descr);
      free_string(obj->description);
      free_string(obj->name);

      if (number_percent() % 3 == 0) {
        obj->short_descr = str_dup("bouquet of red carnations");
        obj->description = str_dup("A natural bouquet of red carnations");
        obj->name = str_dup("bouquet red carnations");
      }
      else if (number_percent() % 2 == 0) {
        obj->short_descr = str_dup("bouquet of pink carnations");
        obj->description = str_dup("A natural bouquet of pink carnations");
        obj->name = str_dup("bouquet pink carnations");
      }
      else {
        obj->short_descr = str_dup("bouquet of yellow carnations");
        obj->description = str_dup("A natural bouquet of yellow carnations");
        obj->name = str_dup("bouquet yellow carnations");
      }
      obj_to_room(obj, ch->in_room);
      break;
    }
  }
 
  _DOFUN(do_enrage) {
    if (IS_FLAG(ch->comm, COMM_RACIAL)) {
      send_to_char("You've done that too recently.\n\r", ch);
      return;
    }
    if (!is_super(ch) || is_neutralized(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    else if (get_skill(ch, SKILL_RAGEFUELED) > 0) {
      AFFECT_DATA af;
      af.where = TO_AFFECTS;
      af.type = 0;
      af.level = 10;
      af.duration = 750;
      af.location = APPLY_NONE;
      af.modifier = 0;
      af.caster = NULL;
      af.weave = FALSE;
      af.bitvector = AFF_BERSERK;
      affect_to_char(ch, &af);

      SET_FLAG(ch->comm, COMM_RACIAL);
      send_to_char("Done.\n\r", ch);

    }
    else {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
  }

  _DOFUN(do_nightmare) {
    char arg1[MSL];
    CHAR_DATA *victim;
    if (!is_super(ch) || is_neutralized(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (get_skill(ch, SKILL_NIGHTMARE) <= 0) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (IS_FLAG(ch->comm, COMM_RACIAL)) {
      send_to_char("You've done that too recently.\n\r", ch);
      return;
    }

    argument = one_argument_nouncap(argument, arg1);

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (IS_FLAG(victim->act, PLR_DEAD)) {
      send_to_char("The dead have no need for dreams./n/r", ch);
      return;
    }

    // ghostie check and limit for nightmare -Discordance
    if (is_ghost(ch)) {
      if (is_manifesting(ch)) {
        if (deplete_ghostpool(ch, GHOST_MANIFESTATION) == FALSE) {
          send_to_char("You can't muster the strength to project your will any more today.\n\r", ch);
          return;
        }
      }
      else {
        send_to_char("You must be prepared to manifest this power.\n\r", ch);
        return;
      }
    }

    string_append(ch, &victim->pcdata->nightmare);
    SET_FLAG(ch->comm, COMM_RACIAL);
    send_to_char("Done, now write their nightmare\n\r", ch);
  }

  _DOFUN(do_wail) {
    if (!is_super(ch) || is_neutralized(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (get_skill(ch, SKILL_WAILING) <= 0) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (IS_FLAG(ch->comm, COMM_RACIAL)) {
      send_to_char("You've done that too recently.\n\r", ch);
      return;
    }

    // ghostie check and limit for wail -Discordance
    if (is_ghost(ch)) {
      if (is_manifesting(ch)) {
        if (deplete_ghostpool(ch, GHOST_MANIFESTATION) == FALSE) {
          send_to_char("You can't muster the strength to project your voice any more today.\n\r", ch);
          return;
        }
      }
      else {
        send_to_char("You must be prepared to manifest this power.\n\r", ch);
        return;
      }
    }

    CHAR_DATA *victim;

    for (CharList::iterator it = ch->in_room->people->begin();
    it != ch->in_room->people->end(); ++it) {
      victim = *it;

      if (victim == NULL)
      continue;

      if (victim->in_room == NULL)
      continue;

      if (victim->in_room != ch->in_room)
      continue;

      if (victim == ch)
      continue;

      if (is_ghost(victim))
      continue;

      AFFECT_DATA af;
      af.where = TO_AFFECTS;
      af.type = 0;
      af.level = 10;
      af.duration = 150;
      af.location = APPLY_NONE;
      af.modifier = 0;
      af.caster = NULL;
      af.weave = FALSE;
      af.bitvector = AFF_DEAF;
      affect_to_char(victim, &af);
    }
    SET_FLAG(ch->comm, COMM_RACIAL);
    act("You let out an unearthly scream.", ch, NULL, NULL, TO_CHAR);
    act("$n lets out an unearthly scream.", ch, NULL, NULL, TO_ROOM);
  }

  _DOFUN(do_storm) {
    if (get_skill(ch, SKILL_STORMCALLING) <= 0) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (IS_FLAG(ch->comm, COMM_RACIAL)) {
      send_to_char("You've done that too recently.\n\r", ch);
      return;
    }
    if (!is_super(ch) || is_neutralized(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    // ghostie check and limit for storm -Discordance
    if (is_ghost(ch)) {
      if (is_manifesting(ch)) {
        if (deplete_ghostpool(ch, GHOST_MANIFESTATION) == FALSE) {
          send_to_char("You can't muster the strength to manifest your will any more today.\n\r", ch);
          return;
        }
      }
      else {
        send_to_char("You must be prepared to manifest this power.\n\r", ch);
        return;
      }
    }

    if (in_haven(ch->in_room)) {
      if (temperature(ch->in_room) < 35 && temperature(ch->in_room) > 25)
      snowing = 1;
      else if (temperature(ch->in_room) < 35)
      hailing = 1;
      else
      raining = 1;

      time_info.local_density_total = 100;
      time_info.local_cover_total = 100;
      SET_FLAG(ch->comm, COMM_RACIAL);
      send_to_char("You conjure a storm.\n\r", ch);
    }
    else {
      if (temperature(ch->in_room) < 35 && temperature(ch->in_room) > 25)
      ch->in_room->snowing = 1;
      else if (temperature(ch->in_room) < 35)
      ch->in_room->hailing = 1;
      else
      ch->in_room->raining = 1;

      ch->in_room->cloud_cover = 100;
      ch->in_room->cloud_density = 100;
      SET_FLAG(ch->comm, COMM_RACIAL);
      send_to_char("You conjure a storm.\n\r", ch);
    }
  }

  _DOFUN(do_deathtouch) {
    CHAR_DATA *victim;
    char arg1[MSL];
    if (IS_FLAG(ch->comm, COMM_RACIAL)) {
      send_to_char("You've done that too recently.\n\r", ch);
      return;
    }
    if (get_skill(ch, SKILL_DEATHTOUCH) <= 0) {
      send_to_char("Only death demigods can do that.\n\r", ch);
      return;
    }
    if (!is_super(ch) || is_neutralized(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }

    argument = one_argument_nouncap(argument, arg1);

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (IS_FLAG(victim->act, PLR_DEAD)) {
      send_to_char("Death has already embraced them.", ch);
      return;
    }

    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (is_pinned(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (IS_NPC(victim)) {
      send_to_char("Not on NPCS.\n\r", ch);
      return;
    }
    if (is_safe(ch, victim)) {
      send_to_char("For some reason you can't bring yourself to do that.\n\r", ch);
      return;
    }

    if (victim->wounds > 0) {
      int val = 15000;
      if (get_skill(victim, SKILL_REGEN) >= 3)
      val *= 42;
      else if (get_skill(victim, SKILL_REGEN) >= 1)
      val *= 12;
      victim->heal_timer += val;
    }
    else
    take_lifeforce(victim, 200, "Death Touch");
    // ghostie check and limit for deathtouch -Discordance
    if (is_ghost(ch)) {
      if (is_manifesting(ch)) {
        if (deplete_ghostpool(ch, GHOST_MANIFESTATION) == FALSE) {
          send_to_char("You can't muster the strength to manifest your will any more today.\n\r", ch);
          return;
        }
      }
      else {
        send_to_char("You must be prepared to manifest this power.\n\r", ch);
        return;
      }
    }

    act("$n touches $N briefly.", ch, NULL, victim, TO_NOTVICT);
    act("You touch $N.", ch, NULL, victim, TO_CHAR);
    act("$n touches you briefly and you feel a sickly, cold chill run through you.", ch, NULL, victim, TO_VICT);
    SET_FLAG(ch->comm, COMM_RACIAL);
  }

  _DOFUN(do_bless) {
    char arg1[MSL];
    CHAR_DATA *victim;
    int i;

    if (IS_FLAG(ch->comm, COMM_RACIAL)) {
      send_to_char("You've done that too recently.\n\r", ch);
      return;
    }
    if (!is_super(ch) || is_neutralized(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (get_skill(ch, SKILL_BLOOMING) > 0) {
      if (!str_cmp(argument, "roses")) {
        for (i = 0; i < 4; i++)
        make_flower(ch, 1);
      }
      else if (!str_cmp(argument, "orchids")) {
        for (i = 0; i < 4; i++)
        make_flower(ch, 2);
      }
      else if (!str_cmp(argument, "gardenias")) {
        for (i = 0; i < 4; i++)
        make_flower(ch, 3);
      }
      else if (!str_cmp(argument, "lilies")) {
        for (i = 0; i < 4; i++)
        make_flower(ch, 4);
      }
      else if (!str_cmp(argument, "carnations")) {
        for (i = 0; i < 4; i++)
        make_flower(ch, 5);
      }
      else if (!str_cmp(argument, "random")) {
        for (i = 0; i < 7; i++)
        make_flower(ch, number_range(1, 5));
      }
      else {
        send_to_char("Bless roses/orchids/gardenias/lilies/carnations/random\n\r", ch);
        return;
      }

      // ghostie check and limit for bless -Discordance
      if (is_ghost(ch)) {
        if (is_manifesting(ch)) {
          if (deplete_ghostpool(ch, GHOST_MANIFESTATION) == FALSE) {
            send_to_char("You can't muster the strength to manifest your will any more today.\n\r", ch);
            return;
          }
        }
        else {
          send_to_char("You must be prepared to manifest this power.\n\r", ch);
          return;
        }
      }

      act("Natural bouquets of flowers spring up from natural surfaces around the area.", ch, NULL, NULL, TO_ROOM);
      act("Natural bouquets of flowers spring up from natural surfaces around the area.", ch, NULL, NULL, TO_CHAR);

      SET_FLAG(ch->comm, COMM_RACIAL);

      return;
    }
    argument = one_argument_nouncap(argument, arg1);

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }
    if (get_skill(ch, SKILL_SOLARBLESS) > 0) {

      AFFECT_DATA af;
      af.where = TO_AFFECTS;
      af.type = 0;
      af.level = 10;
      af.duration = 12 * 60 * 3;
      af.location = APPLY_NONE;
      af.modifier = 0;
      af.caster = NULL;
      af.weave = FALSE;
      af.bitvector = AFF_SUNBLESS;
      affect_to_char(victim, &af);

      SET_FLAG(ch->comm, COMM_RACIAL);
      send_to_char("Done.\n\r", ch);
    }
    if (get_skill(ch, SKILL_FERTILITY) > 0) {

      AFFECT_DATA af;
      af.where = TO_AFFECTS;
      af.type = 0;
      af.level = 10;
      if (ch != victim)
      af.duration = 12 * 60 * 5;
      else
      af.duration = 12 * 60;
      af.location = APPLY_NONE;
      af.modifier = 0;
      af.caster = NULL;
      af.weave = FALSE;
      af.bitvector = AFF_FERTILITY;
      affect_to_char(victim, &af);

      if (victim->pcdata->penis > 0) {
        victim->pcdata->sex_potency = 200;
      }
      SET_FLAG(ch->comm, COMM_RACIAL);
      send_to_char("Done.\n\r", ch);
    }
    else if (get_skill(ch, SKILL_LUNARBLESS) > 0) {

      AFFECT_DATA af;
      af.where = TO_AFFECTS;
      af.type = 0;
      af.level = 10;
      af.duration = 12 * 60 * 3;
      af.location = APPLY_NONE;
      af.modifier = 0;
      af.caster = NULL;
      af.weave = FALSE;
      af.bitvector = AFF_MOONBLESS;
      affect_to_char(victim, &af);

      SET_FLAG(ch->comm, COMM_RACIAL);
      send_to_char("Done.\n\r", ch);
    }
    else if (get_skill(ch, SKILL_OCEANAFFINITY) > 0) {

      AFFECT_DATA af;
      af.where = TO_AFFECTS;
      af.type = 0;
      af.level = 10;
      af.duration = 12 * 60 * 3;
      af.location = APPLY_NONE;
      af.modifier = 0;
      af.caster = NULL;
      af.weave = FALSE;
      af.bitvector = AFF_WATERBLESS;
      affect_to_char(victim, &af);

      SET_FLAG(ch->comm, COMM_RACIAL);
      send_to_char("Done.\n\r", ch);
    }
    else if (get_skill(ch, SKILL_WARBLESS) > 0) {

      AFFECT_DATA af;
      af.where = TO_AFFECTS;
      af.type = 0;
      af.level = 10;
      af.duration = 12 * 60 * 3;
      af.location = APPLY_NONE;
      af.modifier = 0;
      af.caster = NULL;
      af.weave = FALSE;
      af.bitvector = AFF_WARBLESS;
      affect_to_char(victim, &af);

      SET_FLAG(ch->comm, COMM_RACIAL);
      send_to_char("Done.\n\r", ch);
    }
    else if (get_skill(ch, SKILL_LUCKCHANGE) > 0) {

      AFFECT_DATA af;
      af.where = TO_AFFECTS;
      af.type = 0;
      af.level = 10;
      af.duration = 12 * 60 * 3;
      af.location = APPLY_NONE;
      af.modifier = 0;
      af.caster = NULL;
      af.weave = FALSE;
      af.bitvector = AFF_LUCKY;
      affect_to_char(victim, &af);

      SET_FLAG(ch->comm, COMM_RACIAL);
      send_to_char("Done.\n\r", ch);
    }
    else {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
  }

  _DOFUN(do_curse) {
    char arg1[MSL];
    CHAR_DATA *victim;
    argument = one_argument_nouncap(argument, arg1);
    if (ch->pcdata->ci_editing == 17) {
      ch->pcdata->ci_absorb = 1;
      int cnum = 0;
      if(!str_cmp(arg1, "gullibility"))
      cnum = CURSE_GULLIBLITY;
      else if(!str_cmp(arg1, "narcissism"))
      cnum = CURSE_NARCISSISM;
      else if(!str_cmp(arg1, "revelation"))
      cnum = CURSE_REVELATION;
      else if(!str_cmp(arg1, "weakness"))
      cnum = CURSE_WEAKNESS;
      else if(!str_cmp(arg1, "timid"))
      cnum = CURSE_TIMID;
      else if(!str_cmp(arg1, "puritanical"))
      cnum = CURSE_PURITANICAL;
      else if(!str_cmp(arg1, "dependency"))
      cnum = CURSE_DEPENDENCY;
      else if(!str_cmp(arg1, "phobia"))
      {
        if(strlen(argument) < 3)
        {
          send_to_char("Syntax: curse phobia (What the character will have a phobia of).\n\r", ch);
          return;
        }
        free_string(ch->pcdata->ci_message);
        ch->pcdata->ci_message = str_dup(argument);
        cnum = CURSE_PHOBIA;
      }
      else if(!str_cmp(arg1, "imprint"))
      {
        if(strlen(argument) < 3)
        {
          send_to_char("Syntax: curse imprint (What the character will be imprinted with).\n\r", ch);
          return;
        }
        free_string(ch->pcdata->ci_message);
        ch->pcdata->ci_message = str_dup(argument);
        cnum = CURSE_IMPRINT;
      }
      else {
        send_to_char("Syntax: curse (gullibility/narcissism/revelation/weakness/timid/puritanical/dependency/phobia/imprint)\n\r", ch);
        return;
      }
      ch->pcdata->ci_zips = cnum;
      send_to_char("Curse set.\n\r", ch);

      return;
    }

    if (IS_FLAG(ch->comm, COMM_RACIAL)) {
      send_to_char("You've done that too recently.\n\r", ch);
      return;
    }
    if (!is_super(ch) || is_neutralized(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (IS_FLAG(victim->act, PLR_DEAD)) {
      send_to_char("You curse the dead in vain.\n\r", ch);
      return;
    }
    if (get_skill(ch, SKILL_LUCKCHANGE) > 0) {
      // ghostie check and limit for curse -Discordance
      if (is_ghost(ch)) {
        if (is_manifesting(ch)) {
          if (deplete_ghostpool(ch, GHOST_MANIFESTATION) == FALSE) {
            send_to_char("You can't muster the strength to manifest your will any more today.\n\r", ch);
            return;
          }
        }
        else {
          send_to_char("You must be prepared to manifest this power.\n\r", ch);
          return;
        }
      }

      AFFECT_DATA af;
      af.where = TO_AFFECTS;
      af.type = 0;
      af.level = 10;
      af.duration = 750;
      af.location = APPLY_NONE;
      af.modifier = 0;
      af.caster = NULL;
      af.weave = FALSE;
      af.bitvector = AFF_UNLUCKY;
      affect_to_char(victim, &af);

      SET_FLAG(ch->comm, COMM_RACIAL);
      send_to_char("Done.\n\r", ch);
    }
    else {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
  }

  _DOFUN(do_boon) {
    char arg1[MSL];
    argument = one_argument_nouncap(argument, arg1);
    if (ch->pcdata->ci_editing == 17) {
      ch->pcdata->ci_absorb = 1;
      int cnum = 0;
      if(!str_cmp(arg1, "beauty"))
      cnum = BOON_BEAUTY;
      else if(!str_cmp(arg1, "strength"))
      cnum = BOON_STRENGTH;
      else if(!str_cmp(arg1, "lavish"))
      cnum = BOON_LAVISH;
      else if(!str_cmp(arg1, "gift"))
      {
        OBJ_DATA *obj;
        if ((obj = get_obj_carryhold(ch, argument, NULL)) == NULL) {
          send_to_char("You don't have that.\n\r", ch);
          return;
        }
        ch->pcdata->boon_gift = obj;
        cnum = BOON_GIFT;
      }
      else if(!str_cmp(arg1, "lover"))
      cnum = BOON_LOVER;
      else if(!str_cmp(arg1, "silvertongue"))
      cnum = BOON_SILVERTONGUE;
      else if(!str_cmp(arg1, "vitality"))
      cnum = BOON_VITALITY;
      else if(!str_cmp(arg1, "astral"))
      cnum = BOON_ASTRAL;
      else if(!str_cmp(arg1, "noworries"))
      cnum = BOON_NOWORRIES;
      else if(!str_cmp(arg1, "bliss"))
      cnum = BOON_BLISS;
      else if(!str_cmp(arg1, "renovate"))
      cnum = BOON_RENOVATE;

      else {
        send_to_char("Syntax: boon (beauty/strength/lavish/gift/lover/silvertongue/vitality/astral/noworries/bliss/renovate)\n\r", ch);
        return;
      }

      ch->pcdata->ci_disclevel = cnum;
      send_to_char("Boon set.\n\r", ch);

      return;
    }
  }
  _DOFUN(do_sing) {
    if (get_skill(ch, SKILL_SIRENSONG) <= 0) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (IS_FLAG(ch->comm, COMM_RACIAL)) {
      send_to_char("You've done that too recently.\n\r", ch);
      return;
    }
    if (!is_super(ch) || is_neutralized(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    // ghostie check and limit for sing -Discordance
    if (is_ghost(ch)) {
      if (is_manifesting(ch)) {
        if (deplete_ghostpool(ch, GHOST_MANIFESTATION) == FALSE) {
          send_to_char("You can't muster the strength to manifest your will any more today.\n\r", ch);
          return;
        }
      }
      else {
        send_to_char("You must be prepared to manifest this power.\n\r", ch);
        return;
      }
    }
    CHAR_DATA *victim;

    for (CharList::iterator it = ch->in_room->people->begin(); it != ch->in_room->people->end(); ++it) {
      victim = *it;

      if (victim == NULL)
      continue;

      if (victim->in_room == NULL)
      continue;

      if (victim->in_room != ch->in_room)
      continue;

      if (victim == ch)
      continue;

      if (is_ghost(ch) && !can_hear_ghost(ch, victim))
      continue;

      AFFECT_DATA af;
      af.where = TO_AFFECTS;
      af.type = 0;
      af.level = 10;
      af.duration = 150;
      af.location = APPLY_NONE;
      af.modifier = 0;
      af.caster = NULL;
      af.weave = FALSE;
      af.bitvector = AFF_SUNG;
      affect_to_char(victim, &af);
    }
    SET_FLAG(ch->comm, COMM_RACIAL);
    act("You sing a beautiful song.", ch, NULL, NULL, TO_CHAR);
    act("$n sings a beautiful but hard to remember song.", ch, NULL, NULL, TO_ROOM);
  }

  void gossip(char *message) {
    NEWS_TYPE *news;

    news = new_news();
    news->timer = 1500;
    free_string(news->message);
    news->message = str_dup(message);
    free_string(news->author);
    news->author = str_dup("Town Gossip");
    NewsVect.push_back(news);
  }

  char *infmodifier(int amount) {
    if (amount < 1000)
    return "somewhat ";
    else if (amount < 2000)
    return "";
    else if (amount < 3000)
    return "very ";
    else
    return "extremely ";
  }

#define PRAISE_CHARACTER 1
#define PRAISE_APPEARANCE 2
#define PRAISE_LOYALTY 3
#define DISS_CHARACTER 4
#define DISS_APPEARANCE 5
#define DISS_LOYALTY 6
#define DISS_SEXUAL 7

  int praise_calc(CHAR_DATA *ch, CHAR_DATA *victim, int amount) {
    int val = amount;
    int counter = 0;

    if (!str_cmp(ch->pcdata->last_praised[0], victim->name))
    counter += 5;
    if (!str_cmp(ch->pcdata->last_praised[1], victim->name))
    counter += 2;
    if (!str_cmp(ch->pcdata->last_praised[2], victim->name))
    counter += 1;

    int temp = 10 - counter;

    if (counter > 0)
    val = val * temp / 10;

    val = val * 3 / 2;
    return val;
  }

  bool worthy_praise(CHAR_DATA *ch, CHAR_DATA *victim) {
    bool worthy = TRUE;
    char buf[MSL];

    if (!str_cmp(ch->name, victim->name))
    return TRUE;

    if (!str_cmp(ch->pcdata->last_sexed[0], victim->name))
    worthy = FALSE;
    if (!str_cmp(ch->pcdata->last_sexed[1], victim->name))
    worthy = FALSE;
    if (!str_cmp(ch->pcdata->last_sexed[2], victim->name))
    worthy = FALSE;

    if (worthy == FALSE) {
      sprintf(buf, "PRAISDISS: %s praises %s, unworthy because sex partner.\n\r", ch->name, victim->name);
      log_string(buf);
    }

    if (!str_cmp(ch->pcdata->last_praised[0], victim->name))
    worthy = FALSE;
    if (!str_cmp(ch->pcdata->last_praised[1], victim->name))
    worthy = FALSE;

    if (worthy == FALSE) {
      sprintf(buf, "PRAISEDISSINFLUENCE: %s praises %s, unworthy because last praised.\n\r", ch->name, victim->name);
      log_string(buf);
    }

    return worthy;
  }
  bool worthy_diss(CHAR_DATA *ch, CHAR_DATA *victim) {
    bool worthy = TRUE;
    char buf[MSL];

    if (!str_cmp(ch->pcdata->last_dissed[0], victim->name))
    worthy = FALSE;

    if (!str_cmp(ch->pcdata->last_dissed[1], victim->name))
    worthy = FALSE;
    if (worthy == FALSE) {
      sprintf(
      buf, "PRAISEDISSINFLUENCE: %s disses %s, unworthy because last dissed.\n\r", ch->name, victim->name);
      log_string(buf);
    }

    return worthy;
  }

  int diss_calc(CHAR_DATA *ch, CHAR_DATA *victim, int amount) {
    int val = amount;
    int counter = 0;

    if (!str_cmp(ch->pcdata->last_dissed[0], victim->name))
    counter += 5;
    if (!str_cmp(ch->pcdata->last_dissed[1], victim->name))
    counter += 2;
    if (!str_cmp(ch->pcdata->last_dissed[2], victim->name))
    counter += 1;

    int temp = 10 - counter;

    if (counter > 0)
    val = val * temp / 10;

    val = val * 3 / 2;
    return val;
  }

  void auto_praise(char *name, char *type, int amount) {
    struct stat sb;
    char buf[MSL];
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    CHAR_DATA *victim;

    if (safe_strlen(name) < 2 || amount <= 0)
    return;

    d.original = NULL;
    if ((victim = get_char_world_pc(name)) != NULL) // Victim is online.
    online = TRUE;
    else {
      log_string("DESCRIPTOR:Auto Praise");

      if (!load_char_obj(&d, name)) {
        return;
      }

      sprintf(buf, "%s%s", PLAYER_DIR, capitalize(name));
      stat(buf, &sb);
      victim = d.character;
    }
    if (IS_NPC(victim)) {
      if (!online)
      free_char(victim);
      return;
    }

    if (!str_cmp(type, "character")) {
      victim->pcdata->influence += amount / 2;
      victim->pcdata->social_praise += amount;
    }

    if (!str_cmp(type, "appearance")) {
      victim->pcdata->attract_mod += amount / 50;
      victim->pcdata->attract[ATTRACT_PRAISE] += amount;
    }
    if (!str_cmp(type, "loyalty")) {
      give_respect_noecho(victim, amount, victim->faction);
      give_respect_noecho(victim, amount, victim->factiontwo);
    }
    save_char_obj(victim, FALSE, FALSE);
    if (!online)
    free_char(victim);
  }
  
  void auto_diss(char *name, char *type, int amount) {
    struct stat sb;
    char buf[MSL];
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    CHAR_DATA *victim;

    if (safe_strlen(name) < 2 || amount <= 0)
    return;

    d.original = NULL;
    if ((victim = get_char_world_pc(name)) != NULL) // Victim is online.
    online = TRUE;
    else {
      log_string("DESCRIPTOR: Auto diss");

      if (!load_char_obj(&d, name)) {
        return;
      }

      sprintf(buf, "%s%s", PLAYER_DIR, capitalize(name));
      stat(buf, &sb);
      victim = d.character;
    }
    if (IS_NPC(victim)) {
      if (!online)
      free_char(victim);
      return;
    }

    if (!str_cmp(type, "character")) {
      victim->pcdata->influence -= amount / 2;
      victim->pcdata->social_praise -= amount;
    }
    if (!str_cmp(type, "appearance")) {
      victim->pcdata->attract_mod -= amount / 50;
      victim->pcdata->attract[ATTRACT_PRAISE] -= amount;
    }
    if (!str_cmp(type, "loyalty")) {
      give_respect_noecho(victim, amount * -1, victim->faction);
      give_respect_noecho(victim, amount * -1, victim->factiontwo);
    }
    save_char_obj(victim, FALSE, FALSE);
    if (!online)
    free_char(victim);
  }
  
  void praise_echo(CHAR_DATA *ch, char *type, int amount) {
    if (safe_strlen(ch->pcdata->pledge) > 2) {
      auto_praise(ch->pcdata->pledge, type, amount / 2);
    }
    for (int i = 0; i < 10; i++) {
      if (ch->pcdata->relationship_type[i] == REL_CHILD) {
        auto_praise(ch->pcdata->relationship[i], type, amount / 3);
      }
    }
  }
  
  void diss_echo(CHAR_DATA *ch, char *type, int amount) {

    if (safe_strlen(ch->pcdata->pledge) > 2) {
      auto_diss(ch->pcdata->pledge, type, amount / 2);
    }
    for (int i = 0; i < 10; i++) {
      if (ch->pcdata->relationship_type[i] == REL_CHILD) {
        auto_diss(ch->pcdata->relationship[i], type, amount / 3);
      }
    }
  }

  void make_rumor_faction(char *argument, int faction) {
    if (faction == 0 || clan_lookup(faction) == NULL)
    return;

    FACTION_TYPE *fac = clan_lookup(faction);
    int i;
    for (i = 0; i < 20 && safe_strlen(fac->messages[i]) > 2; i++) {
    }
    if (i == 20)
    return;
    free_string(fac->messages[i]);
    fac->messages[i] = str_dup(argument);
    fac->message_timer[i] = 50;
  }

  bool sex_partner(CHAR_DATA *ch, CHAR_DATA *victim) {
    if (!str_cmp(ch->pcdata->last_sexed[0], victim->name))
    return TRUE;
    if (!str_cmp(ch->pcdata->last_sexed[1], victim->name))
    return TRUE;
    if (!str_cmp(ch->pcdata->last_sexed[2], victim->name))
    return TRUE;

    return FALSE;
  }

  bool in_your_face(CHAR_DATA *ch, CHAR_DATA *victim, int amount, int type) {
    if (IS_IMMORTAL(ch) || IS_IMMORTAL(victim))
    return FALSE;

    if (ch == victim)
    return FALSE;

    char buf[MSL];
    if (type == PRAISE_CHARACTER) {
      if (sex_partner(ch, victim)) {
        int chance = 10;
        if (amount == 10000)
        chance *= 2;
        if (!str_cmp(ch->pcdata->last_praised[0], victim->name))
        chance *= 2;
        if (!str_cmp(ch->pcdata->last_praised[1], victim->name))
        chance *= 2;
        if (!str_cmp(ch->pcdata->last_praised[2], victim->name))
        chance *= 2;

        if (chance > number_percent()) {
          sprintf(buf, "%s is trying to talk up %s again, they're probably sleeping together.", ch->name, victim->name);
          gossip(buf);
          return TRUE;
        }
      }
      else {
        int chance = 0;
        if (!str_cmp(ch->pcdata->last_praised[0], victim->name))
        chance += 10;
        if (!str_cmp(ch->pcdata->last_praised[1], victim->name))
        chance += 10;
        if (!str_cmp(ch->pcdata->last_praised[2], victim->name))
        chance += 10;

        if (amount == 10000)
        chance *= 2;

        if (chance > number_percent()) {
          sprintf(buf, "%s is trying to talk up %s again, beating a dead horse much?", ch->name, victim->name);
          gossip(buf);
          return TRUE;
        }
      }
    }
    if (type == PRAISE_APPEARANCE) {
      if (sex_partner(ch, victim)) {
        int chance = 10;
        if (amount == 10000)
        chance *= 2;
        if (!str_cmp(ch->pcdata->last_praised[0], victim->name))
        chance *= 2;
        if (!str_cmp(ch->pcdata->last_praised[1], victim->name))
        chance *= 2;
        if (!str_cmp(ch->pcdata->last_praised[2], victim->name))
        chance *= 2;

        if (chance > number_percent()) {
          if (get_attract(victim, NULL) < 60)
          sprintf(buf, "%s is trying to tell people how hot %s is, deluded much? They must be sleeping together.", ch->name, victim->name);
          else
          sprintf(buf, "%s is trying to tell people how hot %s is again. I bet they're sleeping together.", ch->name, victim->name);
          gossip(buf);
          return TRUE;
        }
      }
      else {
        int chance = 0;
        if (!str_cmp(ch->pcdata->last_praised[0], victim->name))
        chance += 10;
        if (!str_cmp(ch->pcdata->last_praised[1], victim->name))
        chance += 10;
        if (!str_cmp(ch->pcdata->last_praised[2], victim->name))
        chance += 10;

        if (amount == 10000)
        chance *= 2;

        if (chance > number_percent()) {
          if (get_attract(victim, NULL) < 60)
          sprintf(buf, "%s is trying to tell people how hot %s is, deluded much?", ch->name, victim->name);
          else
          sprintf(buf, "%s is trying to tell people how hot %s is again, get over it already.", ch->name, victim->name);
          gossip(buf);
          return TRUE;
        }
      }
    }
    if (type == PRAISE_LOYALTY) {
      if (sex_partner(ch, victim)) {
        int chance = 10;
        if (amount == 10000)
        chance *= 2;
        if (!str_cmp(ch->pcdata->last_praised[0], victim->name))
        chance *= 2;
        if (!str_cmp(ch->pcdata->last_praised[1], victim->name))
        chance *= 2;
        if (!str_cmp(ch->pcdata->last_praised[2], victim->name))
        chance *= 2;

        if (chance > number_percent()) {
          sprintf(buf, "I heard %s put in another good report for %s, I guess you can sleep your way to the top.", ch->name, victim->name);
          make_rumor_faction(buf, victim->faction);
          return TRUE;
        }
      }
      else {
        int chance = 0;
        if (!str_cmp(ch->pcdata->last_praised[0], victim->name))
        chance += 10;
        if (!str_cmp(ch->pcdata->last_praised[1], victim->name))
        chance += 10;
        if (!str_cmp(ch->pcdata->last_praised[2], victim->name))
        chance += 10;

        if (amount == 10000)
        chance *= 2;

        if (chance > number_percent()) {
          sprintf(buf, "%s supposedly put in another good report for %s, I wonder what that's all about?", ch->name, victim->name);
          make_rumor_faction(buf, victim->faction);
          return TRUE;
        }
      }
    }
    if (type == DISS_CHARACTER) {
      int chance = 0;
      if (!str_cmp(ch->pcdata->last_dissed[0], victim->name))
      chance += 10;
      if (!str_cmp(ch->pcdata->last_dissed[1], victim->name))
      chance += 10;
      if (!str_cmp(ch->pcdata->last_dissed[2], victim->name))
      chance += 10;

      if (amount == 10000)
      chance *= 2;

      if (chance > number_percent()) {
        sprintf(buf, "%s is talking shit about %s again, surprised they haven't got their ass beat for that yet.", ch->name, victim->name);
        gossip(buf);
        return TRUE;
      }
    }
    if (type == DISS_APPEARANCE) {
      int chance = 0;
      if (!str_cmp(ch->pcdata->last_dissed[0], victim->name))
      chance += 10;
      if (!str_cmp(ch->pcdata->last_dissed[1], victim->name))
      chance += 10;
      if (!str_cmp(ch->pcdata->last_dissed[2], victim->name))
      chance += 10;

      if (amount == 10000)
      chance *= 2;

      if (get_attract(ch, NULL) < get_attract(victim, NULL))
      chance *= 3;

      if (chance > number_percent()) {
        if (get_attract(ch, NULL) < get_attract(victim, NULL))
        sprintf(buf, "%s has been trying to diss %s's appearance again. We get it, they're hotter than you, you're jealous, let it go.", ch->name, victim->name);
        else
        sprintf(buf, "%s has been trying to diss %s's appearance again, this isn't a competition you know.", ch->name, victim->name);
        gossip(buf);
        return TRUE;
      }
    }
    if (type == DISS_SEXUAL) {
      int chance = 0;
      if (!str_cmp(ch->pcdata->last_dissed[0], victim->name))
      chance += 10;
      if (!str_cmp(ch->pcdata->last_dissed[1], victim->name))
      chance += 10;
      if (!str_cmp(ch->pcdata->last_dissed[2], victim->name))
      chance += 10;

      if (amount == 10000)
      chance *= 2;

      if (chance > number_percent()) {
        if (ch->pcdata->attract[ATTRACT_PROM] > ch->pcdata->attract[ATTRACT_PROM])
        sprintf(buf, "%s has been trying to diss %s sexually again. I guess they figure it takes one to know one.", ch->name, victim->name);
        else
        sprintf(buf, "%s has been trying to diss %s sexually again, isn't this supposed to be the 21st century already?", ch->name, victim->name);
        gossip(buf);
        return TRUE;
      }
    }
    if (type == DISS_LOYALTY) {
      int chance = 0;
      if (!str_cmp(ch->pcdata->last_dissed[0], victim->name))
      chance += 10;
      if (!str_cmp(ch->pcdata->last_dissed[1], victim->name))
      chance += 10;
      if (!str_cmp(ch->pcdata->last_dissed[2], victim->name))
      chance += 10;

      if (amount == 10000)
      chance *= 2;

      if (chance > number_percent()) {
        sprintf(buf, "I heard %s filed another bad report on %s, there must be something going on there.", ch->name, victim->name);
        make_rumor_faction(buf, victim->faction);
        return TRUE;
      }
    }

    return FALSE;
  }

  void praise_rumor(CHAR_DATA *ch, CHAR_DATA *victim, char *argument, int type) {
    if (IS_IMMORTAL(ch) || IS_IMMORTAL(victim))
    return;
    char buf[MSL];

    if (ch == victim)
    return;

    if (type == PRAISE_CHARACTER) {
      sprintf(buf, "People have been speaking highly of %s's character recently, saying %s", victim->name, argument);
      gossip(buf);
      return;
    }
    else if (type == PRAISE_APPEARANCE) {
      sprintf(buf, "People have been speaking highly of %s's appearance recently, saying %s", victim->name, argument);
      gossip(buf);
      return;
    }
    else if (type == PRAISE_LOYALTY) {
      sprintf(
      buf, "People have been speaking highly of %s's loyalty recently, saying %s", victim->name, argument);
      make_rumor_faction(buf, victim->faction);
      return;
    }
    else if (type == DISS_CHARACTER) {
      sprintf(buf, "People have been speaking poorly of %s's character recently, saying %s", victim->name, argument);
      gossip(buf);
      return;
    }
    else if (type == DISS_APPEARANCE) {
      sprintf(buf, "People have been speaking poorly of %s's appearance recently, saying %s", victim->name, argument);
      gossip(buf);
      return;
    }
    else if (type == DISS_LOYALTY) {
      sprintf(
      buf, "People have been speaking poorly of %s's loyalty recently, saying %s", victim->name, argument);
      make_rumor_faction(buf, victim->faction);
      return;
    }
    else if (type == DISS_SEXUAL) {
      sprintf(
      buf, "People have been speaking poorly of %s sexually recently, saying %s", victim->name, argument);
      gossip(buf);
      return;
    }
  }

  _DOFUN(do_praise) {
    char arg1[MSL];
    char arg2[MSL];
    char arg3[MSL];
    struct stat sb;
    char buf[MSL];
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    CHAR_DATA *victim;

    argument = one_argument_nouncap(argument, arg1);
    argument = one_argument_nouncap(argument, arg2);
    argument = one_argument_nouncap(argument, arg3);

    ch->pcdata->influence_balance = UMIN(ch->pcdata->influence_balance, 15);
    ch->pcdata->influence_balance = UMAX(ch->pcdata->influence_balance, -15);

    if (IS_AFFECTED(ch, AFF_OUTCAST)) {
      send_to_char("None of your friends seem to be talking to you at the moment.\n\r", ch);
      return;
    }
    if (IS_FLAG(ch->act, PLR_DEAD)) {
      send_to_char("Dead men tell no tales.", ch);
      return;
    }
    // if(IS_FLAG(ch->pcdata->account->flags, ACCOUNT_NOFEEDBACK)) {return;}
    if (is_gm(ch) && str_cmp(ch->name, "Tyr")) {
      return;
    }

    d.original = NULL;
    if ((victim = get_char_world(ch, arg1)) != NULL) // Victim is online.
    online = TRUE;
    else {
      if ((victim = get_char_world_pc(arg1)) != NULL) // Victim is online.
      online = TRUE;
      else {
        log_string("DESCRIPTOR: Praise");

        if (!load_char_obj(&d, arg1)) {
          printf_to_char(ch, "\n\r%s is not a character!\n\r", capitalize(arg1));
          return;
        }

        sprintf(buf, "%s%s", PLAYER_DIR, capitalize(arg1));
        stat(buf, &sb);
        victim = d.character;
      }
    }
    if (IS_NPC(victim)) {
      if (!online)
      free_char(victim);
      send_to_char("\n\rYou can't target mobiles!\n\r", ch);
      return;
    }

    if ((!is_number(arg3) && str_cmp(arg2, "roleplay") && str_cmp(arg2, "villainy"))) {
      send_to_char("Praise (character name) (character/loyalty/appearance/roleplay) (amount) (reason)\n\r", ch);
      if (!online)
      free_char(victim);

      return;
    }
    if (ch != victim && !same_player(ch, victim) && safe_strlen(argument) < 10) {
      send_to_char("Praise (character name) (character/loyalty/appearance/roleplay) (amount) (reason)\n\r", ch);
      if (!online)
      free_char(victim);

      return;
    }
    if (higher_power(ch) || higher_power(victim))
    return;

    if (!str_cmp(arg2, "character")) {
      int amount = atoi(arg3);
      if (amount < 500 || (amount > ch->pcdata->influence && !IS_IMMORTAL(ch))) {
        send_to_char("You don't have enough influence to do that.\n\r", ch);
        if (!online)
        free_char(victim);

        return;
      }
      if (amount > 10000 && !IS_IMMORTAL(ch)) {
        send_to_char("Maximum is 10000 influence.\n\r", ch);
        return;
      }
      int superamount = 0;
      if (!IS_IMMORTAL(ch)) {
        if (is_super(victim) || victim->faction != 0) {
          superamount = UMIN(amount, ch->pcdata->super_influence);
          charge_influence(ch, INFLUENCE_SUPER, amount);
        }
        else
        ch->pcdata->influence -= amount;
      }

      if (!in_your_face(ch, victim, amount, PRAISE_CHARACTER)) {
        if (ch->pcdata->influence_balance <= 0 && amount > number_percent() * 100 && number_percent() % 4 == 0)
        praise_rumor(ch, victim, argument, PRAISE_CHARACTER);
      }

      int orig = amount;

      if (!worthy_praise(ch, victim))
      amount /= 4;
      if (staff_char(victim))
      amount /= 2;
      if (ch != victim && !same_player(ch, victim))
      victim->pcdata->influence += orig / 2;
      else {
        social_behave_mod(victim, -20, "praising themself.");
        amount /= 2;
      }
      victim->pcdata->social_praise += amount;

      if (!str_cmp(ch->pcdata->last_sexed[0], victim->name) || !str_cmp(ch->pcdata->last_sexed[1], victim->name) || !str_cmp(ch->pcdata->last_sexed[2], victim->name)) {
        send_to_char("Your attempts to increase their popularity seem less effective because of your sexual relationship.\n\r", ch);
      }
      else if (!worthy_praise(ch, victim)) {
        send_to_char("People seem a bit inured to your attempts to praise them.\n\r", ch);
      }
      else {
        ch->pcdata->social_praise += amount / 3;
        ch->pcdata->week_tracker[TRACK_CHARACTER_PRAISE_AMOUNT] += amount;
        ch->pcdata->life_tracker[TRACK_CHARACTER_PRAISE_AMOUNT] += amount;
        if (amount > number_percent() * 150 || safe_strlen(ch->pcdata->last_praise_message[MESSAGE_CHARACTER]) < 2) {
          free_string(ch->pcdata->last_praise_message[MESSAGE_CHARACTER]);
          ch->pcdata->last_praise_message[MESSAGE_CHARACTER] = str_dup(argument);
        }
      }
      superamount = UMIN(superamount, amount);
      if (superamount > 0)
      victim->pcdata->super_influence += superamount;
      if (amount > number_percent() * 50 && str_cmp(ch->name, victim->name)) {
        free_string(ch->pcdata->last_praised[2]);
        ch->pcdata->last_praised[2] = str_dup(ch->pcdata->last_praised[1]);
        free_string(ch->pcdata->last_praised[1]);
        ch->pcdata->last_praised[1] = str_dup(ch->pcdata->last_praised[0]);
        free_string(ch->pcdata->last_praised[0]);
        ch->pcdata->last_praised[0] = str_dup(victim->name);
      }

      if (ch != victim)
      ch->pcdata->influence_balance++;
      if (ch != victim)
      praise_echo(victim, "character", amount);

      save_char_obj(victim, FALSE, FALSE);
      if (!online)
      free_char(victim);

      sprintf(buf, "You speak well of $S character because %s.", argument);
      act(buf, ch, NULL, victim, TO_CHAR);

    }
    else if (!str_cmp(arg2, "appearance")) {
      int amount = atoi(arg3);
      if (amount < 500 || (amount > ch->pcdata->influence && !IS_IMMORTAL(ch))) {
        send_to_char("You don't have enough influence to do that.\n\r", ch);
        return;
      }
      if (amount > 10000 && !IS_IMMORTAL(ch)) {
        send_to_char("Maximum is 10000 influence.\n\r", ch);
        return;
      }

      if (!IS_IMMORTAL(ch)) {
        if (is_super(victim) || victim->faction != 0)
        charge_influence(ch, -1, amount);
        else
        ch->pcdata->influence -= amount;
      }

      if (!in_your_face(ch, victim, amount, PRAISE_APPEARANCE)) {
        if (ch->pcdata->influence_balance <= 0 && amount > number_percent() * 100 && number_percent() % 4 == 0)
        praise_rumor(ch, victim, argument, PRAISE_APPEARANCE);
      }

      if (ch != victim && !same_player(ch, victim))
      amount = praise_calc(ch, victim, amount);

      if (staff_char(victim))
      amount /= 2;
      if (same_player(ch, victim))
      amount /= 2;
      if (!str_cmp(ch->pcdata->last_sexed[0], victim->name) || !str_cmp(ch->pcdata->last_sexed[1], victim->name) || !str_cmp(ch->pcdata->last_sexed[2], victim->name)) {
        send_to_char("Your attempts to increase their desirability seem less effective because of your sexual relationship.\n\r", ch);
      }
      else if (!worthy_praise(ch, victim)) {
        send_to_char("People seem a bit inured to your attempts to praise them.\n\r", ch);
      }
      else {
        ch->pcdata->week_tracker[TRACK_APPEARANCE_PRAISE_AMOUNT] += amount;
        ch->pcdata->life_tracker[TRACK_APPEARANCE_PRAISE_AMOUNT] += amount;
        if (amount > number_percent() * 150 || safe_strlen(ch->pcdata->last_praise_message[MESSAGE_APPEARANCE]) < 2) {
          free_string(ch->pcdata->last_praise_message[MESSAGE_APPEARANCE]);
          ch->pcdata->last_praise_message[MESSAGE_APPEARANCE] = str_dup(argument);
        }
      }

      if (ch != victim && !same_player(ch, victim) && worthy_praise(ch, victim)) {
        social_behave_mod(ch, 5, "praising someone");
      }
      else
      social_behave_mod(ch, -20, "praising themself");

      if (victim->pcdata->attract[ATTRACT_PRAISE] > 5000)
      amount /= 2;

      victim->pcdata->attract_mod += amount / 50;

      victim->pcdata->attract[ATTRACT_PRAISE] += amount;

      if (amount > number_percent() * 50 && str_cmp(ch->name, victim->name)) {
        free_string(ch->pcdata->last_praised[2]);
        ch->pcdata->last_praised[2] = str_dup(ch->pcdata->last_praised[1]);
        free_string(ch->pcdata->last_praised[1]);
        ch->pcdata->last_praised[1] = str_dup(ch->pcdata->last_praised[0]);
        free_string(ch->pcdata->last_praised[0]);
        ch->pcdata->last_praised[0] = str_dup(victim->name);
      }

      if (ch == victim)
      ch->pcdata->selfesteem += amount / 1500;

      if (ch != victim)
      ch->pcdata->influence_balance++;

      if (ch != victim)
      praise_echo(victim, "appearance", amount);

      save_char_obj(victim, FALSE, FALSE);
      if (!online)
      free_char(victim);

      sprintf(buf, "You speak well of $S appearance because %s.", argument);
      act(buf, ch, NULL, victim, TO_CHAR);

    }
    else if (!str_cmp(arg2, "loyalty")) {
      int amount = atoi(arg3);
      if (ch == victim || same_player(ch, victim)) {
        if (amount < 500 || (amount > ch->pcdata->influence && !IS_IMMORTAL(ch))) {
          send_to_char("You don't have enough influence to do that.\n\r", ch);
          return;
        }
      }
      else {
        if (amount < 500 || (amount > (ch->pcdata->influence + ch->pcdata->faction_influence) && !IS_IMMORTAL(ch))) {
          send_to_char("You don't have enough influence to do that.\n\r", ch);
          return;
        }
      }

      if (amount > 10000 && !IS_IMMORTAL(ch)) {
        send_to_char("Maximum is 10000 influence.\n\r", ch);
        return;
      }

      if (!IS_IMMORTAL(ch)) {
        if (ch == victim || same_player(ch, victim)) {
          ch->pcdata->influence -= amount;
        }
        else {
          charge_influence(ch, INFLUENCE_FACTION, amount);
        }
      }

      if (!in_your_face(ch, victim, amount, PRAISE_LOYALTY)) {
        if (ch->pcdata->influence_balance <= 0 && amount > number_percent() * 100 && number_percent() % 4 == 0)
        praise_rumor(ch, victim, argument, PRAISE_LOYALTY);
      }

      if (ch != victim && !same_player(ch, victim))
      amount = praise_calc(ch, victim, amount);

      if (staff_char(victim))
      amount /= 2;

      if (!str_cmp(ch->pcdata->last_sexed[0], victim->name))
      amount /= 2;
      else if (!str_cmp(ch->pcdata->last_sexed[1], victim->name))
      amount /= 2;
      else if (!str_cmp(ch->pcdata->last_sexed[2], victim->name))
      amount /= 2;

      if (same_player(ch, victim))
      amount = amount * 2 / 3;

      if (!str_cmp(ch->pcdata->last_sexed[0], victim->name) || !str_cmp(ch->pcdata->last_sexed[1], victim->name) || !str_cmp(ch->pcdata->last_sexed[2], victim->name)) {
        send_to_char("Your attempts to increase their standing seem less effective because of your sexual relationship.\n\r", ch);
      }
      else if (!worthy_praise(ch, victim)) {
        send_to_char("People seem a bit inured to your attempts to praise them.\n\r", ch);
      }
      else {
        ch->pcdata->week_tracker[TRACK_LOYALTY_PRAISE_AMOUNT] += amount;
        ch->pcdata->life_tracker[TRACK_LOYALTY_PRAISE_AMOUNT] += amount;
        if (amount > number_percent() * 150 || safe_strlen(ch->pcdata->last_praise_message[MESSAGE_LOYALTY]) < 2) {
          free_string(ch->pcdata->last_praise_message[MESSAGE_LOYALTY]);
          ch->pcdata->last_praise_message[MESSAGE_LOYALTY] = str_dup(argument);
        }
      }
      int amcore = amount;
      int amsect = amount;
      int amcult = amount;

      if (ch->fcore != 0 && victim->fcore != 0 && clan_lookup(victim->fcore) != NULL && ch->fcore == victim->fcore) {
        if (is_leader(ch, victim->fcore)) {
          if (clan_lookup(victim->fcore)->axes[AXES_DEMOCRATIC] == AXES_FARLEFT)
          amcore = amount * 10;
          else if (clan_lookup(victim->fcore)->axes[AXES_DEMOCRATIC] ==
              AXES_MIDLEFT)
          amcore = amount * 5;
          else if (clan_lookup(victim->fcore)->axes[AXES_DEMOCRATIC] ==
              AXES_NEARLEFT)
          amcore = amount * 5 / 2;
          else if (clan_lookup(victim->fcore)->axes[AXES_DEMOCRATIC] ==
              AXES_NEUTRAL)
          amcore = amount * 2;
          else if (clan_lookup(victim->fcore)->axes[AXES_DEMOCRATIC] ==
              AXES_FARRIGHT)
          amcore = amount / 2;
          else if (clan_lookup(victim->fcore)->axes[AXES_DEMOCRATIC] ==
              AXES_NEARRIGHT)
          amcore = amount * 3 / 2;
        }
        else if (clan_lookup(victim->fcore)->axes[AXES_DEMOCRATIC] >
            AXES_NEUTRAL)
        amcore *= 3;
      }

      if (ch->fsect != 0 && victim->fsect != 0 && clan_lookup(victim->fsect) != NULL && ch->fsect == victim->fsect) {
        if (is_leader(ch, victim->fsect)) {
          if (clan_lookup(victim->fsect)->axes[AXES_DEMOCRATIC] == AXES_FARLEFT)
          amsect = amount * 10;
          else if (clan_lookup(victim->fsect)->axes[AXES_DEMOCRATIC] ==
              AXES_MIDLEFT)
          amsect = amount * 5;
          else if (clan_lookup(victim->fsect)->axes[AXES_DEMOCRATIC] ==
              AXES_NEARLEFT)
          amsect = amount * 5 / 2;
          else if (clan_lookup(victim->fsect)->axes[AXES_DEMOCRATIC] ==
              AXES_NEUTRAL)
          amsect = amount * 2;
          else if (clan_lookup(victim->fsect)->axes[AXES_DEMOCRATIC] ==
              AXES_FARRIGHT)
          amsect = amount / 2;
          else if (clan_lookup(victim->fsect)->axes[AXES_DEMOCRATIC] ==
              AXES_NEARRIGHT)
          amsect = amount * 3 / 2;
        }
        else if (clan_lookup(victim->fsect)->axes[AXES_DEMOCRATIC] >
            AXES_NEUTRAL)
        amsect *= 3;
      }

      if (ch->fcult != 0 && victim->fcult != 0 && clan_lookup(victim->fcult) != NULL && ch->fcult == victim->fcult) {
        if (is_leader(ch, victim->fcult)) {
          if (clan_lookup(victim->fcult)->axes[AXES_DEMOCRATIC] == AXES_FARLEFT)
          amcult = amount * 10;
          else if (clan_lookup(victim->fcult)->axes[AXES_DEMOCRATIC] ==
              AXES_MIDLEFT)
          amcult = amount * 5;
          else if (clan_lookup(victim->fcult)->axes[AXES_DEMOCRATIC] ==
              AXES_NEARLEFT)
          amcult = amount * 5 / 2;
          else if (clan_lookup(victim->fcult)->axes[AXES_DEMOCRATIC] ==
              AXES_NEUTRAL)
          amcult = amount * 2;
          else if (clan_lookup(victim->fcult)->axes[AXES_DEMOCRATIC] ==
              AXES_FARRIGHT)
          amcult = amount / 2;
          else if (clan_lookup(victim->fcult)->axes[AXES_DEMOCRATIC] ==
              AXES_NEARRIGHT)
          amcult = amount * 3 / 2;
        }
        else if (clan_lookup(victim->fcult)->axes[AXES_DEMOCRATIC] >
            AXES_NEUTRAL)
        amcult *= 3;
      }

      if (ch != victim && !same_player(ch, victim) && worthy_praise(ch, victim)) {
        if(ch->fcore > 0)
        give_respect_noecho(ch, amount / 4, ch->fcore);
        if(ch->fsect > 0)
        give_respect_noecho(ch, amount / 4, ch->fsect);
        if(ch->fcult > 0)
        give_respect_noecho(ch, amount / 4, ch->fcult);
      }

      int perc_core = victim->esteem_faction / 5000 * amount;
      perc_core /= 20;

      int perc_sect = victim->esteem_faction / 5000 * amount;
      perc_sect /= 20;

      int perc_cult = victim->esteem_cult / 5000 * amount;
      perc_cult /= 20;

      if (ch == victim || same_player(ch, victim))
      social_behave_mod(ch, -20, "praising themself");

      if (amount > number_percent() * 50 && str_cmp(ch->name, victim->name)) {
        free_string(ch->pcdata->last_praised[2]);
        ch->pcdata->last_praised[2] = str_dup(ch->pcdata->last_praised[1]);
        free_string(ch->pcdata->last_praised[1]);
        ch->pcdata->last_praised[1] = str_dup(ch->pcdata->last_praised[0]);
        free_string(ch->pcdata->last_praised[0]);
        ch->pcdata->last_praised[0] = str_dup(victim->name);
      }

      if(ch->fcore == victim->fcore) {
        if (ch != victim && !same_player(ch, victim))
        give_respect(victim, amcore + perc_core, "Praise", victim->fcore);
        else
        give_respect_noecho(victim, amcore + perc_core, victim->fcore);
      }
      else
      {
        if (ch != victim && !same_player(ch, victim))
        give_respect(victim, (amcore + perc_core)/5, "Praise", victim->fcore);
        else
        give_respect_noecho(victim, (amcore + perc_core)/5, victim->fcore);
      }

      if(ch->fsect == victim->fsect) {
        if (ch != victim && !same_player(ch, victim))
        give_respect(victim, amsect + perc_sect, "Praise", victim->fsect);
        else
        give_respect_noecho(victim, amsect + perc_sect, victim->fsect);
      }
      else
      {
        if (ch != victim && !same_player(ch, victim))
        give_respect(victim, (amsect + perc_sect)/5, "Praise", victim->fsect);
        else
        give_respect_noecho(victim, (amsect + perc_sect)/5, victim->fsect);
      }

      if(ch->fcult == victim->fcult) {
        if (ch != victim && !same_player(ch, victim))
        give_respect(victim, amcult + perc_cult, "Praise", victim->fcult);
        else
        give_respect_noecho(victim, amcult + perc_cult, victim->fcult);
      }
      else
      {
        if (ch != victim && !same_player(ch, victim))
        give_respect(victim, (amcult + perc_cult)/5, "Praise", victim->fcult);
        else
        give_respect_noecho(victim, (amcult + perc_cult)/5, victim->fcult);
      }

      if (ch != victim)
      praise_echo(victim, "loyalty", amount);

      if (ch != victim)
      ch->pcdata->influence_balance++;

      save_char_obj(victim, FALSE, FALSE);
      if (!online)
      free_char(victim);

      sprintf(buf, "You speak well of $S loyalty because %s.", argument);
      act(buf, ch, NULL, victim, TO_CHAR);

    }
    else if (!str_cmp(arg2, "roleplay")) {

      sprintf(buf, "%s\nSomeone had this positive feedback on your roleplay: %s %s", victim->pcdata->messages, arg3, argument);
      if(!spammer(ch) && !IS_FLAG(ch->pcdata->account->flags, ACCOUNT_SHH))
      {
        free_string(victim->pcdata->messages);
        victim->pcdata->messages = str_dup(buf);
      }

      save_char_obj(victim, FALSE, FALSE);
      if (!online)
      free_char(victim);

      send_to_char("Done.\n\r", ch);
    }
    else if (!str_cmp(arg2, "villainy")) {
      if (IS_IMMORTAL(ch)) {
        if (victim->pcdata->account == NULL) {
          send_to_char("No account found.\n\r", ch);
          return;
        }
        victim->pcdata->account->villain_mod = atoi(arg3);
        victim->pcdata->account->villain_mod =
        UMAX(victim->pcdata->account->villain_mod, -10);
        victim->pcdata->account->villain_mod =
        UMIN(victim->pcdata->account->villain_mod, 10);
        printf_to_char(ch, "Villain mod set to %d.\n\r", victim->pcdata->account->villain_mod);
        return;
      }
      if (ch->pcdata->account->villain_cooldown > current_time) {
        send_to_char("You can't do that again yet, only one villain praise or diss can be done per account per two weeks.\n\r", ch);
        return;
      }
      if (safe_strlen(argument) < 2) {
        send_to_char("Syntax: Praise (person) villainy (reason)\n\r", ch);
        return;
      }
      if (ch == victim || same_player(ch, victim)) {
        send_to_char("You can't use that on yourself.\n\r", ch);
        return;
      }
      if(are_noncult_allies(ch, victim))
      {
        send_to_char("You shouldn't be afraid of your ally.\n\r", ch);
        return;
      }
      bool lpraised = FALSE;
      if (!str_cmp(ch->pcdata->last_praised[0], victim->name))
      lpraised = TRUE;
      if (!str_cmp(ch->pcdata->last_praised[1], victim->name))
      lpraised = TRUE;
      if (!str_cmp(ch->pcdata->last_praised[2], victim->name))
      lpraised = TRUE;

      if (clan_lookup(ch->faction) != NULL && clan_lookup(ch->faction)->axes[AXES_CORRUPT] <= AXES_NEUTRAL)
      lpraised = TRUE;

      if (lpraised == FALSE) {
        ch->pcdata->villain_type = 1;
        free_string(ch->pcdata->villain_praise);
        ch->pcdata->villain_praise = str_dup(victim->name);
        free_string(ch->pcdata->villain_message);
        sprintf(buf, "%s %s", arg3, argument);
        ch->pcdata->villain_message = str_dup(buf);
      }
      ch->pcdata->account->villain_cooldown = current_time + (3600 * 24 * 10);

      sprintf(buf, "You are afraid of $N because %s.", argument);
      act(buf, ch, NULL, victim, TO_CHAR);
      sprintf(buf, "VILLAIN: %s praises %s because %s.", ch->name, victim->name, argument);
      log_string(buf);
      villain_mod(victim, 10, "Praise");
      save_char_obj(victim, FALSE, FALSE);
      if (!online)
      free_char(victim);
    }
    else {
      send_to_char("Praise (character name) (character/loyalty/appearance/roleplay/villainy) (amount) (reason)\n\r", ch);
      return;
    }
  }

  _DOFUN(do_diss) {
    char arg1[MSL];
    char arg2[MSL];
    char arg3[MSL];
    struct stat sb;
    char buf[MSL];
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    CHAR_DATA *victim;

    ch->pcdata->influence_balance = UMIN(ch->pcdata->influence_balance, 15);
    ch->pcdata->influence_balance = UMAX(ch->pcdata->influence_balance, -15);

    argument = one_argument_nouncap(argument, arg1);
    argument = one_argument_nouncap(argument, arg2);
    argument = one_argument_nouncap(argument, arg3);

    if (IS_AFFECTED(ch, AFF_OUTCAST)) {
      send_to_char("None of your friends seem to be talking to you at the moment.\n\r", ch);
      return;
    }

    if (IS_FLAG(ch->act, PLR_DEAD)) {
      send_to_char("Dead men tell no tales.", ch);
      return;
    }

    if (IS_FLAG(ch->pcdata->account->flags, ACCOUNT_NOFEEDBACK)) {
      send_to_char("Your ability to provide feedback has been disabled.", ch);
      return;
    }

    if (is_gm(ch) && !IS_IMMORTAL(ch))
    return;

    d.original = NULL;
    if ((victim = get_char_world(ch, arg1)) != NULL) // Victim is online.
    online = TRUE;
    else {
      if ((victim = get_char_world_pc(arg1)) != NULL) // Victim is online.
      online = TRUE;
      else {
        log_string("DESCRIPTOR: Diss");

        if (!load_char_obj(&d, arg1)) {
          printf_to_char(ch, "\n\r%s is not a character!\n\r", capitalize(arg1));
          return;
        }

        sprintf(buf, "%s%s", PLAYER_DIR, capitalize(arg1));
        stat(buf, &sb);
        victim = d.character;
      }
    }
    if (IS_NPC(victim)) {
      if (!online) {
        free_char(victim);
      }
      send_to_char("\n\rYou can't target mobiles!\n\r", ch);
      return;
    }

    if ((!is_number(arg3) && str_cmp(arg2, "roleplay") && str_cmp(arg2, "villainy")) || safe_strlen(argument) < 10) {
      send_to_char("Diss (character name) (character/loyalty/appearance/roleplay) (amount) (reason)\n\r", ch);
      if (!online) {
        free_char(victim);
      }

      return;
    }
    if (ch == victim) {
      send_to_char("Don't hate yourself bro.\n\r", ch);
      return;
    }
    if (higher_power(ch) || higher_power(victim))
    return;

    if (!str_cmp(arg2, "character")) {
      int amount = atoi(arg3);
      if (amount < 500 || (amount > ch->pcdata->influence && !IS_IMMORTAL(ch))) {
        send_to_char("You don't have enough influence to do that.\n\r", ch);
        if (!online) {
          free_char(victim);
        }

        return;
      }
      if (amount > 10000 && !IS_IMMORTAL(ch)) {
        send_to_char("Maximum is 10000 influence.\n\r", ch);
        return;
      }
      int superamount = 0;
      if (!IS_IMMORTAL(ch)) {
        if (is_super(victim) || victim->faction != 0) {
          superamount = UMIN(amount, ch->pcdata->super_influence);
          charge_influence(ch, INFLUENCE_SUPER, amount);
        }
        else {
          ch->pcdata->influence -= amount;
        }
      }

      if (!in_your_face(ch, victim, amount, DISS_CHARACTER)) {
        if (ch->pcdata->influence_balance >= 0 && amount > number_percent() * 100 && number_percent() % 4 == 0)
        praise_rumor(ch, victim, argument, DISS_CHARACTER);
      }
      int orig = amount;
      if (!worthy_diss(ch, victim)) {
        amount /= 4;
      }
      else {
        social_behave_mod(ch, 5, "praising someone");
      }

      if (!str_cmp(ch->pcdata->last_sexed[0], victim->name) || !str_cmp(ch->pcdata->last_sexed[1], victim->name) || !str_cmp(ch->pcdata->last_sexed[2], victim->name)) {
        amount *= 2;
        send_to_char("People seem much more interested in hearing your complaints given your history.\n\r", ch);
      }

      victim->pcdata->influence -= orig / 2;
      victim->pcdata->social_praise -= amount;
      ch->pcdata->social_praise += amount / 5;

      superamount = UMIN(superamount, amount);
      if (superamount > 0) {
        victim->pcdata->super_influence -= superamount;
      }
      if (!worthy_diss(ch, victim)) {
        send_to_char("People seem a bit inured to your attempts to diss them.\n\r", ch);
      }
      else {
        ch->pcdata->week_tracker[TRACK_CHARACTER_DISS_AMOUNT] += amount;
        ch->pcdata->life_tracker[TRACK_CHARACTER_DISS_AMOUNT] += amount;
        if (amount > number_percent() * 150 || safe_strlen(ch->pcdata->last_diss_message[MESSAGE_CHARACTER]) < 2) {
          free_string(ch->pcdata->last_diss_message[MESSAGE_CHARACTER]);
          ch->pcdata->last_diss_message[MESSAGE_CHARACTER] = str_dup(argument);
        }
      }

      if (amount > number_percent() * 50) {
        free_string(ch->pcdata->last_dissed[2]);
        ch->pcdata->last_dissed[2] = str_dup(ch->pcdata->last_dissed[1]);
        free_string(ch->pcdata->last_dissed[1]);
        ch->pcdata->last_dissed[1] = str_dup(ch->pcdata->last_dissed[0]);
        free_string(ch->pcdata->last_dissed[0]);
        ch->pcdata->last_dissed[0] = str_dup(victim->name);
      }

      if (ch != victim) {
        diss_echo(victim, "character", amount);
      }

      ch->pcdata->influence_balance--;
      save_char_obj(victim, FALSE, FALSE);

      if (!online) {
        free_char(victim);
      }

      sprintf(buf, "You speak badly of $S character because %s.", argument);
      act(buf, ch, NULL, victim, TO_CHAR);
    }
    if (!str_cmp(arg2, "sexual")) {
      int amount = atoi(arg3);
      if (amount < 500 || (amount > ch->pcdata->influence && !IS_IMMORTAL(ch))) {
        send_to_char("You don't have enough influence to do that.\n\r", ch);
        if (!online) {
          free_char(victim);
        }

        return;
      }
      if (amount > 10000 && !IS_IMMORTAL(ch)) {
        send_to_char("Maximum is 10000 influence.\n\r", ch);
        return;
      }

      if (!IS_IMMORTAL(ch)) {
        if (is_super(victim) || victim->faction != 0) {
          charge_influence(ch, -1, amount);
        }
        else {
          ch->pcdata->influence -= amount;
        }
      }

      if (!in_your_face(ch, victim, amount, DISS_SEXUAL)) {
        if (ch->pcdata->influence_balance >= 0 && amount > number_percent() * 100 && number_percent() % 4 == 0)
        praise_rumor(ch, victim, argument, DISS_SEXUAL);
      }
      if (!worthy_diss(ch, victim)) {
        amount /= 4;
      }
      else {
        social_behave_mod(ch, 5, "praising someone.");
      }
      int value = amount / 1500;
      if (!str_cmp(ch->pcdata->last_sexed[0], victim->name)) {
        value *= 10;
      }
      else if (!str_cmp(ch->pcdata->last_sexed[1], victim->name) || !str_cmp(ch->pcdata->last_sexed[2], victim->name)) {
        value *= 5;
      }

      if (!str_cmp(ch->pcdata->last_sexed[0], victim->name) || !str_cmp(ch->pcdata->last_sexed[1], victim->name) || !str_cmp(ch->pcdata->last_sexed[2], victim->name)) {
        send_to_char("People seem much more interested in hearing your complaints given your history.\n\r", ch);
      }
      if (!worthy_diss(ch, victim)) {
        send_to_char("People seem a bit inured to your attempts to diss them.\n\r", ch);
      }
      if (amount > number_percent() * 50) {
        free_string(ch->pcdata->last_dissed[2]);
        ch->pcdata->last_dissed[2] = str_dup(ch->pcdata->last_dissed[1]);
        free_string(ch->pcdata->last_dissed[1]);
        ch->pcdata->last_dissed[1] = str_dup(ch->pcdata->last_dissed[0]);
        free_string(ch->pcdata->last_dissed[0]);
        ch->pcdata->last_dissed[0] = str_dup(victim->name);
      }
      if (ch != victim) {
        diss_echo(victim, "sexual", amount);
      }
      victim->pcdata->attract[ATTRACT_PROM] += value;

      ch->pcdata->influence_balance--;

      save_char_obj(victim, FALSE, FALSE);
      if (!online) {
        free_char(victim);
      }

      sprintf(buf, "You speak badly of $S sexually because %s.", argument);
      act(buf, ch, NULL, victim, TO_CHAR);
    }
    else if (!str_cmp(arg2, "appearance")) {
      int amount = atoi(arg3);
      if (amount < 500 || (amount > ch->pcdata->influence && !IS_IMMORTAL(ch))) {
        send_to_char("You don't have enough influence to do that.\n\r", ch);
        return;
      }
      if (amount > 10000 && !IS_IMMORTAL(ch)) {
        send_to_char("Maximum is 10000 influence.\n\r", ch);
        return;
      }

      if (!IS_IMMORTAL(ch)) {
        if (is_super(victim) || victim->faction != 0) {
          charge_influence(ch, -1, amount);
        }
        else {
          ch->pcdata->influence -= amount;
        }
      }

      if (!in_your_face(ch, victim, amount, DISS_APPEARANCE)) {
        if (ch->pcdata->influence_balance >= 0 && amount > number_percent() * 100 && number_percent() % 4 == 0) {
          praise_rumor(ch, victim, argument, DISS_APPEARANCE);
        }
      }

      if (ch != victim && !same_player(ch, victim)) {
        amount = diss_calc(ch, victim, amount);
      }

      if (!worthy_diss(ch, victim)) {
        send_to_char("People seem a bit inured to your attempts to diss them.\n\r", ch);
      }
      else {
        ch->pcdata->week_tracker[TRACK_APPEARANCE_DISS_AMOUNT] += amount;
        ch->pcdata->life_tracker[TRACK_APPEARANCE_DISS_AMOUNT] += amount;
        if (amount > number_percent() * 150 || safe_strlen(ch->pcdata->last_diss_message[MESSAGE_APPEARANCE]) < 2) {
          free_string(ch->pcdata->last_diss_message[MESSAGE_APPEARANCE]);
          ch->pcdata->last_diss_message[MESSAGE_APPEARANCE] = str_dup(argument);
        }

        social_behave_mod(ch, 5, "dissing someone.");
      }
      if (!str_cmp(ch->pcdata->last_sexed[0], victim->name) || !str_cmp(ch->pcdata->last_sexed[1], victim->name) || !str_cmp(ch->pcdata->last_sexed[2], victim->name)) {
        amount *= 2;
        send_to_char("People seem much more interested in hearing your complaints given your history.\n\r", ch);
      }

      if (amount > number_percent() * 50) {
        free_string(ch->pcdata->last_dissed[2]);
        ch->pcdata->last_dissed[2] = str_dup(ch->pcdata->last_dissed[1]);
        free_string(ch->pcdata->last_dissed[1]);
        ch->pcdata->last_dissed[1] = str_dup(ch->pcdata->last_dissed[0]);
        free_string(ch->pcdata->last_dissed[0]);
        ch->pcdata->last_dissed[0] = str_dup(victim->name);
      }

      victim->pcdata->attract_mod -= amount / 50;
      victim->pcdata->attract[ATTRACT_PRAISE] -= amount;

      if (ch != victim) {
        diss_echo(victim, "appearance", amount);
      }

      ch->pcdata->influence_balance--;

      save_char_obj(victim, FALSE, FALSE);
      if (!online) {
        free_char(victim);
      }

      sprintf(buf, "You speak badly of $S appearance because %s.", argument);
      act(buf, ch, NULL, victim, TO_CHAR);
    }
    else if (!str_cmp(arg2, "loyalty")) {
      int amount = atoi(arg3);
      if (ch == victim || same_player(ch, victim)) {
        if (amount < 500 || (amount > ch->pcdata->influence && !IS_IMMORTAL(ch))) {
          send_to_char("You don't have enough influence to do that.\n\r", ch);
          return;
        }
      }
      else {
        if (amount < 500 || (amount > (ch->pcdata->influence + ch->pcdata->faction_influence) && !IS_IMMORTAL(ch))) {
          send_to_char("You don't have enough influence to do that.\n\r", ch);
          return;
        }
      }

      if (amount > 10000 && !IS_IMMORTAL(ch)) {
        send_to_char("Maximum is 10000 influence.\n\r", ch);
        return;
      }

      if (!IS_IMMORTAL(ch)) {
        charge_influence(ch, INFLUENCE_FACTION, amount);
      }

      if (!in_your_face(ch, victim, amount, DISS_LOYALTY)) {
        if (ch->pcdata->influence_balance >= 0 && amount > number_percent() * 100 && number_percent() % 4 == 0) {
          praise_rumor(ch, victim, argument, DISS_LOYALTY);
        }
      }

      if (ch != victim && !same_player(ch, victim)) {
        amount = diss_calc(ch, victim, amount);
      }

      if (!worthy_diss(ch, victim)) {
        send_to_char("People seem a bit inured to your attempts to diss them.\n\r", ch);
      }
      else {
        ch->pcdata->week_tracker[TRACK_LOYALTY_DISS_AMOUNT] += amount;
        ch->pcdata->life_tracker[TRACK_LOYALTY_DISS_AMOUNT] += amount;
        if (amount > number_percent() * 150 || safe_strlen(ch->pcdata->last_diss_message[MESSAGE_LOYALTY]) < 2) {
          free_string(ch->pcdata->last_diss_message[MESSAGE_LOYALTY]);
          ch->pcdata->last_diss_message[MESSAGE_LOYALTY] = str_dup(argument);
        }
        social_behave_mod(ch, 5, "dissing someone");
      }

      if (!str_cmp(ch->pcdata->last_sexed[0], victim->name) || !str_cmp(ch->pcdata->last_sexed[1], victim->name) || !str_cmp(ch->pcdata->last_sexed[2], victim->name)) {
        amount *= 2;
        send_to_char("People seem much more interested in hearing your complaints given your history.\n\r", ch);
      }

      if (ch != victim && !same_player(ch, victim) && worthy_praise(ch, victim)) {
        if(ch->fcore > 0)
        give_respect_noecho(ch, amount / 4, ch->fcore);
        if(ch->fsect > 0)
        give_respect_noecho(ch, amount / 4, ch->fsect);
        if(ch->fcult > 0)
        give_respect_noecho(ch, amount / 4, ch->fcult);
      }
      int amcore = amount;
      int amsect = amount;
      int amcult = amount;


      int perc_core = victim->esteem_faction / 5000 * amount;
      perc_core /= 20;

      int perc_sect = victim->esteem_faction / 5000 * amount;
      perc_sect /= 20;


      int perc_cult = victim->esteem_cult / 5000 * amount;
      perc_cult /= 20;


      if (amount > number_percent() * 50) {
        free_string(ch->pcdata->last_dissed[2]);
        ch->pcdata->last_dissed[2] = str_dup(ch->pcdata->last_dissed[1]);
        free_string(ch->pcdata->last_dissed[1]);
        ch->pcdata->last_dissed[1] = str_dup(ch->pcdata->last_dissed[0]);
        free_string(ch->pcdata->last_dissed[0]);
        ch->pcdata->last_dissed[0] = str_dup(victim->name);
      }

      if(ch->fcore == victim->fcore) {
        if (ch != victim && !same_player(ch, victim))
        give_respect(victim, -1*(amcore + perc_core), "Diss", victim->fcore);
        else
        give_respect_noecho(victim, -1*(amcore + perc_core), victim->fcore);
      }
      else
      {
        if (ch != victim && !same_player(ch, victim))
        give_respect(victim, -1*(amcore + perc_core)/5, "Diss", victim->fcore);
        else
        give_respect_noecho(victim, -1*(amcore + perc_core)/5, victim->fcore);
      }

      if(ch->fsect == victim->fsect) {
        if (ch != victim && !same_player(ch, victim))
        give_respect(victim, -1*(amsect + perc_sect), "Diss", victim->fsect);
        else
        give_respect_noecho(victim, -1*(amsect + perc_sect), victim->fsect);
      }
      else
      {
        if (ch != victim && !same_player(ch, victim))
        give_respect(victim, -1*(amsect + perc_sect)/5, "Diss", victim->fsect);
        else
        give_respect_noecho(victim, -1*(amsect + perc_sect)/5, victim->fsect);
      }

      if(ch->fcult == victim->fcult) {
        if (ch != victim && !same_player(ch, victim))
        give_respect(victim, -1*(amcult + perc_cult), "Diss", victim->fcult);
        else
        give_respect_noecho(victim, -1*(amcult + perc_cult), victim->fcult);
      }
      else
      {
        if (ch != victim && !same_player(ch, victim))
        give_respect(victim, -1*(amcult + perc_cult)/5, "Diss", victim->fcult);
        else
        give_respect_noecho(victim, -1*(amcult + perc_cult)/5, victim->fcult);
      }

      if (ch != victim) {
        diss_echo(victim, "loyalty", amount);
      }

      ch->pcdata->influence_balance--;

      save_char_obj(victim, FALSE, FALSE);
      if (!online) {
        free_char(victim);
      }

      sprintf(buf, "You speak badly of $S loyalty because %s.", argument);
      act(buf, ch, NULL, victim, TO_CHAR);

    }
    else if (!str_cmp(arg2, "roleplay")) {
      sprintf(buf, "%s %s", arg3, argument);

      free_string(ch->pcdata->diss_message);
      ch->pcdata->diss_message = str_dup(buf);
      free_string(ch->pcdata->diss_target);
      ch->pcdata->diss_target = str_dup(victim->name);
      ch->pcdata->diss_sendable = 0;

      save_char_obj(victim, FALSE, FALSE);
      if (!online) {
        free_char(victim);
      }

      send_to_char("Done.\n\r", ch);
    }
    else if (!str_cmp(arg2, "villainy")) {
      if (IS_IMMORTAL(ch)) {
        if (victim->pcdata->account == NULL) {
          send_to_char("No account found.\n\r", ch);
          return;
        }
        victim->pcdata->account->villain_mod = atoi(arg3);
        victim->pcdata->account->villain_mod =
        UMAX(victim->pcdata->account->villain_mod, -10);
        victim->pcdata->account->villain_mod =
        UMIN(victim->pcdata->account->villain_mod, 10);
        printf_to_char(ch, "Villain mod set to %d.\n\r", victim->pcdata->account->villain_mod);
        return;
      }
      if (ch->pcdata->account->villain_cooldown > current_time) {
        send_to_char("You can't do that again yet, only one villain praise or diss can be done per account per two weeks.\n\r", ch);
        return;
      }
      if (safe_strlen(argument) < 2) {
        send_to_char("Syntax: Diss (person) villainy (reason)\n\r", ch);
        return;
      }
      bool ldissed = FALSE;

      if (!str_cmp(ch->pcdata->last_dissed[0], victim->name)) {
        ldissed = TRUE;
      }
      else if (!str_cmp(ch->pcdata->last_dissed[1], victim->name)) {
        ldissed = TRUE;
      }
      else if (!str_cmp(ch->pcdata->last_dissed[2], victim->name)) {
        ldissed = TRUE;
      }

      if (ldissed == FALSE) {
        ch->pcdata->villain_type = 2;
        free_string(ch->pcdata->villain_praise);
        ch->pcdata->villain_praise = str_dup(victim->name);
        free_string(ch->pcdata->villain_message);
        sprintf(buf, "%s %s", arg3, argument);
        ch->pcdata->villain_message = str_dup(buf);
      }
      ch->pcdata->account->villain_cooldown = current_time + (3600 * 24 * 10);

      sprintf(buf, "You are not afraid of $N because %s.", argument);
      act(buf, ch, NULL, victim, TO_CHAR);
      sprintf(buf, "VILLAIN: %s disses %s because %s.", ch->name, victim->name, argument);
      log_string(buf);
      villain_mod(victim, -10, "Diss");
      save_char_obj(victim, FALSE, FALSE);
      if (!online) {
        free_char(victim);
      }
    }
    else {
      send_to_char("Diss (character name) (character/loyalty/appearance/roleplay) (amount) (reason)\n\r", ch);
      return;
    }
  }

  _DOFUN(do_rumor) {
    char buf[MSL];

    if (IS_AFFECTED(ch, AFF_OUTCAST)) {
      send_to_char("None of your friends seem to be talking to you at the moment.\n\r", ch);
      return;
    }
    if (room_pop_mortals(ch->in_room) < 2 && !IS_IMMORTAL(ch)) {
      send_to_char("There's nobody here to tell.\n\r", ch);
      return;
    }
    if (is_gm(ch) && !IS_IMMORTAL(ch)) {
      return;
    }
    if (is_helpless(ch) || is_prisoner(ch)) {
      send_to_char("There's nobody here to tell.\n\r", ch);
      return;
    }
    if (college_student(ch, FALSE) || clinic_staff(ch, FALSE) || college_staff(ch, FALSE)) {
      if (ch->pcdata->influence < 250) {
        send_to_char("You don't have enough influence.\n\r", ch);
        return;
      }
    }
    else {
      if (ch->pcdata->influence < 1000) {
        send_to_char("You don't have enough influence.\n\r", ch);
        return;
      }
    }
    if (safe_strlen(argument) < 5) {
      send_to_char("Syntax: rumor (message)\n\r", ch);
      return;
    }

    if (IS_FLAG(ch->act, PLR_DEAD)) {
      send_to_char("Dead men tell no tales.\n\r", ch);
      return;
    }

    social_behave_mod(ch, 10, "making a rumor");
    if (institute_room(ch->in_room)
        && (college_student(ch, FALSE) || clinic_staff(ch, FALSE) || college_staff(ch, FALSE))) {
      ch->pcdata->influence -= 500;
    }
    else {
      ch->pcdata->influence -= 1000;
    }

    ch->pcdata->week_tracker[TRACK_RUMORS]++;
    ch->pcdata->life_tracker[TRACK_RUMORS]++;
    if (number_percent() % 2 == 0 || safe_strlen(ch->pcdata->last_rumor) < 2) {
      free_string(ch->pcdata->last_rumor);
      ch->pcdata->last_rumor = str_dup(argument);
    }

    sprintf(buf, "You spread the rumor that: %s", argument);
    act(buf, ch, NULL, NULL, TO_CHAR);
    sprintf(buf, "$n spreads the rumor that: %s", argument);
    act(buf, ch, NULL, NULL, TO_ROOM);
    // seperating institute gossip - Discordance 6/7/2016
    if (institute_room(ch->in_room) && (college_student(ch, FALSE) || clinic_staff(ch, FALSE) || college_staff(ch, FALSE))) {
      gossip(argument);
    }
    else {
      gossip(argument);
    }
  }

  _DOFUN(do_lightswitch) {
    if (in_fight(ch))
    return;

    // ghostie check and limit for lightswitch -Discordance
    if (is_ghost(ch)) {
      if (is_manifesting(ch)) {
        if (deplete_ghostpool(ch, GHOST_MANIFESTATION) == FALSE) {
          send_to_char("You can't muster the strength to manifest your will any more today.\n\r", ch);
          return;
        }
      }
      else {
        send_to_char("You must be prepared to manifest your will.\n\r", ch);
        return;
      }
    }
    if (is_helpless(ch) || in_fight(ch) || IS_FLAG(ch->act, PLR_SHROUD)) {
      send_to_char("Not now.\n\r", ch);
      return;
    }
    if (prop_from_room(ch->in_room) != NULL && prop_from_room(ch->in_room)->prop_state == 1) {
      send_to_char("The lightswitch doesn't seem to work.\n\r", ch);
      return;
    }

    if (IS_SET(ch->in_room->room_flags, ROOM_LIGHTON)) {
      act("You turn off the lights.", ch, NULL, NULL, TO_CHAR);
      act("$n turns off the lights.", ch, NULL, NULL, TO_ROOM);
      REMOVE_BIT(ch->in_room->room_flags, ROOM_LIGHTON);
      SET_BIT(ch->in_room->room_flags, ROOM_LIGHTOFF);
      if (prop_from_room(ch->in_room) != NULL) {
        prop_from_room(ch->in_room)->lightcount--;
      }
    }
    else if (IS_SET(ch->in_room->room_flags, ROOM_LIGHTOFF)) {
      if (prop_from_room(ch->in_room) != NULL && prop_from_room(ch->in_room)->type_special == PROPERTY_OUTERFOREST && prop_from_room(ch->in_room)->utilities == 0) {
        send_to_char("The lightswitch doesn't seem to work.\n\r", ch);
        return;
      }

      REMOVE_BIT(ch->in_room->room_flags, ROOM_LIGHTOFF);
      SET_BIT(ch->in_room->room_flags, ROOM_LIGHTON);
      act("You turn on the lights.", ch, NULL, NULL, TO_CHAR);
      act("$n turns on the lights.", ch, NULL, NULL, TO_ROOM);
      if (prop_from_room(ch->in_room) != NULL) {
        prop_from_room(ch->in_room)->lightcount++;
      }
    }
    else {
      send_to_char("There is no lightswitch here.\n\r", ch);
    }
  }

  void vamp_bite(CHAR_DATA *ch, CHAR_DATA *victim, int level) {
    if (safe_strlen(victim->pcdata->taste) > 2)
    printf_to_char(ch, "%s\n\r", victim->pcdata->taste);

    free_string(victim->pcdata->last_bitten);
    victim->pcdata->last_bitten = str_dup(ch->name);

    for (int i = 0; i < 25; i++) {
      if (victim->pcdata->imprint_type[i] == IMPRINT_DRUGS && victim->pcdata->imprint_pending[i] > 0)
      auto_imprint(ch, victim->pcdata->imprint[i], IMPRINT_DRUGS);
    }

    if (is_vampire(victim)) {
      if (str_cmp(victim->pcdata->pledge, ch->name) || !IS_FLAG(victim->comm, COMM_VBLOOD)) {
        AFFECT_DATA af;
        af.where = TO_AFFECTS;
        af.type = 0;
        af.level = 10;
        af.duration = 60;
        af.location = APPLY_NONE;
        af.modifier = 0;
        af.caster = NULL;
        af.weave = FALSE;
        af.bitvector = AFF_VBLOOD;
        affect_to_char(ch, &af);

        send_to_char("You start to feel energized, aroused and powerful as the vampire blood hits your system.\n\r", ch);
        SET_FLAG(ch->comm, COMM_VBLOOD);
      }

      for (int i = 0; i < level; i++) {
        int max = 0;
        int pointer = -1;
        for (int j = 0; j < 6; j++) {
          if (victim->pcdata->heldblood[j] > max) {
            max = victim->pcdata->heldblood[j];
            pointer = j;
          }
        }
        if (pointer > -1) {
          victim->pcdata->heldblood[pointer]--;
          ch->pcdata->heldblood[pointer]++;
        }
      }
    }

    if (seems_faeborn(victim)) {
      send_to_char("The blood starts to make you feel a lot more amorous.\n\r", ch);
    }
    if (seems_demonborn(victim)) {
      send_to_char("The blood starts to make you feel less connected to others, and more emotionally deadened.\n\r", ch);
    }
    if (seems_demigod(victim)) {
      send_to_char("The blood starts to make you feel more energized and fearless.\n\r", ch);
    }
    if (seems_angelborn(victim)) {
      send_to_char("The blood starts to make you feel more empathetic and human.\n\r", ch);
    }
    if (seems_werewolf(victim)) {
      send_to_char("The blood makes you feel more primal, your baser impulses are stronger.\n\r", ch);
    }
    if(is_virgin(victim)) {
      send_to_char("The blood is crisp and pure.  It is invigoratingly wholesome and tastes like innocence.\n\r", ch);
    }
    if (get_app_race(victim) == RACE_WIGHT) {
      send_to_char("The blood tastes flat and boring.\n\r", ch);
    }
  }

  bool biteable(CHAR_DATA *ch, CHAR_DATA *victim, bool show) {
    if (IS_FLAG(victim->act, PLR_DEAD)) {
      if (show == TRUE)
      send_to_char("Their flesh no longer courses with fresh blood.\n\r", ch);
      return FALSE;
    }

    if (event_cleanse == 1)
    return FALSE;
    if (in_fight(ch)) {
      if (show == TRUE)
      send_to_char("You're a bit busy.\n\r", ch);
      return FALSE;
    }
    if (is_pinned(ch) || is_helpless(ch)) {
      if (show == TRUE)
      send_to_char("You can't do that.\n\r", ch);
      return FALSE;
    }
    if (IS_NPC(victim)) {
      if (show == TRUE)
      send_to_char("Not on NPCS.\n\r", ch);
      return FALSE;
    }
    if (is_safe(ch, victim)) {
      if (show == TRUE)
      send_to_char("For some reason you can't bring yourself to do that.\n\r", ch);
      return FALSE;
    }
    if (room_hostile(ch->in_room)) {
      if (show == TRUE)
      start_hostilefight(ch);
      return FALSE;
    }
    if (ch->race == RACE_WIGHT) {
      if (!IS_NPC(victim) && victim->pcdata->trance > 0 && show == TRUE)
      victim->pcdata->trance = -20;

      if (in_public(ch, victim)) {
        if (show == TRUE)
        send_to_char("That would draw a bit too much attention.\n\r", ch);
        return FALSE;
      }

      if (!is_helpless(victim)) {
        if (show == TRUE)
        send_to_char("I don't think they'll let you do that.\n\r", ch);
        return FALSE;
      }
      if (under_understanding(victim, ch) && victim->wounds > 0) {
        if (show == TRUE)
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return FALSE;
      }
      return TRUE;
    }
    if (!is_vampire(ch)) {
      if (show == TRUE)
      send_to_char("Try sharpening your teeth a little more first.\n\r", ch);
      return FALSE;
    }
    if (ch->recent_moved > -300 || victim->recent_moved > -300) {
      if (show == TRUE)
      send_to_char("They don't seem inclined to let you that close.\n\r", ch);
      return FALSE;
    }
    if (in_public(ch, victim) && pc_pop(ch->in_room) > 2) {
      if (show == TRUE)
      send_to_char("That would draw a bit too much attention.\n\r", ch);
      return FALSE;
    }
    if (in_public(ch, victim)) {
      if (victim->pcdata->guard_number > 0 && victim->pcdata->guard_expiration >= current_time) {
        if (show == TRUE)
        send_to_char("That would draw a bit too much attention from their guards.\n\r", ch);
        return FALSE;
      }
    }

    int amount = 0;
    amount = UMIN(1000, base_lifeforce(victim) - 8000);
    if (is_super(victim)) {
      amount /= 4;
    }
    if (IS_AFFECTED(victim, AFF_DRAINED))
    amount /= 2;

    int profit = amount;

    if(is_virgin(victim)) {
      profit *= 2;
    }

    if (victim->wounds != 0 && (!is_helpless(victim) || victim->pcdata->trance > 0)) {
      if (show == TRUE)
      send_to_char("Their blood doesn't smell potent enough to feed on them without better restraints.\n\r", ch);
      return FALSE;
    }
    if (amount <= 200 && (!is_helpless(victim) || victim->pcdata->trance > 0)) {
      if (show == TRUE)
      send_to_char("Their blood doesn't smell potent enough for a small sip to be worth it.\n\r", ch);
      return FALSE;
    }
    if (IS_AFFECTED(victim, AFF_ABDUCTED) && show == FALSE)
    return FALSE;

    return TRUE;
  }

  _DOFUN(do_kiss) {

    CHAR_DATA *victim;
    char arg1[MSL];
    char buf[MSL];

    argument = one_argument_nouncap(argument, arg1);

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }
    if(strlen(argument) < 2)
    {
      send_to_char("Syntax: kiss (person) (location)\n\r", ch);
      return;
    }
    if (ch->recent_moved > -900 || victim->recent_moved > -900) {
      send_to_char("They don't seem inclined to let you that close.\n\r", ch);
      return;
    }
    if (pc_pop(ch->in_room) > 4) {
      send_to_char("There are too many people around.\n\r", ch);
      return;
    }
    sprintf(buf, "$n kisses $N on %s", argument);
    act(buf, ch, NULL, victim, TO_NOTVICT);
    sprintf(buf, "$n kisses you on %s", argument);
    act(buf, ch, NULL, victim, TO_VICT);
    sprintf(buf, "You kiss $N on %s", argument);
    act(buf, ch, NULL, victim, TO_CHAR);
    if(ch->pcdata->boon == BOON_LOVER && ch->pcdata->boon_timeout > current_time)
    {

      AFFECT_DATA af;
      af.where = TO_AFFECTS;
      af.type = 0;
      af.level = 10;
      af.duration = 12*60*4;
      af.location = APPLY_NONE;
      af.modifier = 0;
      af.caster = NULL;
      af.weave = FALSE;
      af.bitvector = AFF_DSENSITIVE;
      affect_to_char(victim, &af);
      send_to_char("You make them more suggestible.\n\r", ch);
    }
  }
  _DOFUN(do_bite) {

    CHAR_DATA *victim;
    char arg1[MSL];
    char buf[MSL];

    argument = one_argument_nouncap(argument, arg1);

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }
    if (!biteable(ch, victim, TRUE))
    return;
    if (is_ghost(ch))
    return;
    if (ch->race == RACE_WIGHT) {
      int val;
      wound_char(victim, 1);
      if (get_skill(victim, SKILL_HYPERREGEN) > 0)
      val = 0;
      else if (get_skill(victim, SKILL_IMMORTALITY) > 0 && victim->wounds > 1)
      val = 0;
      else if (get_skill(victim, SKILL_REGEN) >= 2)
      val = 2;
      else if (get_skill(victim, SKILL_REGEN) > 0)
      val = 10;
      else
      val = 30;

      val *= 3;

      ch->pcdata->decay_timer =
      UMIN(ch->pcdata->max_decay_timer, ch->pcdata->decay_timer + val);
      act("$n takes a bloody, messy bite out of $N, hungrily chewing on and then swallowing the hunk of bloody flesh.", ch, NULL, victim, TO_NOTVICT);
      act("$n takes a bloody, messy bite out of you, hungrily chewing on and then swallowing the hunk of bloody flesh.", ch, NULL, victim, TO_VICT);
      act("You take a bloody, messy bite out of $N, hungrily chewing on and then swallowing the hunk of bloody flesh.", ch, NULL, victim, TO_CHAR);
      vamp_bite(ch, victim, 1);
      if (val <= 0)
      send_to_char("The flesh is tasteless in your mouth.\n\r", ch);
      return;
    }

    int amount = 0;
    amount = UMIN(1000, base_lifeforce(victim) - 8000);
    if (is_super(victim))
    amount /= 4;
    if (IS_AFFECTED(victim, AFF_DRAINED))
    amount /= 2;

    int profit = amount;
    if (is_virgin(victim) && str_cmp(victim->pcdata->last_bitten, ch->name))
    profit *= 2;

    if (!str_cmp(victim->pcdata->last_bitten, ch->name))
    profit = profit * 2 / 3;
    else
    profit = profit * 12 / 10;

    int goodmod = base_lifeforce(ch);
    profit = profit * 10000 / goodmod;
    profit = profit * 10000 / goodmod;
    profit = profit * 10000 / goodmod;

    int cap;
    if (get_tier(victim) == 1)
    cap = 10000;
    else if (get_tier(victim) == 2)
    cap = 12000;
    else
    cap = 20000;

    if (guestmonster(victim))
    return;
    if (higher_power(victim))
    return;
    if (!str_cmp(argument, "mild")) {
      if (!is_helpless(victim)) {
        send_to_char("I don't think they'll let you do that.\n\r", ch);
        return;
      }
      if (victim->wounds != 0 && victim->pcdata->trance > 0) {
        send_to_char("Their blood doesn't smell potent enough to feed on them without better restraints.\n\r", ch);
        return;
      }
      if (amount <= 200) {
        send_to_char("Their blood doesn't smell potent enough for a small sip to be worth it.\n\r", ch);
        return;
      }
      if (IS_AFFECTED(victim, AFF_ABDUCTED)) {
        send_to_char("Their blood doesn't smell potent enough for a small sip to be worth it.\n\r", ch);
        return;
      }
      if (get_tier(victim) > 1 && UMAX(base_lifeforce(ch), UMIN(cap, base_lifeforce(ch) + profit)) >
          base_lifeforce(ch) && str_cmp(victim->pcdata->last_bitten, ch->name)) {
        sprintf(buf, "Biting %s", victim->name);
        villain_mod(ch, 15, buf);
      }
      if (!str_cmp(victim->pcdata->last_bitten, ch->name))
      victim->pcdata->ill_count += amount;

      take_lifeforce(victim, amount, "Vampire bite.");
      if (victim->pcdata->trance > 0)
      victim->pcdata->bittenloss = amount;
      if (IS_AFFECTED(victim, AFF_BITTEN))
      take_lifeforce(ch, 100, "Bad blood bite");
      else
      give_lifeforce_nouse(ch, UMAX(0, UMIN(cap - unused_lifeforce(ch), profit)), "Vampire bite");
      vamp_bite(ch, victim, 1);
      ch->pcdata->conditions[COND_DRUNK] +=
      victim->pcdata->conditions[COND_DRUNK];
      AFFECT_DATA af;
      af.where = TO_AFFECTS;
      af.type = 0;
      af.level = 10;
      af.duration = 12 * 60 * 20;
      af.location = APPLY_NONE;
      af.modifier = 0;
      af.caster = NULL;
      af.weave = FALSE;
      af.bitvector = AFF_BITTEN;
      affect_to_char(victim, &af);

      act("You grab $N to hold them in place as you move in, lowering your fangs to $S neck and drinking greedily before pulling away and letting $M go.", ch, NULL, victim, TO_CHAR);
      if (victim->pcdata->trance < 1)
      act("$n grabs you to hold you in pace as $e lowers $s mouth to your neck, a moment later you feel $s fangs pierce your skin painfully and $e starts to drink, pulling back after a moment and letting you go.", ch, NULL, victim, TO_VICT);
      act("$n grabs $N roughly to hold them in pace as $e lowers $s mouth to $S neck, sinking fangs into them and drinking hungrily for several moments before pulling back and letting $M go.", ch, NULL, victim, TO_NOTVICT);
      if (victim->desc == NULL) {
        sprintf(
        buf, "You half awaken to %s standing over you and a pain in your neck.", PERS(ch, victim));
        message_to_char(victim->name, buf);
      }
      if (victim->pcdata->trance > 0)
      victim->pcdata->trance = -30;
      victim->hit = max_hp(victim);
    }
    else if (!str_cmp(argument, "severe")) {
      if (!IS_NPC(victim) && victim->pcdata->trance > 0)
      victim->pcdata->trance = -20;

      if (!is_helpless(victim)) {
        send_to_char("Maybe you should tie them up first.\n\r", ch);
        return;
      }
      if (under_understanding(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }

      amount *= 2;
      profit *= 2;

      if (victim->wounds <= 1)
      wound_char_absolute(victim, 2);
      else
      victim->heal_timer += 20000;

      if (!str_cmp(victim->pcdata->last_bitten, ch->name))
      victim->pcdata->ill_count += amount;

      take_lifeforce(victim, amount, "vampire bite.");
      if (IS_AFFECTED(victim, AFF_BITTEN))
      take_lifeforce(ch, 100, "Bad blood bite");
      else
      give_lifeforce_nouse(ch, UMAX(0, UMIN(cap - unused_lifeforce(ch), profit)), "Vampire bite");

      vamp_bite(ch, victim, 2);

      ch->pcdata->conditions[COND_DRUNK] +=
      victim->pcdata->conditions[COND_DRUNK];

      act("You move in on $N lowering your fangs to $S neck and drinking deeply before pulling away, leaving $M severely wounded", ch, NULL, victim, TO_CHAR);
      act("$n lowers $s mouth to your neck, a moment later you feel $s fangs pierce your skin painfully and $e starts to drink, pulling backagain after having drunk deeply, leaving you severely wounded.", ch, NULL, victim, TO_VICT);
      act("$n lowers $s mouth to $S neck, sinking fangs into them and drinking deeply for several moments before pulling back, leaving $M severely wounded.", ch, NULL, victim, TO_NOTVICT);
      if (victim->desc == NULL) {
        sprintf(
        buf, "You half awaken to %s standing over you and a pain in your neck.", PERS(ch, victim));
        message_to_char(victim->name, buf);
      }
    }
    else if (!str_cmp(argument, "critical")) {
      if (!IS_NPC(victim) && victim->pcdata->trance > 0)
      victim->pcdata->trance = -20;

      if (!is_helpless(victim)) {
        send_to_char("Maybe you should tie them up first.\n\r", ch);
        return;
      }
      if (under_understanding(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }
      if (under_limited(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }

      if (higher_power(ch) || higher_power(victim))
      return;

      amount *= 3;
      profit *= 3;

      if (victim->wounds <= 2)
      wound_char_absolute(victim, 3);
      else
      victim->heal_timer += 50000;

      take_lifeforce(victim, amount, "Vampire bite.");
      give_lifeforce_nouse(ch, UMAX(0, UMIN(cap - unused_lifeforce(ch), profit)), "Vampire bite");

      vamp_bite(ch, victim, 3);

      ch->pcdata->conditions[COND_DRUNK] +=
      victim->pcdata->conditions[COND_DRUNK];

      act("You move in on $N lowering your fangs to $S neck and drinking deeply before pulling away, leaving $M critically wounded", ch, NULL, victim, TO_CHAR);
      act("$n lowers $s mouth to your neck, a moment later you feel $s fangs pierce your skin painfully and $e starts to drink, pulling back again after having drunk deeply, leaving you critically wounded.", ch, NULL, victim, TO_VICT);
      act("$n lowers $s mouth to $S neck, sinking fangs into them and drinking deeply for several moments before pulling back leaving $M critically wounded.", ch, NULL, victim, TO_NOTVICT);
      if (victim->desc == NULL) {
        sprintf(
        buf, "You half awaken to %s standing over you and a pain in your neck.", PERS(ch, victim));
        message_to_char(victim->name, buf);
      }

      if (!IS_NPC(victim))
      critplayer(ch, victim);

      free_string(victim->pcdata->deathcause);
      victim->pcdata->deathcause = str_dup("Heart failure.");

    }
    else if (!str_cmp(argument, "fatal")) {
      if (!IS_NPC(victim) && victim->pcdata->trance > 0)
      victim->pcdata->trance = -20;

      if (!is_helpless(victim)) {
        send_to_char("Maybe you should tie them up first.\n\r", ch);
        return;
      }
      if (under_understanding(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }
      if (under_limited(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }

      if (higher_power(ch) || higher_power(victim))
      return;

      amount *= 5;
      profit *= 5;

      take_lifeforce(victim, amount, "Vampire bite.");
      give_lifeforce_nouse(ch, UMAX(0, UMIN(cap - unused_lifeforce(ch), profit)), "Vampire bite");

      vamp_bite(ch, victim, 4);
      ch->pcdata->conditions[COND_DRUNK] +=
      victim->pcdata->conditions[COND_DRUNK];

      act("You move in on $N lowering your fangs to $S neck and draining $M utterly before pulling away.", ch, NULL, victim, TO_CHAR);
      act("$n lowers $s mouth to your neck, a moment later you feel $s fangs pierce your skin painfully and $e starts to drink, pulling back again after having drunk deeply.", ch, NULL, victim, TO_VICT);
      act("$n lowers $s mouth to $S neck, sinking fangs into them and draining $M utterly before pulling back.", ch, NULL, victim, TO_NOTVICT);

      if (!IS_NPC(victim))
      killplayer(ch, victim);

      real_kill(victim, ch);
      free_string(victim->pcdata->deathcause);
      victim->pcdata->deathcause = str_dup("Heart failure.");

      if (IS_FLAG(victim->act, PLR_BOUND))
      REMOVE_FLAG(victim->act, PLR_BOUND);
      if (IS_FLAG(victim->act, PLR_BOUNDFEET))
      REMOVE_FLAG(victim->act, PLR_BOUNDFEET);

      if (under_understanding(victim, ch)) {
        under_taint(ch, victim, 12 * 60 * 20);
      }
      victim->pcdata->blood_date = current_time;
      victim->pcdata->blood_level = victim->pcdata->blood_potency;
    }
    else
    send_to_char("Syntax: bite (person) mild/severe/critical/fatal\n\r", ch);
  }

  _DOFUN(do_drain) {

    CHAR_DATA *victim;
    char arg1[MSL];
    OBJ_DATA *obj;
    char buf[MSL];
    argument = one_argument_nouncap(argument, arg1);

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (IS_FLAG(victim->act, PLR_DEAD)) {
      send_to_char("Their flesh no longer courses with fresh blood.\n\r", ch);
      return;
    }

    if (event_cleanse == 1)
    return;
    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (is_pinned(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (IS_NPC(victim)) {
      send_to_char("Not on NPCS.\n\r", ch);
      return;
    }
    if (is_safe(ch, victim)) {
      send_to_char("For some reason you can't bring yourself to do that.\n\r", ch);
      return;
    }
    if (in_public(ch, victim)) {
      send_to_char("That would draw a bit too much attention.\n\r", ch);
      return;
    }
    if (!IS_NPC(victim) && victim->pcdata->trance > 0)
    victim->pcdata->trance = -20;

    if (!is_helpless(victim)) {
      send_to_char("I don't think they're going to let you do that.\n\r", ch);
      return;
    }
    if (is_ghost(ch)) {
      send_to_char("You don't have anywhere to keep blood draining equipment.\n\r", ch);
      return;
    }
    if (!IS_NPC(ch) && ch->in_room->vnum >= 105000000 && ch->in_room->vnum <= 105000020) {
      send_to_char("That woudln't work here.\n\r", ch);
      return;
    }

    if (!str_cmp(argument, "mild")) {
      if (victim->wounds == 0)
      wound_char_absolute(victim, 1);
      else
      victim->heal_timer += 25000;

      if (is_vampire(victim)) {
        obj = create_object(get_obj_index(33), 0);
        obj_to_room(obj, ch->in_room);
        obj = create_object(get_obj_index(33), 0);
        obj_to_room(obj, ch->in_room);
      }

      act("You force a needle into $N and drain some of their blood.", ch, NULL, victim, TO_CHAR);
      act("$n forces a needle into you and drains some of your blood.", ch, NULL, victim, TO_VICT);
      act("$n forces a needle into $N and drains some of $S blood.", ch, NULL, victim, TO_NOTVICT);
      if (victim->desc == NULL) {
        sprintf(buf, "You half awaken to %s standing over you and a needle in your arm during the night.", ch->pcdata->intro_desc);
        message_to_char(victim->name, buf);
      }
    }
    else if (!str_cmp(argument, "severe")) {

      if (under_understanding(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }

      if (victim->wounds <= 1)
      wound_char_absolute(victim, 2);
      else
      victim->heal_timer += 50000;

      if (is_vampire(victim)) {
        obj = create_object(get_obj_index(33), 0);
        obj_to_room(obj, ch->in_room);
        obj = create_object(get_obj_index(33), 0);
        obj_to_room(obj, ch->in_room);
        obj = create_object(get_obj_index(33), 0);
        obj_to_room(obj, ch->in_room);
        obj = create_object(get_obj_index(33), 0);
        obj_to_room(obj, ch->in_room);
      }

      victim->pcdata->blood_date = current_time;
      victim->pcdata->blood_level = victim->pcdata->blood_potency;

      act("You force a needle into $N and drain some of their blood, leaving them severely wounded.", ch, NULL, victim, TO_CHAR);
      act("$n forces a needle into you and drains some of your blood, leaving you severely wounded.", ch, NULL, victim, TO_VICT);
      act("$n forces a needle into $N and drains some of $S blood, leaving them severely wounded", ch, NULL, victim, TO_NOTVICT);
      if (victim->desc == NULL) {
        sprintf(buf, "You half awaken to %s standing over you and a needle in your arm during the night.", ch->pcdata->intro_desc);
        message_to_char(victim->name, buf);
      }

    }
    else if (!str_cmp(argument, "fatal")) {
      if (!is_helpless(victim)) {
        send_to_char("Maybe you should tie them up first.\n\r", ch);
        return;
      }
      if (under_understanding(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }
      if (under_limited(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }
      if (is_vampire(victim)) {
        obj = create_object(get_obj_index(33), 0);
        obj_to_room(obj, ch->in_room);
        obj = create_object(get_obj_index(33), 0);
        obj_to_room(obj, ch->in_room);
        obj = create_object(get_obj_index(33), 0);
        obj_to_room(obj, ch->in_room);
        obj = create_object(get_obj_index(33), 0);
        obj_to_room(obj, ch->in_room);
        obj = create_object(get_obj_index(33), 0);
        obj_to_room(obj, ch->in_room);
        obj = create_object(get_obj_index(33), 0);
        obj_to_room(obj, ch->in_room);
        obj = create_object(get_obj_index(33), 0);
        obj_to_room(obj, ch->in_room);
        obj = create_object(get_obj_index(33), 0);
        obj_to_room(obj, ch->in_room);
        obj = create_object(get_obj_index(33), 0);
        obj_to_room(obj, ch->in_room);
        obj = create_object(get_obj_index(33), 0);
        obj_to_room(obj, ch->in_room);
        obj = create_object(get_obj_index(33), 0);
        obj_to_room(obj, ch->in_room);
        obj = create_object(get_obj_index(33), 0);
        obj_to_room(obj, ch->in_room);
      }

      ch->pcdata->conditions[COND_DRUNK] +=
      victim->pcdata->conditions[COND_DRUNK];

      act("You force a needle into $N and drain some of their blood, killing them.", ch, NULL, victim, TO_CHAR);
      act("$n forces a needle into you and drains some of your blood, killing you.", ch, NULL, victim, TO_VICT);
      act("$n forces a needle into $N and drains some of $S blood, killing $M.", ch, NULL, victim, TO_NOTVICT);

      if (!IS_NPC(victim))
      killplayer(ch, victim);

      real_kill(victim, ch);
      free_string(victim->pcdata->deathcause);
      victim->pcdata->deathcause = str_dup("Blood loss");

      if (IS_FLAG(victim->act, PLR_BOUND))
      REMOVE_FLAG(victim->act, PLR_BOUND);
      if (IS_FLAG(victim->act, PLR_BOUNDFEET))
      REMOVE_FLAG(victim->act, PLR_BOUNDFEET);

      if (under_understanding(victim, ch)) {
        under_taint(ch, victim, 12 * 60 * 20);
      }
    }
    else
    send_to_char("Syntax: drain (person) mild/severe/critical/fatal\n\r", ch);
  }

  _DOFUN(do_giveblood) {
    OBJ_DATA *obj;

    if (IS_FLAG(ch->act, PLR_DEAD)) {
      send_to_char("Your blood has already been spilt.", ch);
      return;
    }
    if (is_vampire(ch)) {
      if (ch->wounds > 0) {
        send_to_char("I'm not sure you have the blood to share.\n\r", ch);
        return;
      }
      obj = create_object(get_obj_index(33), 0);
      obj_to_char(obj, ch);
      obj->cost = 2;
      wound_char_noregen(ch, 1);
      ch->heal_timer /= 10;

      send_to_char("You find a glass and pour some of your blood into it.\n\r", ch);
      return;
    }
    return;

    if (ch->in_room->vnum != ROOM_BLOODBANK) {
      send_to_char("You have to be in a blood bank to do that.\n\r", ch);
      return;
    }
    if (ch->played / 3600 < 15) {
      send_to_char("Play a little more first.\n\r", ch);
      return;
    }

    if (ch->pcdata->blood_potency < 100) {
      send_to_char("Your blood isn't powerful enough for that to achieve anything.\n\r", ch);
      return;
    }

    if (ch->wounds > 0) {
      send_to_char("You're too weak to do that.\n\r", ch);
      return;
    }

    if (ch->money < 3000) {
      send_to_char("You don't have enough money to bribe the nurse.\n\r", ch);
      return;
    }

    obj = create_object(get_obj_index(30), 0);

    if (get_skill(ch, SKILL_VIRGIN) && ch->pcdata->virginity_lost == 0)
    obj->level = 1;
    else if (get_skill(ch, SKILL_FAEBORN) > 0)
    obj->level = 2;
    else if (get_skill(ch, SKILL_ANGELBORN) > 0)
    obj->level = 3;
    else if (get_skill(ch, SKILL_DEMONBORN) > 0)
    obj->level = 4;
    else if (get_skill(ch, SKILL_DEMIGOD) > 0)
    obj->level = 5;

    obj_to_char(obj, ch);
    ch->money -= 3000;
    send_to_char("You give blood and bribe the nurse to let you keep the sample.\n\r", ch);
    ch->pcdata->blood_potency -= 10;
    wound_char(ch, 1);

    ch->pcdata->blood_date = current_time;
    ch->pcdata->blood_level = ch->pcdata->blood_potency;
  }

  _DOFUN(do_libate) {

    char arg1[MSL];
    char arg2[MSL];
    OBJ_DATA *obj;
    OBJ_DATA *mount;

    argument = one_argument(argument, arg1);
    argument = one_argument(argument, arg2);

    if ((obj = get_obj_carry(ch, arg2, NULL)) == NULL) {
      if ((obj = get_obj_list(ch, arg2, ch->in_room->contents)) == NULL) {
        send_to_char("That isn't here.\n\r", ch);
        return;
      }
    }

    if ((mount = get_obj_carry(ch, arg1, NULL)) == NULL) {
      if ((mount = get_obj_list(ch, arg1, ch->in_room->contents)) == NULL) {
        send_to_char("That isn't here.\n\r", ch);
        return;
      }
    }

    if (obj->pIndexData->vnum != 30) {
      send_to_char("That isn't a blood bag.\n\r", ch);
      return;
    }

    if (mount->item_type != ITEM_BLOODCRYSTAL) {
      send_to_char("That isn't a blood crystal.\n\r", ch);
      return;
    }

    if (obj->level == 0) {
      mount->level++;
    }
    else {
      mount->value[obj->level - 1]++;
    }

    extract_obj(obj);
    send_to_char("You libate the blood into the crystal.\n\r", ch);
  }

  OBJ_DATA *get_crystal(CHAR_DATA *ch) {
    OBJ_DATA *phone;
    if ((phone = get_held(ch, ITEM_BLOODCRYSTAL)) != NULL && phone->item_type == ITEM_BLOODCRYSTAL)
    return phone;

    for (phone = ch->carrying; phone != NULL; phone = phone->next_content) {
      if (phone->wear_loc != WEAR_NONE || IS_SET(phone->extra_flags, ITEM_WARDROBE))
      continue;

      if (phone->item_type != ITEM_BLOODCRYSTAL)
      continue;

      return phone;
    }

    return NULL;
  }

  bool take_blood_vamp(CHAR_DATA *ch, int type, int amount) {

    int total, subblood;
    if (!is_vampire(ch))
    return FALSE;

    if (type == BLOOD_VIRGIN) {

      total = ch->pcdata->heldblood[0];
      subblood = 0;
      subblood += ch->pcdata->heldblood[5];
      subblood += ch->pcdata->heldblood[1];
      subblood += ch->pcdata->heldblood[2];
      subblood += ch->pcdata->heldblood[3];
      subblood += ch->pcdata->heldblood[4];
      
      subblood = subblood / 3;

      total += subblood;

      if (total < amount)
      return FALSE;

      if (ch->pcdata->heldblood[0] > amount) {
        ch->pcdata->heldblood[0] -= amount;
        return TRUE;
      }

      amount -= ch->pcdata->heldblood[0];
      ch->pcdata->heldblood[0] = 0;

      amount *= 3;

      for (; amount > 0;) {
        if (ch->pcdata->heldblood[5] > 0) {
          amount--;
          ch->pcdata->heldblood[5]--;
        }
        else if (ch->pcdata->heldblood[1] > 0) {
          amount--;
          ch->pcdata->heldblood[1]--;
        }
        else if (ch->pcdata->heldblood[2] > 0) {
          amount--;
          ch->pcdata->heldblood[2]--;
        }
        else if (ch->pcdata->heldblood[3] > 0) {
          amount--;
          ch->pcdata->heldblood[3]--;
        }
        else if (ch->pcdata->heldblood[4] > 0) {
          amount--;
          ch->pcdata->heldblood[4]--;
        }
      }

      return TRUE;
    }
    if (type == BLOOD_FAEBORN) {

      total = ch->pcdata->heldblood[1];
      subblood = 0;
      subblood += ch->pcdata->heldblood[5];
      subblood += ch->pcdata->heldblood[0];
      subblood += ch->pcdata->heldblood[2];
      subblood += ch->pcdata->heldblood[3];
      subblood += ch->pcdata->heldblood[4];

      subblood = subblood / 2;

      total += subblood;

      if (total < amount)
      return FALSE;

      if (ch->pcdata->heldblood[1] > amount) {
        ch->pcdata->heldblood[1] -= amount;
        return TRUE;
      }

      amount -= ch->pcdata->heldblood[1];
      ch->pcdata->heldblood[1] = 0;

      amount *= 2;

      for (; amount > 0;) {
        if (ch->pcdata->heldblood[5] > 0) {
          amount--;
          ch->pcdata->heldblood[5]--;
        }
        else if (ch->pcdata->heldblood[0] > 0) {
          amount--;
          ch->pcdata->heldblood[0]--;
        }
        else if (ch->pcdata->heldblood[2] > 0) {
          amount--;
          ch->pcdata->heldblood[2]--;
        }
        else if (ch->pcdata->heldblood[3] > 0) {
          amount--;
          ch->pcdata->heldblood[3]--;
        }
        else if (ch->pcdata->heldblood[4] > 0) {
          amount--;
          ch->pcdata->heldblood[4]--;
        }
      }
      return TRUE;
    }
    if (type == BLOOD_ANGELBORN) {
      total = ch->pcdata->heldblood[2];
      subblood = 0;
      subblood += ch->pcdata->heldblood[5];
      subblood += ch->pcdata->heldblood[0];
      subblood += ch->pcdata->heldblood[1];
      subblood += ch->pcdata->heldblood[3];
      subblood += ch->pcdata->heldblood[4];
      subblood = subblood / 2;
      total += subblood;
      if (total < amount)
      return FALSE;
      if (ch->pcdata->heldblood[2] > amount) {
        ch->pcdata->heldblood[2] -= amount;
        return TRUE;
      }

      amount -= ch->pcdata->heldblood[2];
      ch->pcdata->heldblood[2] = 0;

      amount *= 2;

      for (; amount > 0;) {
        if (ch->pcdata->heldblood[5] > 0) {
          amount--;
          ch->pcdata->heldblood[5]--;
        }
        else if (ch->pcdata->heldblood[0] > 0) {
          amount--;
          ch->pcdata->heldblood[0]--;
        }
        else if (ch->pcdata->heldblood[1] > 0) {
          amount--;
          ch->pcdata->heldblood[1]--;
        }
        else if (ch->pcdata->heldblood[3] > 0) {
          amount--;
          ch->pcdata->heldblood[3]--;
        }
        else if (ch->pcdata->heldblood[4] > 0) {
          amount--;
          ch->pcdata->heldblood[4]--;
        }
      }

      return TRUE;
    }
    if (type == BLOOD_DEMONBORN) {

      total = ch->pcdata->heldblood[3];
      subblood = 0;
      subblood += ch->pcdata->heldblood[5];
      subblood += ch->pcdata->heldblood[0];
      subblood += ch->pcdata->heldblood[2];
      subblood += ch->pcdata->heldblood[3];
      subblood += ch->pcdata->heldblood[4];

      subblood = subblood / 2;

      total += subblood;

      if (total < amount)
      return FALSE;

      if (ch->pcdata->heldblood[3] > amount) {
        ch->pcdata->heldblood[3] -= amount;
        return TRUE;
      }

      amount -= ch->pcdata->heldblood[3];
      ch->pcdata->heldblood[3] = 0;

      amount *= 2;

      for (; amount > 0;) {
        if (ch->pcdata->heldblood[5] > 0) {
          amount--;
          ch->pcdata->heldblood[5]--;
        }
        else if (ch->pcdata->heldblood[0] > 0) {
          amount--;
          ch->pcdata->heldblood[0]--;
        }
        else if (ch->pcdata->heldblood[2] > 0) {
          amount--;
          ch->pcdata->heldblood[2]--;
        }
        else if (ch->pcdata->heldblood[1] > 0) {
          amount--;
          ch->pcdata->heldblood[1]--;
        }
        else if (ch->pcdata->heldblood[4] > 0) {
          amount--;
          ch->pcdata->heldblood[4]--;
        }
      }

      return TRUE;
    }
    if (type == BLOOD_DEMIGOD) {

      total = ch->pcdata->heldblood[4];
      subblood = 0;
      subblood += ch->pcdata->heldblood[5];
      subblood += ch->pcdata->heldblood[0];
      subblood += ch->pcdata->heldblood[2];
      subblood += ch->pcdata->heldblood[3];
      subblood += ch->pcdata->heldblood[4];

      subblood = subblood / 2;

      total += subblood;

      if (total < amount)
      return FALSE;

      if (ch->pcdata->heldblood[4] > amount) {
        ch->pcdata->heldblood[4] -= amount;
        return TRUE;
      }

      amount -= ch->pcdata->heldblood[4];
      ch->pcdata->heldblood[4] = 0;

      amount *= 2;

      for (; amount > 0;) {
        if (ch->pcdata->heldblood[5] > 0) {
          amount--;
          ch->pcdata->heldblood[5]--;
        }
        else if (ch->pcdata->heldblood[0] > 0) {
          amount--;
          ch->pcdata->heldblood[0]--;
        }
        else if (ch->pcdata->heldblood[2] > 0) {
          amount--;
          ch->pcdata->heldblood[2]--;
        }
        else if (ch->pcdata->heldblood[3] > 0) {
          amount--;
          ch->pcdata->heldblood[3]--;
        }
        else if (ch->pcdata->heldblood[1] > 0) {
          amount--;
          ch->pcdata->heldblood[1]--;
        }
      }

      return TRUE;
    }
    if (type == BLOOD_REGULAR) {

      total = ch->pcdata->heldblood[1];
      subblood = 0;
      subblood += ch->pcdata->heldblood[5];
      subblood += ch->pcdata->heldblood[0];
      subblood += ch->pcdata->heldblood[2];
      subblood += ch->pcdata->heldblood[3];
      subblood += ch->pcdata->heldblood[4];

      total += subblood;

      if (total < amount)
      return FALSE;

      if (ch->pcdata->heldblood[5] > amount) {
        ch->pcdata->heldblood[5] -= amount;
        return TRUE;
      }

      amount -= ch->pcdata->heldblood[5];
      ch->pcdata->heldblood[5] = 0;

      for (; amount > 0;) {
        if (ch->pcdata->heldblood[1] > 0) {
          amount--;
          ch->pcdata->heldblood[1]--;
        }

        else if (ch->pcdata->heldblood[0] > 0) {
          amount--;
          ch->pcdata->heldblood[0]--;
        }
        else if (ch->pcdata->heldblood[2] > 0) {
          amount--;
          ch->pcdata->heldblood[2]--;
        }
        else if (ch->pcdata->heldblood[3] > 0) {
          amount--;
          ch->pcdata->heldblood[3]--;
        }
        else if (ch->pcdata->heldblood[4] > 0) {
          amount--;
          ch->pcdata->heldblood[4]--;
        }
      }

      return TRUE;
    }
    return FALSE;
  }

  bool take_blood(CHAR_DATA *ch, int type, int amount) {

    OBJ_DATA *obj;
    int total, subblood;

    obj = get_crystal(ch);

    if (obj == NULL) {
      if (is_vampire(ch)) {
        if (!take_blood_vamp(ch, type, amount))
        return FALSE;
        else
        return TRUE;
      }
      return FALSE;
    }

    if (type == BLOOD_VIRGIN) {

      total = obj->value[0];
      subblood = 0;
      subblood += obj->level;
      subblood += obj->value[1];
      subblood += obj->value[2];
      subblood += obj->value[3];
      subblood += obj->value[4];

      subblood = subblood / 3;

      total += subblood;

      if (total < amount)
      return FALSE;

      if (obj->value[0] > amount) {
        obj->value[0] -= amount;
        return TRUE;
      }

      amount -= obj->value[0];
      obj->value[0] = 0;

      amount *= 3;

      for (; amount > 0;) {
        if (obj->level > 0) {
          amount--;
          obj->level--;
        }
        else if (obj->value[1] > 0) {
          amount--;
          obj->value[1]--;
        }
        else if (obj->value[2] > 0) {
          amount--;
          obj->value[2]--;
        }
        else if (obj->value[3] > 0) {
          amount--;
          obj->value[3]--;
        }
        else if (obj->value[4] > 0) {
          amount--;
          obj->value[4]--;
        }
      }

      return TRUE;
    }
    if (type == BLOOD_FAEBORN) {

      total = obj->value[1];
      subblood = 0;
      subblood += obj->level;
      subblood += obj->value[0];
      subblood += obj->value[2];
      subblood += obj->value[3];
      subblood += obj->value[4];

      subblood = subblood / 2;

      total += subblood;

      if (total < amount)
      return FALSE;

      if (obj->value[1] > amount) {
        obj->value[1] -= amount;
        return TRUE;
      }

      amount -= obj->value[1];
      obj->value[1] = 0;

      amount *= 2;

      for (; amount > 0;) {
        if (obj->level > 0) {
          amount--;
          obj->level--;
        }
        else if (obj->value[0] > 0) {
          amount--;
          obj->value[0]--;
        }
        else if (obj->value[2] > 0) {
          amount--;
          obj->value[2]--;
        }
        else if (obj->value[3] > 0) {
          amount--;
          obj->value[3]--;
        }
        else if (obj->value[4] > 0) {
          amount--;
          obj->value[4]--;
        }
      }

      return TRUE;
    }
    if (type == BLOOD_ANGELBORN) {

      total = obj->value[2];
      subblood = 0;
      subblood += obj->level;
      subblood += obj->value[0];
      subblood += obj->value[1];
      subblood += obj->value[3];
      subblood += obj->value[4];

      subblood = subblood / 2;

      total += subblood;

      if (total < amount)
      return FALSE;

      if (obj->value[2] > amount) {
        obj->value[2] -= amount;
        return TRUE;
      }

      amount -= obj->value[2];
      obj->value[2] = 0;

      amount *= 2;

      for (; amount > 0;) {
        if (obj->level > 0) {
          amount--;
          obj->level--;
        }
        else if (obj->value[0] > 0) {
          amount--;
          obj->value[0]--;
        }
        else if (obj->value[1] > 0) {
          amount--;
          obj->value[1]--;
        }
        else if (obj->value[3] > 0) {
          amount--;
          obj->value[3]--;
        }
        else if (obj->value[4] > 0) {
          amount--;
          obj->value[4]--;
        }
      }

      return TRUE;
    }
    if (type == BLOOD_DEMONBORN) {

      total = obj->value[3];
      subblood = 0;
      subblood += obj->level;
      subblood += obj->value[0];
      subblood += obj->value[2];
      subblood += obj->value[3];
      subblood += obj->value[4];

      subblood = subblood / 2;

      total += subblood;

      if (total < amount)
      return FALSE;

      if (obj->value[3] > amount) {
        obj->value[3] -= amount;
        return TRUE;
      }

      amount -= obj->value[3];
      obj->value[3] = 0;

      amount *= 2;

      for (; amount > 0;) {
        if (obj->level > 0) {
          amount--;
          obj->level--;
        }
        else if (obj->value[0] > 0) {
          amount--;
          obj->value[0]--;
        }
        else if (obj->value[2] > 0) {
          amount--;
          obj->value[2]--;
        }
        else if (obj->value[1] > 0) {
          amount--;
          obj->value[1]--;
        }
        else if (obj->value[4] > 0) {
          amount--;
          obj->value[4]--;
        }
      }

      return TRUE;
    }
    if (type == BLOOD_DEMIGOD) {

      total = obj->value[4];
      subblood = 0;
      subblood += obj->level;
      subblood += obj->value[0];
      subblood += obj->value[2];
      subblood += obj->value[3];
      subblood += obj->value[4];

      subblood = subblood / 2;

      total += subblood;

      if (total < amount)
      return FALSE;

      if (obj->value[4] > amount) {
        obj->value[4] -= amount;
        return TRUE;
      }

      amount -= obj->value[4];
      obj->value[4] = 0;

      amount *= 2;

      for (; amount > 0;) {
        if (obj->level > 0) {
          amount--;
          obj->level--;
        }
        else if (obj->value[0] > 0) {
          amount--;
          obj->value[0]--;
        }
        else if (obj->value[2] > 0) {
          amount--;
          obj->value[2]--;
        }
        else if (obj->value[3] > 0) {
          amount--;
          obj->value[3]--;
        }
        else if (obj->value[1] > 0) {
          amount--;
          obj->value[1]--;
        }
      }

      return TRUE;
    }
    if (type == BLOOD_REGULAR) {

      total = obj->value[1];
      subblood = 0;
      subblood += obj->level;
      subblood += obj->value[0];
      subblood += obj->value[2];
      subblood += obj->value[3];
      subblood += obj->value[4];

      total += subblood;

      if (total < amount)
      return FALSE;

      if (obj->level > amount) {
        obj->level -= amount;
        return TRUE;
      }

      amount -= obj->level;
      obj->level = 0;

      for (; amount > 0;) {
        if (obj->value[1] > 0) {
          amount--;
          obj->value[1]--;
        }

        else if (obj->value[0] > 0) {
          amount--;
          obj->value[0]--;
        }
        else if (obj->value[2] > 0) {
          amount--;
          obj->value[2]--;
        }
        else if (obj->value[3] > 0) {
          amount--;
          obj->value[3]--;
        }
        else if (obj->value[4] > 0) {
          amount--;
          obj->value[4]--;
        }
      }

      return TRUE;
    }
    return FALSE;
  }

  void enhance_item(OBJ_DATA *obj, int type, int value, int level) {
    int count = 1;
    EXTRA_DESCR_DATA *ed;
    char buf[MSL];

    for (ed = obj->extra_descr; ed; ed = ed->next) {
      if (is_name("+augmentone", ed->keyword))
      count++;
      if (is_name("+augmenttwo", ed->keyword))
      count++;
      if (is_name("+augmentthree", ed->keyword))
      count++;
      if (is_name("+augmentfour", ed->keyword))
      count++;
      if (is_name("+augmentfive", ed->keyword))
      count++;
    }

    if (type == ITEM_AMULET) {
      if (!IS_SET(obj->extra_flags, ITEM_AMULET))
      SET_BIT(obj->extra_flags, ITEM_AMULET);

    }
    else if (type == ITEM_ARTIFACTWEAPON) {
      if (!IS_SET(obj->extra_flags, ITEM_ARTIFACTWEAPON))
      SET_BIT(obj->extra_flags, ITEM_ARTIFACTWEAPON);

    }
    else if (type == ITEM_CHARM) {
      if (!IS_SET(obj->extra_flags, ITEM_CHARM))
      SET_BIT(obj->extra_flags, ITEM_CHARM);
    }

    sprintf(buf, "%d %d\n", value, level);

    ed = new_extra_descr();

    if (count == 1)
    ed->keyword = str_dup("+augmentone");
    else if (count == 2)
    ed->keyword = str_dup("+augmenttwo");
    else if (count == 3)
    ed->keyword = str_dup("+augmentthree");
    else if (count == 4)
    ed->keyword = str_dup("+augmentfour");
    else if (count == 5)
    ed->keyword = str_dup("+augmentfive");

    ed->next = obj->extra_descr;
    obj->extra_descr = ed;
    free_string(obj->extra_descr->description);
    obj->extra_descr->description = str_dup(buf);
  }

  _DOFUN(do_artificeweapon) {
    OBJ_DATA *obj;
    OBJ_DATA *obj_next;
    char arg1[MSL];
    char arg2[MSL];
    int i, level;
    OBJ_DATA *weapon = NULL;

    if (!is_gm(ch) && !higher_power(ch)) {
      send_to_char("Only SRs and Eidolons can do that.\n\r", ch);
      return;
    }

    argument = one_argument_nouncap(argument, arg1);
    argument = one_argument_nouncap(argument, arg2);

    level = atoi(arg2);

    if (level < 1 || level > 4) {
      send_to_char("Syntax artificeweapon (weapon) (level) (discipline)\n\r", ch);
      return;
    }
    if (!is_gm(ch) && !higher_power(ch) && level > 2) {
      send_to_char("Syntax artificeweapon (weapon) (level) (discipline)\n\r", ch);
      return;
    }

    if (!is_gm(ch) && !higher_power(ch)) {
      if (!workshop_room(ch->in_room)) {
        send_to_char("You need to be in an arcane workshop to do that.\n\r", ch);
        return;
      }
    }
    int cost = 0;
    if (level == 1)
    cost = 10000;
    if (level == 2)
    cost = 100000;


    int faccost = 0;
    int cashcost = 0;
    if (has_trust(ch, TRUST_RESOURCES, ch->faction) && clan_lookup(ch->faction)->resource >= 8000 + cost / 10 && can_spend_resources(clan_lookup(ch->faction)))
    faccost = cost / 10;
    else
    cashcost = cost * 100;

    if (is_gm(ch) || higher_power(ch)) {
      faccost = 0;
      cashcost = 0;
    }
    if (ch->money < cashcost && cashcost > 0) {
      printf_to_char(
      ch, "You'd need at least %d dollars in supplies to make that.\n\r", cashcost / 100);
      return;
    }
    if (faccost > 0 && clan_lookup(ch->faction)->resource < 8000 + faccost) {
      printf_to_char(ch, "That costs $%d in society resources.\n\r", faccost * 10);
      return;
    }
    if (faccost > 0 && !can_spend_resources(clan_lookup(ch->faction))) {
      send_to_char("You don't have enough resources for that.\n\r", ch);
      return;
    }

    for (obj = ch->carrying; obj != NULL; obj = obj_next) {
      obj_next = obj->next_content;

      if (IS_SET(obj->extra_flags, ITEM_WARDROBE))
      continue;

      if (obj->item_type != ITEM_WEAPON && obj->item_type != ITEM_RANGED)
      continue;

      if (is_name(arg1, obj->name)) {
        weapon = obj;
        break;
      }
    }

    if (weapon == NULL) {
      send_to_char("What do you want to artifice?\n\r", ch);
      return;
    }

    if (IS_SET(weapon->extra_flags, ITEM_AMULET) || IS_SET(weapon->extra_flags, ITEM_CHARM) || IS_SET(weapon->extra_flags, ITEM_ARTIFACTWEAPON)) {
      send_to_char("That item has already been artificed.\n\r", ch);
      return;
    }

    for (i = 0; i < DIS_USED; i++) {
      if (!str_cmp(argument, discipline_table[i].name)) {
        // ghostie check and limit for artifice weapon -Discordance
        if (is_ghost(ch)) {
          if (is_manifesting(ch)) {
            if (deplete_ghostpool(ch, GHOST_MANIFESTATION) == FALSE) {
              send_to_char("You can't muster the strength to manifest your will any more today.\n\r", ch);
              return;
            }
          }
          else {
            send_to_char("You must be prepared to manifest this power.\n\r", ch);
            return;
          }
        }
        if (discipline_table[i].pc == 0 && str_cmp(discipline_table[i].name, "custom")) {
          send_to_char("No such discipline.\n\r", ch);
          return;
        }
        enhance_item(weapon, ITEM_ARTIFACTWEAPON, discipline_table[i].vnum, level);
        if (cashcost > 0) {
          printf_to_char(
          ch, "For %d dollars in supplies you create an artifact.\n\r");
          ch->money -= cashcost;
        }
        else if (faccost > 0) {
          printf_to_char(ch, "For $%d society resources you create an artifact\n\r", faccost * 10);
          use_resources(faccost, ch->faction, ch, "creating an artifact");
        }
        else if (is_gm(ch) || higher_power(ch))
        send_to_char("Done.\n\r", ch);

        return;
      }
    }
    send_to_char("No such discipline.\n\r", ch);
  }

  _DOFUN(do_artificeamulet) {
    OBJ_DATA *obj;
    OBJ_DATA *obj_next;
    char arg1[MSL];
    char arg2[MSL];
    int i, level;
    OBJ_DATA *weapon = NULL;

    if (!is_gm(ch) && !higher_power(ch)) {
      send_to_char("Only SRs and Eidolons can do that.\n\r", ch);
      return;
    }

    argument = one_argument_nouncap(argument, arg1);
    argument = one_argument_nouncap(argument, arg2);

    level = atoi(arg2);

    if (level < 1 || level > 4) {
      send_to_char("Syntax artificeamulet (amulet) (level) (discipline)\n\r", ch);
      return;
    }
    if (!is_gm(ch) && !higher_power(ch) && level > 2) {
      send_to_char("Syntax artificeamulet (amulet) (level) (discipline)\n\r", ch);
      return;
    }

    if (!is_gm(ch) && !higher_power(ch)) {
      if (!workshop_room(ch->in_room)) {
        send_to_char("You need to be in an arcane workshop to do that.\n\r", ch);
        return;
      }
    }
    int cost;
    if (level == 1)
    cost = 10000;
    if (level == 2)
    cost = 100000;

    int faccost = 0;
    int cashcost = 0;
    if (has_trust(ch, TRUST_RESOURCES, ch->faction) && clan_lookup(ch->faction)->resource >= 8000 + faccost && can_spend_resources(clan_lookup(ch->faction)))
    faccost = cost / 10;
    else
    cashcost = cost * 100;

    if (is_gm(ch) || higher_power(ch)) {
      faccost = 0;
      cashcost = 0;
    }
    if (ch->money < cashcost && cashcost > 0) {
      printf_to_char(
      ch, "You'd need at least %d dollars in supplies to make that.\n\r", cashcost / 100);
      return;
    }
    if (faccost > 0 && clan_lookup(ch->faction)->resource < 8000 + faccost) {
      printf_to_char(ch, "That costs $%d in society resources.\n\r", faccost * 10);
      return;
    }
    for (obj = ch->carrying; obj != NULL; obj = obj_next) {
      obj_next = obj->next_content;

      if (IS_SET(obj->extra_flags, ITEM_WARDROBE))
      continue;

      if (obj->item_type != ITEM_JEWELRY)
      continue;

      if (is_name(arg1, obj->name)) {
        weapon = obj;
        break;
      }
    }

    if (weapon == NULL) {
      send_to_char("What do you want to artifice?\n\r", ch);
      return;
    }

    if (IS_SET(weapon->extra_flags, ITEM_AMULET) || IS_SET(weapon->extra_flags, ITEM_CHARM) || IS_SET(weapon->extra_flags, ITEM_ARTIFACTWEAPON)) {
      send_to_char("That item has already been artificed.\n\r", ch);
      return;
    }

    for (i = 0; i < DIS_USED; i++) {
      if (!str_cmp(argument, discipline_table[i].name)) {
        if (discipline_table[i].range > -1) {
          send_to_char("You don't have the gem you'd need to do that.\n\r", ch);
          return;
        }

        // ghostie check and limit for artifice amulet -Discordance
        if (is_ghost(ch)) {
          if (is_manifesting(ch)) {
            if (deplete_ghostpool(ch, GHOST_MANIFESTATION) == FALSE) {
              send_to_char("You can't muster the strength to manifest your will any more today.\n\r", ch);
              return;
            }
          }
          else {
            send_to_char("You must be prepared to manifest this power.\n\r", ch);
            return;
          }
        }
        if (discipline_table[i].pc == 0) {
          send_to_char("No such discipline.\n\r", ch);
          return;
        }

        enhance_item(weapon, ITEM_AMULET, discipline_table[i].vnum, level);
        if (cashcost > 0) {
          printf_to_char(
          ch, "For %d dollars in supplies you create an artifact.\n\r");
          ch->money -= cashcost;
        }
        else if (faccost > 0) {
          printf_to_char(ch, "For $%d society resources you create an artifact\n\r", faccost * 10);
          use_resources(faccost, ch->faction, ch, "creating an artifact");
        }
        else if (is_gm(ch) || higher_power(ch))
        send_to_char("Done.\n\r", ch);

        return;
      }
    }
    send_to_char("No such discipline.\n\r", ch);
  }

  _DOFUN(do_artificecharm) {
    OBJ_DATA *obj;
    OBJ_DATA *obj_next;
    char arg1[MSL];
    char arg2[MSL];
    int i, level;
    OBJ_DATA *weapon;

    if (!is_gm(ch) && !higher_power(ch)) {
      send_to_char("Only SRs and Eidolons can do that.\n\r", ch);
      return;
    }

    argument = one_argument_nouncap(argument, arg1);
    argument = one_argument_nouncap(argument, arg2);

    level = atoi(arg2);

    if (level < 1 || level > 4) {
      send_to_char("Syntax artificecharm (charm) (level) (discipline)\n\r", ch);
      return;
    }
    if (!is_gm(ch) && !higher_power(ch) && level > 2) {
      send_to_char("Syntax artificecharm (charm) (level) (discipline)\n\r", ch);
      return;
    }

    if (!is_gm(ch) && !higher_power(ch)) {
      if (!workshop_room(ch->in_room)) {
        send_to_char("You need to be in an arcane workshop to do that.\n\r", ch);
        return;
      }
    }
    int cost;
    if (level == 1)
    cost = 10000;
    if (level == 2)
    cost = 100000;
    int faccost = 0;
    int cashcost = 0;
    if (has_trust(ch, TRUST_RESOURCES, ch->faction) && clan_lookup(ch->faction)->resource >= 8000 + faccost && can_spend_resources(clan_lookup(ch->faction)))
    faccost = cost / 10;
    else
    cashcost = cost * 100;

    if (is_gm(ch) || higher_power(ch)) {
      faccost = 0;
      cashcost = 0;
    }
    if (ch->money < cashcost && cashcost > 0) {
      printf_to_char(
      ch, "You'd need at least %d dollars in supplies to make that.\n\r", cashcost / 100);
      return;
    }
    if (faccost > 0 && clan_lookup(ch->faction)->resource < 8000 + faccost) {
      printf_to_char(ch, "That costs $%d in society resources.\n\r", faccost * 10);
      return;
    }

    weapon = NULL;
    for (obj = ch->carrying; obj != NULL; obj = obj_next) {
      obj_next = obj->next_content;

      if (IS_SET(obj->extra_flags, ITEM_WARDROBE))
      continue;

      if (obj->item_type != ITEM_JEWELRY)
      continue;

      if (is_name(arg1, obj->name)) {
        weapon = obj;
        break;
      }
    }

    if (weapon == NULL) {
      send_to_char("What do you want to artifice?\n\r", ch);
      return;
    }

    if (IS_SET(weapon->extra_flags, ITEM_AMULET) || IS_SET(weapon->extra_flags, ITEM_CHARM) || IS_SET(weapon->extra_flags, ITEM_ARTIFACTWEAPON)) {
      send_to_char("That item has already been artificed.\n\r", ch);
      return;
    }

    for (i = 0; i < SKILL_USED; i++) {
      if (!str_cmp(argument, skill_table[i].name)) {
        // ghostie check and limit for artifice charm -Discordance
        if (is_ghost(ch)) {
          if (is_manifesting(ch)) {
            if (deplete_ghostpool(ch, GHOST_MANIFESTATION) == FALSE) {
              send_to_char("You can't muster the strength to manifest your will any more today.\n\r", ch);
              return;
            }
          }
          else {
            send_to_char("You must be prepared to manifest this power.\n\r", ch);
            return;
          }
        }
        if (illegal_augmentation(skill_table[i].vnum)) {
          send_to_char("That stat can't be magically augmented.\n\r", ch);
          return;
        }
        enhance_item(weapon, ITEM_CHARM, skill_table[i].vnum, level);
        if (cashcost > 0) {
          printf_to_char(
          ch, "For %d dollars in supplies you create an artifact.\n\r");
          ch->money -= cashcost;
        }
        else if (faccost > 0) {
          printf_to_char(ch, "For $%d society resources you create an artifact\n\r", faccost * 10);
          use_resources(faccost, ch->faction, ch, "creating an artifact");
        }
        else if (is_gm(ch) || higher_power(ch))
        send_to_char("Done.\n\r", ch);

        return;
      }
    }
    send_to_char("No such stat.\n\r", ch);
  }

  bool has_augment(CHAR_DATA *ch, int type) {
    int i, j;
    if (type == ITEM_CHARM) {
      for (i = 0; i < 10; i++) {
        if (ch->pcdata->augskill_timer[i] > 0)
        return TRUE;
      }
    }
    if (type == ITEM_ARTIFACTWEAPON) {
      for (i = 0; i < 10; i++) {
        if (ch->pcdata->augdisc_timer[i] > 0) {
          for (j = 0; j < DIS_USED; j++) {
            if (discipline_table[j].vnum == ch->pcdata->augdisc_disc[i] && discipline_table[j].range > -1)
            return TRUE;
          }
        }
      }
    }
    if (type == ITEM_AMULET) {
      for (i = 0; i < 10; i++) {
        if (ch->pcdata->augdisc_timer[i] > 0) {
          for (j = 0; j < DIS_USED; j++) {
            if (discipline_table[j].vnum == ch->pcdata->augdisc_disc[i] && discipline_table[j].range == -1)
            return TRUE;
          }
        }
      }
    }

    return FALSE;
  }

  int aug_timers(int level) {
    if (level == 1)
    return 60 * 3;
    if (level == 2)
    return 60 * 2;
    if (level == 3)
    return 60 * 4;
    if (level == 4)
    return 60 * 3;
    if (level == 5)
    return 60 * 2;

    return 60;
  }

  void augment_char(CHAR_DATA *ch, int type, int skill, int level) {
    int i;

    int cost = 200;
    if (ch->pcdata->spectre != 0)
    cost /= 2;
    if (battleground(ch->in_room))
    cost /= 2;
    if (type == ITEM_CHARM)
    cost /= 2;

    if (type == ITEM_ARTIFACTWEAPON) {
      for (i = 0; i < 10; i++) {
        if (ch->pcdata->augdisc_timer[i] <= 0) {
          ch->pcdata->augdisc_timer[i] = aug_timers(level);
          ch->pcdata->augdisc_disc[i] = skill;
          ch->pcdata->augdisc_level[i] = level * 5;
          send_to_char("Done.\n\r", ch);
          ch->lf_sused += cost;
          return;
        }
      }
    }
    if (type == ITEM_AMULET) {
      int percent = 100 * ch->hit / max_hp(ch);

      for (i = 0; i < 10; i++) {
        if (ch->pcdata->augdisc_timer[i] <= 0) {
          ch->pcdata->augdisc_timer[i] = aug_timers(level);
          ch->pcdata->augdisc_disc[i] = skill;
          ch->pcdata->augdisc_level[i] = level * 5;
          send_to_char("Done.\n\r", ch);
          ch->hit = percent * max_hp(ch) / 100;
          ch->lf_sused += cost;
          return;
        }
      }
    }
    if (type == ITEM_CHARM) {
      for (i = 0; i < 10; i++) {
        if (ch->pcdata->augskill_timer[i] <= 0) {
          ch->pcdata->augskill_timer[i] = aug_timers(level);
          ch->pcdata->augskill_skill[i] = skill;
          ch->pcdata->augskill_level[i] = level;
          send_to_char("Done.\n\r", ch);
          ch->lf_sused += cost;
          return;
        }
      }
    }

    return;
  }

  _DOFUN(do_activate) {
    int count = 0;
    OBJ_DATA *obj;
    OBJ_DATA *obj_next;
    OBJ_DATA *objcont;
    OBJ_DATA *objcont_next;
    char *buf;

    char arg1[MSL];
    char arg2[MSL];

    EXTRA_DESCR_DATA *ed;

    if (event_cleanse == 1)
    return;

    buf = str_dup("");

    count = 0;
    int charmcount = 0;
    for (obj = ch->carrying; obj != NULL; obj = obj_next) {
      obj_next = obj->next_content;

      if (IS_SET(obj->extra_flags, ITEM_WARDROBE))
      continue;

      if (IS_SET(obj->extra_flags, ITEM_ARTIFACTWEAPON))
      count++;
      if (IS_SET(obj->extra_flags, ITEM_AMULET))
      count++;
      if (IS_SET(obj->extra_flags, ITEM_CHARM))
      charmcount++;

      if (obj->item_type == ITEM_CONTAINER) {

        for (objcont = obj->contains; objcont != NULL; objcont = objcont_next) {
          objcont_next = objcont->next_content;

          if (IS_SET(objcont->extra_flags, ITEM_ARTIFACTWEAPON))
          count++;
          if (IS_SET(objcont->extra_flags, ITEM_AMULET))
          count++;
          if (IS_SET(objcont->extra_flags, ITEM_CHARM))
          charmcount++;
        }
      }
    }

    if (count > 1 + arcane_focus(ch)) {
      printf_to_char(ch, "You can only have at most %d weapon and amulet artifacts on your person and still make use of them.\n\r", 1 + arcane_focus(ch));
      return;
    }
    if (charmcount > 1 + arcane_focus(ch)) {
      printf_to_char(ch, "You can only have at most %d charm artifacts on your person and still make use of them.\n\r", 1 + arcane_focus(ch));
      return;
    }

    for (obj = ch->carrying; obj != NULL; obj = obj_next) {
      obj_next = obj->next_content;
      if (IS_SET(obj->extra_flags, ITEM_WARDROBE))
      continue;
      if (!IS_SET(obj->extra_flags, ITEM_CHARM) && !IS_SET(obj->extra_flags, ITEM_AMULET) && !IS_SET(obj->extra_flags, ITEM_ARTIFACTWEAPON))
      continue;
      if (is_name(argument, obj->name)) {
        if (IS_SET(obj->extra_flags, ITEM_CHARM)) {
          for (int i = 0; i < 10; i++) {
            if (ch->pcdata->augskill_timer[i] > 0) {
              send_to_char("You're already being magically enhanced.\n\r", ch);
              return;
            }
          }
          for (ed = obj->extra_descr; ed; ed = ed->next) {
            if (is_name("+augmentone", ed->keyword)) {
              free_string(buf);
              buf = str_dup(ed->description);
              buf = one_argument_nouncap(buf, arg1);
              buf = one_argument_nouncap(buf, arg2);
              if (in_world(ch) == WORLD_EARTH && atoi(arg2) > 2) {
                send_to_char("That will not work on earth.\n\r", ch);
                return;
              }
              augment_char(ch, ITEM_CHARM, atoi(arg1), atoi(arg2));
              act("The crystals in $n's $p start to emit a faint white light.", ch, obj, NULL, TO_ROOM);
              act("The crystals in your $p start to emit a faint white light.", ch, obj, NULL, TO_CHAR);
              return;
            }
          }
          return;
        }
        if (IS_SET(obj->extra_flags, ITEM_AMULET)) {
          for (int i = 0; i < 10; i++) {
            if (ch->pcdata->augdisc_timer[i] > 0) {
              send_to_char("You're already being magically enhanced.\n\r", ch);
              return;
            }
          }

          for (ed = obj->extra_descr; ed; ed = ed->next) {
            if (is_name("+augmentone", ed->keyword)) {
              free_string(buf);
              buf = str_dup(ed->description);

              buf = one_argument_nouncap(buf, arg1);
              buf = one_argument_nouncap(buf, arg2);
              if (in_world(ch) == WORLD_EARTH && atoi(arg2) > 2) {
                send_to_char("That will	not work on earth.\n\r", ch);
                return;
              }
              int hitperc = ch->hit * 1000 / max_hp(ch);
              augment_char(ch, ITEM_AMULET, atoi(arg1), atoi(arg2));
              ch->hit = max_hp(ch) * hitperc / 1000;
              act("The crystals in $n's $p start to emit a faint blue light.", ch, obj, NULL, TO_ROOM);
              act("The crystals in your $p start to emit a faint blue light.", ch, obj, NULL, TO_CHAR);
              return;
            }
          }
          return;
        }
        if (IS_SET(obj->extra_flags, ITEM_ARTIFACTWEAPON)) {
          for (int i = 0; i < 10; i++) {
            if (ch->pcdata->augdisc_timer[i] > 0) {
              send_to_char("You're already being magically enhanced.\n\r", ch);
              return;
            }
          }

          for (ed = obj->extra_descr; ed; ed = ed->next) {
            if (is_name("+augmentone", ed->keyword)) {
              free_string(buf);
              buf = str_dup(ed->description);

              buf = one_argument_nouncap(buf, arg1);
              buf = one_argument_nouncap(buf, arg2);
              if (in_world(ch) == WORLD_EARTH && atoi(arg2) > 2) {
                send_to_char("That will	not work on earth.\n\r", ch);
                return;
              }
              augment_char(ch, ITEM_ARTIFACTWEAPON, atoi(arg1), atoi(arg2));

              act("The crystals in $n's $p start to emit a faint red light.", ch, obj, NULL, TO_ROOM);
              act("The crystals in your $p start to emit a faint red light.", ch, obj, NULL, TO_CHAR);
              return;
            }
          }
          return;
        }
      }
    }
  }

  bool expert_ritualist(CHAR_DATA *ch) {
    if (get_skill(ch, SKILL_DEMONOLOGY) + get_skill(ch, SKILL_RITUALISM) >= 5)
    return TRUE;
    return FALSE;
  }
  bool targeted_ritual(char *argument) {
    if (!str_cmp(argument, "cleanse"))
    return FALSE;
    if (!str_cmp(argument, "mist"))
    return FALSE;
    if (!str_cmp(argument, "sacrifice"))
    return FALSE;
    if (!str_cmp(argument, "unbinding"))
    return FALSE;

    return TRUE;
  }
  bool targeted_ritual_vnum(int number) {
    if (number == RITUAL_CLEANSE)
    return FALSE;
    if (number == RITUAL_MIST)
    return FALSE;
    if (number == RITUAL_SACRIFICE)
    return FALSE;
    if (number == RITUAL_UNBINDING)
    return FALSE;

    return TRUE;
  }
  int ritual_cost(CHAR_DATA *ch, int ritual, CHAR_DATA *victim) {
    int mod = 100;
    int base = 2100;
    int skill = get_skill(ch, SKILL_RITUALISM);

    if(victim != NULL && institute_room(victim->in_room) && college_group(ch, FALSE) == COLLEGE_GOTH)
    skill += 1;

    if (skill == 5)
    base = 400;
    else if (skill == 4)
    base = 600;
    else if (skill == 3)
    base = 900;
    else if (skill == 2)
    base = 1200;
    else if (skill == 1)
    base = 2100;

    if (ritual == RITUAL_SUMMONING)
    mod = 100;
    if(ritual == RITUAL_SHADOWALK)
    mod = 25;
    if(ritual == RITUAL_DREADWATCHER)
    mod = 50;
    if (ritual == RITUAL_SANCTUARY)
    mod = 200;
    if (ritual == RITUAL_MADNESS)
    mod = 150;
    if (ritual == RITUAL_PERSECUTION)
    mod = 150;
    if (ritual == RITUAL_PROTECT)
    mod = 150;
    if (ritual == RITUAL_BANISH)
    mod = 200;
    if (ritual == RITUAL_SILENCE)
    mod = 25;
    if (ritual == RITUAL_SHADOWCLOAK)
    mod = 25;
    if (ritual == RITUAL_AGETHEFT)
    mod = 150;
    if (ritual == RITUAL_ILLNESS)
    mod = 100;
    if (ritual == RITUAL_ARTHRITIS)
    mod = 75;
    if (ritual == RITUAL_SACRIFICE)
    mod = 25;
    if (ritual == RITUAL_PURIFY)
    mod = 200;
    if (ritual == RITUAL_DREAMIDENTITY)
    mod = 100;
    if (ritual == RITUAL_DREAM)
    mod = 60;
    if (ritual == RITUAL_DREAMSNARE)
    mod = 100;
    if (ritual == RITUAL_DREAMBELIEF)
    mod = 75;
    if (ritual == RITUAL_SHIELDBREAK)
    mod = 75;
    if (ritual == RITUAL_TECHHEX)
    mod = 25;
    if (ritual == RITUAL_MIST)
    mod = 25;
    if (ritual == RITUAL_CORRUPT)
    mod = 50;
    if (ritual == RITUAL_SCRY)
    mod = 25;
    if (ritual == RITUAL_HAUNT)
    mod = 80;
    if (ritual == RITUAL_TRACE)
    mod = 50;
    if (ritual == RITUAL_SEXCHANGE)
    mod = 150;
    if(ritual == RITUAL_PREDATE)
    mod = 25;

    base = base * mod / 100;

    return base;
  }

  int ritual_debuff_power(CHAR_DATA *ch, CHAR_DATA *victim) {
    int chscore = UMIN(get_tier(ch), arcane_focus(ch)) + 1;
    int vicscore = get_tier(victim);

    if(victim != NULL && institute_room(victim->in_room) && college_group(ch, FALSE) == COLLEGE_GOTH)
    chscore += 1;

    int modifier = 100 * chscore / vicscore;

    modifier =
    modifier * arcane_lifeforce(ch, TRUE) / arcane_lifeforce(victim, FALSE);

    if (victim->modifier == MODIFIER_CURSED)
    modifier = modifier * 3 / 2;

    modifier = UMAX(15, modifier);
    modifier = UMIN(300, modifier);

    return modifier;
  }
  int ritual_buff_power(CHAR_DATA *ch) {
    int chscore = UMIN(get_tier(ch), arcane_focus(ch)) + 1;
    int vicscore = 2;
    int modifier = 100 * chscore / vicscore;

    modifier = modifier * arcane_lifeforce(ch, TRUE) / 100;

    modifier = UMAX(15, modifier);
    modifier = UMIN(300, modifier);

    return modifier;
  }

  int ritual_timer(CHAR_DATA *ch, CHAR_DATA *victim) {
    int skill = get_skill(ch, SKILL_INCANTATION);
    if(victim != NULL && institute_room(victim->in_room) && college_group(ch, FALSE) == COLLEGE_GOTH)
    skill += 2;

    if (skill >= 4)
    return 7;
    else if (skill >= 3)
    return 15;
    else if (skill >= 2)
    return 30;
    else if (skill >= 1)
    return 60;

    return 120;
  }

  _DOFUN(do_ritual) {
    char arg1[MSL];
    char arg2[MSL];

    if (event_cleanse == 1)
    return;

    if (!str_cmp(argument, "terminate")) {
      free_string(ch->pcdata->maintained_target);
      ch->pcdata->maintained_target = str_dup("");
      send_to_char("You stop maintaining your curse.\n\r", ch);
      return;
    }

    argument = one_argument_nouncap(argument, arg1);
    argument = one_argument_nouncap(argument, arg2);

    if (ch->race == RACE_CIVILIAN)
    return;

    if (is_animal(ch)) {
      send_to_char("That might be tricky in your current form.\n\r", ch);
      return;
    }
    if (is_neutralized(ch)) {
      send_to_char("You can't do that right now.\n\r", ch);
      return;
    }
    if (guestmonster(ch)) {
      send_to_char("That is beyond your ken.\n\r", ch);
      return;
    }

    if (public_room(ch->in_room)) {
      send_to_char("It's a bit public for black magic.\n\r", ch);
      return;
    }
    if (is_gm(ch))
    return;

    if (ch->pcdata->overworked > 0) {
      send_to_char("You are too tired.\n\r", ch);
      return;
    }

    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (is_helpless(ch)) {
      send_to_char("Not now.\n\r", ch);
      return;
    }
    if (room_hostile(ch->in_room) || is_pinned(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (is_ghost(ch)) {
      return;
    }

    if (get_skill(ch, SKILL_RITUALISM) < 1) {
      send_to_char("You don't know how to perform a ritual.\n\r", ch);
      return;
    }
    char throwaway[MSL];
    bool maintained = FALSE;
    if (safe_strlen(argument) > 3 && !str_prefix(argument, "maintain")) {
      if (arcane_focus(ch) < 1 && get_skill(ch, SKILL_RITUALISM) < 2)
      {
        send_to_char("You lack the mystical knowledge to do that.\n\r", ch);
        return;
      }
      argument = one_argument_nouncap(argument, throwaway);
      maintained = TRUE;
      log_string(throwaway);
    }
    CHAR_DATA *victim;
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    Buffer outbuf;
    char buf[MSL];

    if (targeted_ritual(arg1)) {
      d.original = NULL;
      if ((victim = get_char_world_pc(arg2)) != NULL) // Victim is online.
      online = TRUE;
      else if ((victim = get_char_haven(ch, arg2)) != NULL)
      online = TRUE;
      else {
        log_string("DESCRIPTOR: Ritul");

        if (!load_char_obj(&d, arg2)) {
          send_to_char("You can't find them.\n\r", ch);
          return;
        }

        sprintf(buf, "%s%s", PLAYER_DIR, capitalize(arg2));
        victim = d.character;
      }
      if (IS_NPC(victim)) {
        send_to_char("You can't find them.\n\r", ch);
        if (!online)
        free_char(victim);
        return;
      }
      if (higher_power(ch) && power_bound(ch) && !IS_NPC(victim) && str_cmp(ch->pcdata->place, victim->pcdata->place)) {
        send_to_char("Your power is bound.\n\r", ch);
        return;
      }

      if (IS_FLAG(ch->act, PLR_SINSPIRIT)) {
        if (ch->pcdata->spirit_type == SPIRIT_JUSTICARUM && !justi_vuln(victim)) {
          send_to_char("They're not vulnerable to your sin.\n\r", ch);
          if (!online)
          free_char(victim);
          return;
        }
        if (ch->pcdata->spirit_type == SPIRIT_MALEFICARUM && !mali_vuln(victim)) {
          send_to_char("They're not vulnerable to your sin.\n\r", ch);
          if (!online)
          free_char(victim);
          return;
        }
      }
      if (is_super(ch) != is_super(victim) && event_aegis == 1) {
        send_to_char("You can't find them.\n\r", ch);
        if (!online)
        free_char(victim);
        return;
      }
    }

    ch->pcdata->process_target = NULL;
    if (victim != NULL && maintained == TRUE) {
      free_string(ch->pcdata->maintained_target);
      ch->pcdata->maintained_target = str_dup("casting");
      send_to_char("You attempt to maintain the ritual.\n\r", ch);
    }
    if (!str_cmp(arg1, "dreambelief")) {
      char world[MSL];
      argument = one_argument_nouncap(argument, world);
      if (fetch_fantasy(ch, atoi(world)) == NULL || fetch_fantasy(ch, atoi(world))->active == FALSE) {
        send_to_char("No such dreamworld.\n\r", ch);
        return;
      }
      if (fetch_fantasy(ch, atoi(world))->highlight_time == 0) {
        send_to_char("That world isn't close enough right now.\n\r", ch);
        return;
      }

      free_string(ch->pcdata->ritual_dreamworld);
      ch->pcdata->ritual_dreamworld =
      str_dup(fetch_fantasy(ch, atoi(world))->name);

      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_DREAMBELIEF;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);
      free_string(ch->pcdata->process_argumenttwo);
      ch->pcdata->process_argumenttwo = str_dup(argument);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "summoning")) {
      if (!has_binding_circle(ch->in_room)) {
        send_to_char("You should create a binding circle first(create a place with the name 'binding circle')\n\r", ch);
        return;
      }
      if (higher_power(ch)) {
        send_to_char("Maybe get an acolyte to do that instead.\n\r", ch);
        return;
      }
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_SUMMONING;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);
      free_string(ch->pcdata->process_argumenttwo);
      ch->pcdata->process_argumenttwo = str_dup(argument);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "dreamidentity")) {
      char world[MSL];
      argument = one_argument_nouncap(argument, world);
      if (fetch_fantasy(ch, atoi(world)) == NULL || fetch_fantasy(ch, atoi(world))->active == FALSE) {
        send_to_char("No such dreamworld.\n\r", ch);
        return;
      }
      if (fetch_fantasy(ch, atoi(world))->highlight_time == 0) {
        send_to_char("That world isn't close enough right now.\n\r", ch);
        return;
      }

      free_string(ch->pcdata->ritual_dreamworld);
      ch->pcdata->ritual_dreamworld =
      str_dup(fetch_fantasy(ch, atoi(world))->name);

      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_DREAMIDENTITY;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);
      free_string(ch->pcdata->process_argumenttwo);
      ch->pcdata->process_argumenttwo = str_dup(argument);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "imprint")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_IMPRINT;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);
      free_string(ch->pcdata->process_argumenttwo);
      ch->pcdata->process_argumenttwo = str_dup(argument);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "bodyimprint")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_IMPRINTBODY;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);
      free_string(ch->pcdata->process_argumenttwo);
      ch->pcdata->process_argumenttwo = str_dup(argument);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "sacrifice")) {
      if (get_skill(ch, SKILL_RITUALISM) < 2) {
        send_to_char("You don't have enough ritualism skill to do that.\n\r", ch);
        return;
      }
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_SACRIFICE;

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "sleepwalk")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_SLEEPWALK;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);
      free_string(ch->pcdata->process_argumenttwo);
      ch->pcdata->process_argumenttwo = str_dup(argument);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "agetheft")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_AGETHEFT;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "silence")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_SILENCE;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "shadowwalk") || !str_cmp(arg1, "shadowalk")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_SHADOWALK;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "dreadwatcher")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_DREADWATCHER;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "decay")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_DECAY;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "naturalizeweather")) {

      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_NATURALIZEWEATHER;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);
      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "naturalizetime")) {

      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_NATURALIZETIME;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);
      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "localizedweather")) {
      if (str_cmp(argument, "clear") && str_cmp(argument, "rain") && str_cmp(argument, "cloudy") && str_cmp(argument, "hail") && str_cmp(argument, "snow")) {
        send_to_char("Syntax: ritual localizedweather (target) (clear/rain/hail/snow)\n\r", ch);
        return;
      }
      if (is_guest(ch) && ch->pcdata->guest_type != GUEST_NIGHTMARE)
      return;
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_LOCALIZEDWEATHER;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);
      free_string(ch->pcdata->process_argumenttwo);
      ch->pcdata->process_argumenttwo = str_dup(argument);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);
      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "temperatureshift")) {
      if (!is_number(argument) || atoi(argument) == 0) {
        send_to_char("Syntax: ritual temperatureshift (target) (temperature offset F)\n\r", ch);
        return;
      }
      if (is_guest(ch) && ch->pcdata->guest_type != GUEST_NIGHTMARE)
      return;

      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_TEMPERATURESHIFT;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);
      free_string(ch->pcdata->process_argumenttwo);
      ch->pcdata->process_argumenttwo = str_dup(argument);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);
      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "freezetemperature")) {
      if (!is_number(argument) || atoi(argument) == 0) {
        send_to_char("Syntax: ritual freezetemperature (target) (temperature F)\n\r", ch);
        return;
      }
      if (is_guest(ch) && ch->pcdata->guest_type != GUEST_NIGHTMARE)
      return;

      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_FREEZETEMPERATURE;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);
      free_string(ch->pcdata->process_argumenttwo);
      ch->pcdata->process_argumenttwo = str_dup(argument);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);
      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "timeshift")) {
      if (!is_number(argument) || atoi(argument) == 0) {
        send_to_char("Syntax: ritual timeshift (target) (hour change)\n\r", ch);
        return;
      }
      if (is_guest(ch) && ch->pcdata->guest_type != GUEST_NIGHTMARE)
      return;

      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_TIMESHIFT;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);
      free_string(ch->pcdata->process_argumenttwo);
      ch->pcdata->process_argumenttwo = str_dup(argument);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);
      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "freezetime")) {
      if (!is_number(argument) || atoi(argument) == 0) {
        send_to_char("Syntax: ritual freezetime (target) (hour)\n\r", ch);
        return;
      }
      if (is_guest(ch) && ch->pcdata->guest_type != GUEST_NIGHTMARE)
      return;
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_FREEZETIME;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);
      free_string(ch->pcdata->process_argumenttwo);
      ch->pcdata->process_argumenttwo = str_dup(argument);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);
      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "encroachment")) {
      if (is_guest(ch) && ch->pcdata->guest_type != GUEST_NIGHTMARE)
      return;

      PROP_TYPE *prop = in_prop(victim);
      if(prop == NULL)
      {
        send_to_char("They are not in a property.\n\r", ch);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }

        return;
      }
      if(prop->last_encroach > current_time - (3600*24*5))
      {
        send_to_char("A property can only be targeted by this ritual once every five days.\n\r", ch);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
        return;
      }



      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_ENCROACHMENT;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);
      free_string(ch->pcdata->process_argumenttwo);
      ch->pcdata->process_argumenttwo = str_dup(argument);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);
      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "nightmareshield")) {
      if (is_guest(ch) && ch->pcdata->guest_type != GUEST_NIGHTMARE)
      return;
      if (higher_power(ch))
      return;
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_SHROUDSHIELD;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "shieldbreak")) {
      if (is_guest(ch) && ch->pcdata->guest_type != GUEST_NIGHTMARE)
      return;
      if (higher_power(ch))
      return;
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_SHIELDBREAK;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "illness")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_ILLNESS;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "arthritis")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_ARTHRITIS;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "purify")) {
      if (is_guest(ch) && ch->pcdata->guest_type != GUEST_NIGHTMARE)
      return;
      if (higher_power(ch))
      return;
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_PURIFY;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }

    if (!str_cmp(arg1, "veil")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_CLOAKING;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "techhex")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_TECHHEX;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "shadowcloak")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_SHADOWCLOAK;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);
      save_char_obj(victim, FALSE, FALSE);
      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "cleanse")) {
      if (is_guest(ch) && ch->pcdata->guest_type != GUEST_NIGHTMARE)
      return;
      if (higher_power(ch))
      return;
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_CLEANSE;

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }

    if (!str_cmp(arg1, "dream")) {
      char world[MSL];
      argument = one_argument_nouncap(argument, world);
      if (fetch_fantasy(ch, atoi(world)) == NULL || fetch_fantasy(ch, atoi(world))->active == FALSE) {
        send_to_char("No such dreamworld.\n\r", ch);
        return;
      }
      free_string(ch->pcdata->ritual_dreamworld);
      ch->pcdata->ritual_dreamworld =
      str_dup(fetch_fantasy(ch, atoi(world))->name);
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_DREAM;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);
      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);
      save_char_obj(victim, FALSE, FALSE);
      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "dreamsnare")) {
      char world[MSL];
      argument = one_argument_nouncap(argument, world);
      if (fetch_fantasy(ch, atoi(world)) == NULL || fetch_fantasy(ch, atoi(world))->active == FALSE) {
        send_to_char("No such dreamworld.\n\r", ch);
        return;
      }
      free_string(ch->pcdata->ritual_dreamworld);
      ch->pcdata->ritual_dreamworld =
      str_dup(fetch_fantasy(ch, atoi(world))->name);
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_DREAMSNARE;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);
      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);
      save_char_obj(victim, FALSE, FALSE);
      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "sanctuary")) {
      if (is_guest(ch) && ch->pcdata->guest_type != GUEST_NIGHTMARE)
      return;
      if (higher_power(ch))
      return;
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_SANCTUARY;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);
      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);
      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "scry")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_SCRY;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "trace")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_TRACE;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "predate")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_PREDATE;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }

    if (!str_cmp(arg1, "sexchange")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_SEXCHANGE;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "mute")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_MUTE;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "corrupt")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_CORRUPT;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "lunacy")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_LUNACY;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "deafen")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_DEAFEN;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "lure")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_LURE;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "madness")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_MADNESS;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "persecution")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_PERSECUTION;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }

    if (!str_cmp(arg1, "enfeeble")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_ENFEEBLE;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "haunt")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_HAUNT;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "protect")) {
      if (is_guest(ch) && ch->pcdata->guest_type != GUEST_NIGHTMARE)
      return;
      if (higher_power(ch))
      return;
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_PROTECT;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "raiseward")) {
      if (is_guest(ch) && ch->pcdata->guest_type != GUEST_NIGHTMARE)
      return;
      if (higher_power(ch))
      return;
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_RAISEWARD;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "lowerward")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_LOWERWARD;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "mist")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_MIST;

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "banish")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_BANISH;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      conclude_process(ch, PROCESS_RITUAL);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);

      return;
    }
    if (!str_cmp(arg1, "binding")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_BINDING;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      conclude_process(ch, PROCESS_RITUAL);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;

    }
    if (!str_cmp(arg1, "unbinding")) {
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_UNBINDING;

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
    if (!str_cmp(arg1, "mindward")) {
      if (is_guest(ch) && ch->pcdata->guest_type != GUEST_NIGHTMARE)
      return;
      if (higher_power(ch))
      return;
      ch->pcdata->process = PROCESS_RITUAL;
      ch->pcdata->process_timer = ritual_timer(ch, victim);
      ch->pcdata->process_subtype = RITUAL_MINDWARD;
      free_string(ch->pcdata->process_argumentone);
      ch->pcdata->process_argumentone = str_dup(victim->name);

      act("You begin to perform the ritual.", ch, NULL, NULL, TO_CHAR);
      act("$n begins a ritual.", ch, NULL, NULL, TO_ROOM);

      save_char_obj(victim, FALSE, FALSE);

      if (!online)
      free_char(victim);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
      return;
    }
  }

  _DOFUN(do_haunt) {
    char arg1[MSL];

    argument = one_argument_nouncap(argument, arg1);

    CHAR_DATA *victim;

    if ((victim = get_char_world_pc(arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (IS_NPC(victim) || str_cmp(ch->name, victim->pcdata->haunter) || victim->pcdata->haunt_timer <= 0) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }
    ch->pcdata->watching += 1200;

    printf_to_char(victim, "%s\n\r", argument);
    send_to_char("Sent.\n\r", ch);
    rpreward(ch, argument, TRUE, 2);
  }

  void wound_char(CHAR_DATA *victim, int type) {
    type += victim->wounds;
    sympathy_pain(victim->pcdata->pledge, type);

    if (type == 1) {
      victim->wounds = 1;
      victim->heal_timer = 30000;
    }
    else if (type == 2 || (type > 2 && get_skill(victim, SKILL_IMMORTALITY) > 1)) {
      victim->wounds = 2;
      victim->heal_timer = 115000;
      miscarriage(victim, FALSE);
    }
    else if (type == 3) {
      victim->wounds = 3;
      victim->heal_timer = 4300;
      victim->death_timer = 720;
      miscarriage(victim, FALSE);
    }
  }
  
  void wound_char_absolute(CHAR_DATA *victim, int type) {
    type = UMAX(type, victim->wounds);

    sympathy_pain(victim->pcdata->pledge, type);

    if (type == 1) {
      victim->wounds = 1;
      victim->heal_timer = 30000;
    }
    else if (type == 2 || (type > 2 && get_skill(victim, SKILL_IMMORTALITY) > 1)) {
      victim->wounds = 2;
      victim->heal_timer = 115000;
      miscarriage(victim, FALSE);
    }
    else if (type == 3) {
      victim->wounds = 3;
      victim->heal_timer = 4300;
      victim->death_timer = 720;
      miscarriage(victim, FALSE);
    }
  }
  
  void wound_char_noregen(CHAR_DATA *victim, int type) {
    type += victim->wounds;
    sympathy_pain(victim->pcdata->pledge, type);
    if (type == 1) {
      victim->wounds = 1;
      victim->heal_timer = 30000;
    }
    else if (type == 2 || (type > 2 && get_skill(victim, SKILL_IMMORTALITY) > 1)) {
      victim->wounds = 2;
      victim->heal_timer = 115000;
      miscarriage(victim, FALSE);
    }
    else if (type == 3) {
      victim->wounds = 3;
      victim->heal_timer = 4300;
      victim->death_timer = 720;
      miscarriage(victim, FALSE);
    }
    if (type != 3) {
      if (get_skill(victim, SKILL_REGEN) >= 3)
      victim->heal_timer *= 42;
      else if (get_skill(victim, SKILL_REGEN) >= 1)
      victim->heal_timer *= 12;
    }
  }

  _DOFUN(do_wound) {
    CHAR_DATA *victim;
    char arg1[MSL];
    char arg2[MSL];

    argument = one_argument_nouncap(argument, arg1);
    argument = one_argument_nouncap(argument, arg2);

    if (guestmonster(ch))
    return;

    if ((victim = get_char_world_pc(arg1)) != NULL && victim->pcdata->ghost_room == ch->in_room->vnum && (IS_FLAG(victim->act, PLR_GHOSTWALKING) || victim->pcdata->spectre > 0)) {
      if (is_helpless(ch)) {
        send_to_char("You can't do that.\n\r", ch);
        return;
      }

      if (is_ghost(ch)) {
        send_to_char("You can't get a grip on them.\n\r", ch);
        return;
      }

      if (room_hostile(ch->in_room)) {
        start_hostilefight(ch);
        return;
      }
      if (!IS_NPC(victim) && victim->pcdata->trance > 0)
      victim->pcdata->trance = -20;

      if (!str_cmp(arg2, "mild")) {
        wound_char_absolute(victim, 1);
        victim->pcdata->mark_timer[1] = 100;
        free_string(victim->pcdata->mark[1]);
        victim->pcdata->mark[1] = str_dup(argument);
        act("You give them a mild wound.", ch, NULL, NULL, TO_CHAR);
        act("$n gives $N a wound.", ch, NULL, victim, TO_NOTVICT);
        act("You feel a sudden, mysterious pain.", ch, NULL, victim, TO_VICT);
        return;
      }
      else if (!str_cmp(arg2, "severe")) {
        if (is_werewolf(ch) && is_animal(ch) && full_moon() == TRUE && (sunphase(NULL) < 2 || sunphase(NULL) == 7)) {
          if (victim->wounds < 2 && number_percent() % 6 == 0 && get_tier(victim) < 3 && !is_werewolf(victim)
          && !is_vampire(victim)) {
            if (get_tier(victim) == 1) {
              victim->race = RACE_NEWWEREWOLF;
              victim->modifier = MODIFIER_NEW;
            }
            else if (get_tier(victim) == 2) {
              victim->race = RACE_NEWWEREWOLF;
              victim->modifier = 0;
            }
            else if (get_tier(victim) == 3) {
              victim->race = RACE_NEWWEREWOLF;
              victim->modifier = MODIFIER_STRONG;
            }
          }
        }
        else {
          if (under_understanding(victim, ch)) {
            wound_char_absolute(victim, 1);
            victim->pcdata->mark_timer[1] = 100;
            free_string(victim->pcdata->mark[1]);
            victim->pcdata->mark[1] = str_dup(argument);
            act("You give them a severe wound.", ch, NULL, NULL, TO_CHAR);
            act("$n gives $N a wound.", ch, NULL, victim, TO_NOTVICT);
            act("You feel a sharp, mysterious pain.", ch, NULL, victim, TO_VICT);
            return;
          }
        }

        wound_char_absolute(victim, 2);
        victim->pcdata->mark_timer[2] = 100;
        free_string(victim->pcdata->mark[2]);
        victim->pcdata->mark[2] = str_dup(argument);
        act("You give them a severe wound.", ch, NULL, NULL, TO_CHAR);
        act("$n gives $N a wound.", ch, NULL, victim, TO_NOTVICT);
        act("You feel a sharp, mysterious pain.", ch, NULL, victim, TO_VICT);
        return;
      }
      else if (!str_cmp(arg2, "critical")) {
        if (under_understanding(victim, ch)) {
          send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
          return;
        }
        if (under_limited(victim, ch)) {
          send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
          return;
        }
        if (higher_power(ch) || higher_power(victim))
        return;

        if (ch->played / 3600 < 10)
        return;

        critplayer(ch, victim);
        wound_char_absolute(victim, 3);
        victim->pcdata->mark_timer[3] = 100;
        free_string(victim->pcdata->mark[3]);
        victim->pcdata->mark[3] = str_dup(argument);
        act("You give them a critical wound.", ch, NULL, NULL, TO_CHAR);
        act("$n gives $N a critical wound.", ch, NULL, victim, TO_NOTVICT);
        act("You feel a dreadful mysterious pain.", ch, NULL, victim, TO_VICT);
        if (!IS_NPC(victim))
        critplayer(ch, victim);

        return;
      }
      return;
    }

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (is_pinned(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (!IS_NPC(victim) && victim->pcdata->trance > 0)
    victim->pcdata->trance = -20;

    if (!is_helpless(victim)) {
      send_to_char("You'd have to subdue them first.\n\r", ch);
      return;
    }

    if (is_ghost(victim)) {
      send_to_char("Wounding the dead is not so easy.", ch);
      return;
    }

    if (is_ghost(ch)) {
      send_to_char("Wounding the living is not so easy any more.", ch);
    }

    captive_command(ch, victim);

    if (!str_cmp(arg2, "mild")) {
      wound_char_absolute(victim, 1);
      victim->pcdata->mark_timer[1] = 100;
      free_string(victim->pcdata->mark[1]);
      victim->pcdata->mark[1] = str_dup(argument);
      act("You give them a mild wound.", ch, NULL, NULL, TO_CHAR);
      act("$n gives $N a wound.", ch, NULL, victim, TO_NOTVICT);
      act("$n gives you a mild wound.", ch, NULL, victim, TO_VICT);
      return;
    }
    else if (!str_cmp(arg2, "severe")) {
      if (is_werewolf(ch) && is_animal(ch) && full_moon() == TRUE && (sunphase(NULL) < 2 || sunphase(NULL) == 7)) {
        if (victim->wounds < 2 && number_percent() % 6 == 0 && get_tier(victim) < 3 && !is_werewolf(victim)
        && !is_vampire(victim)) {
          if (get_tier(victim) == 1) {
            victim->race = RACE_NEWWEREWOLF;
            victim->modifier = MODIFIER_NEW;
          }
          else if (get_tier(victim) == 2) {
            victim->race = RACE_NEWWEREWOLF;
            victim->modifier = 0;
          }
          else if (get_tier(victim) == 3) {
            victim->race = RACE_NEWWEREWOLF;
            victim->modifier = MODIFIER_STRONG;
          }
        }
      }
      else {

        if (under_understanding(victim, ch)) {
          wound_char_absolute(victim, 1);
          victim->pcdata->mark_timer[1] = 100;
          free_string(victim->pcdata->mark[1]);
          victim->pcdata->mark[1] = str_dup(argument);
          act("You give them a severe wound.", ch, NULL, NULL, TO_CHAR);
          act("$n gives $N a wound.", ch, NULL, victim, TO_NOTVICT);
          act("$n gives you a mild wound.", ch, NULL, victim, TO_VICT);

          return;
        }
      }
      wound_char_absolute(victim, 2);
      victim->pcdata->mark_timer[2] = 100;
      free_string(victim->pcdata->mark[2]);
      victim->pcdata->mark[2] = str_dup(argument);
      act("You give them a severe wound.", ch, NULL, NULL, TO_CHAR);
      act("$n gives $N a wound.", ch, NULL, victim, TO_NOTVICT);
      act("$n gives you a severe wound.", ch, NULL, victim, TO_VICT);

      return;
    }
    else if (!str_cmp(arg2, "critical")) {
      if (under_understanding(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }
      if (under_limited(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }

      critplayer(ch, victim);
      wound_char_absolute(victim, 3);
      victim->pcdata->mark_timer[3] = 100;
      free_string(victim->pcdata->mark[3]);
      victim->pcdata->mark[3] = str_dup(argument);
      act("You give them a critical wound.", ch, NULL, NULL, TO_CHAR);
      act("$n gives $N a critical wound.", ch, NULL, victim, TO_NOTVICT);
      act("$n gives you a critical wound.", ch, NULL, victim, TO_VICT);
      if (!IS_NPC(victim))
      critplayer(ch, victim);

      return;
    }
    else
    send_to_char("Syntax: Wound (person) (mild/severe/critical) (message)\n\r", ch);
  }
  _DOFUN(do_mark) {
    CHAR_DATA *victim;
    char arg1[MSL];

    argument = one_argument_nouncap(argument, arg1);

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (is_pinned(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (!is_helpless(victim)) {
      send_to_char("You'd have to subdue them first.\n\r", ch);
      return;
    }

    if (is_ghost(victim)) {
      send_to_char("They are as the day they died.", ch);
      return;
    }

    // ghostie check and limit for mark -Discordance
    if (is_ghost(ch)) {
      if (is_manifesting(ch)) {
        if (deplete_ghostpool(ch, GHOST_MANIFESTATION) == FALSE) {
          send_to_char("You can't muster the strength to project your will any more today.\n\r", ch);
          return;
        }
      }
      else {
        send_to_char("You must be prepared to manifest this power.\n\r", ch);
        return;
      }
    }

    captive_command(ch, victim);

    char mess[MSL];
    victim->pcdata->mark_timer[0] = 12 * 60 * 5;
    if (safe_strlen(victim->pcdata->mark[0]) > 3)
    sprintf(mess, "%s and %s", victim->pcdata->mark[0], argument);
    else
    sprintf(mess, "%s", argument);
    free_string(victim->pcdata->mark[0]);
    victim->pcdata->mark[0] = str_dup(mess);

    act("You mark them.", ch, NULL, NULL, TO_CHAR);
    act("$n marks $N.", ch, NULL, victim, TO_NOTVICT);
    act("$n marks you.", ch, NULL, victim, TO_VICT);
  };

  int power_compare(CHAR_DATA *ch, CHAR_DATA *victim) {

    if (ch->race == RACE_CIVILIAN && victim->race == RACE_CIVILIAN)
    return 100;

    if (ch->race == RACE_CIVILIAN && victim->race != RACE_CIVILIAN)
    return 1;

    if (ch->race != RACE_CIVILIAN && victim->race == RACE_CIVILIAN)
    return 1000;


    if (!same_player(ch, victim) && victim->pcdata->account != NULL && IS_FLAG(victim->pcdata->account->flags, ACCOUNT_SHADOWBAN))
    return 1000;

    if (!same_player(ch, victim) && ch->pcdata->account != NULL && IS_FLAG(ch->pcdata->account->flags, ACCOUNT_SHADOWBAN))
    return 1;

    if (!IS_NPC(victim) && victim->pcdata->trance > 0)
    victim->pcdata->trance = -20;

    if (is_helpless(victim))
    return 1000;

    int chspent = UMAX(ch->spentexp, 1);
    int vicspent = UMAX(victim->spentexp, 1);


    if(overwhelm(ch, victim))
    chspent *= 5;

    if (guestmonster(ch) || higher_power(ch))
    chspent *= 10;
    if (guestmonster(victim) || higher_power(victim))
    vicspent *= 10;
    if (IS_FLAG(victim->act, PLR_GUEST) && victim->pcdata->guest_type == GUEST_CARDINAL)
    vicspent *= 10;

    if (event_cleanse == 1) {
      chspent = UMIN(chspent, 250000);
      vicspent = UMIN(vicspent, 250000);
    }
    chspent /= 10000;
    vicspent /= 10000;
    // 0-50.

    vicspent += get_skill(victim, SKILL_FASTREFLEXES) * 5;

    chspent += get_skill(ch, SKILL_STRENGTH) * 15;
    vicspent += get_skill(victim, SKILL_DEXTERITY) * 15;

    chspent += UMAX(ch->disciplines[DIS_STRIKING], ch->disciplines[DIS_GRAPPLE]);
    vicspent +=
    UMAX(victim->disciplines[DIS_STRIKING], victim->disciplines[DIS_GRAPPLE]);

    vicspent = UMAX(vicspent, 1);

    if (ch->spentrpexp < 10000 && ch->spentexp < 10000 && ch->played / 3600 < 40)
    chspent /= 4;
    if (victim->spentrpexp < 10000 && victim->spentexp < 10000 && victim->played / 3600 < 40)
    vicspent /= 4;

    int ratio = chspent * 100 / UMAX(1, vicspent);

    return ratio;
  }

  _DOFUN(do_punch) {
    CHAR_DATA *victim;
    char arg1[MSL];

    argument = one_argument_nouncap(argument, arg1);

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (ch->played / 3600 < 75 && ch->pcdata->account->maxhours < 100) {
      send_to_char("You cannot do that yet.\n\r", ch);
      return;
    }

    if (IS_FLAG(ch->act, PLR_SHROUD) != IS_FLAG(victim->act, PLR_SHROUD)) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (is_ghost(ch)) {
      send_to_char("Your fist would find only air.\n\r", ch);
      return;
    }

    if ((ch->fistfighting == victim || in_fistfight(victim)) && !is_ghost(victim) && !guestmonster(victim)) {
      if (ch->fistattack == FIST_RETREAT) {
        act("$n stops backing away.", ch, NULL, victim, TO_ROOM);
      }
      ch->fistfighting = victim;
      if (!str_cmp(argument, "high") || !str_cmp(argument, "head")) {
        ch->fistattack = FIST_HIGH;
      }
      else if (!str_cmp(argument, "low") || !str_cmp(argument, "stomach")) {
        ch->fistattack = FIST_LOW;
      }
      else {
        if (number_percent() % 2 == 0)
        ch->fistattack = FIST_HIGH;
        else
        ch->fistattack = FIST_LOW;
      }
      if (ch->fisttimer == 0 || ch->fisttimer > 50)
      ch->fisttimer = 10;
      act("You get ready to launch a punch at $N.", ch, NULL, victim, TO_CHAR);
      return;
    }

    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (is_pinned(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (IS_NPC(victim)) {
      send_to_char("Not on NPCS.\n\r", ch);
      return;
    }
    if (is_safe(ch, victim)) {
      send_to_char("For some reason you can't bring yourself to do that.\n\r", ch);
      return;
    }
    if (in_public(ch, victim) && victim->race == RACE_CIVILIAN) {
      send_to_char("You'd certainly get in trouble with the police if you did that.\n\r", ch);
      return;
    }

    if (is_pinned(victim)) {
      free_string(victim->pcdata->pinned_by);
      victim->pcdata->pinned_by = str_dup("");
    }

    if (ch->wounds >= 2)
    ch->heal_timer += 1500;
    if (victim->wounds >= 2)
    victim->heal_timer += 500;

    if (power_compare(ch, victim) > 200) {
      act("You punch $N solidly in the jaw, sending $M reeling.", ch, NULL, victim, TO_CHAR);
      act("$n punches you solidly in the jaw, sending you reeling.", ch, NULL, victim, TO_VICT);
      act("$n punches $N solidly in the jaw, sending $M reeling.", ch, NULL, victim, TO_NOTVICT);
      WAIT_STATE(ch, PULSE_PER_SECOND * 2);
    }
    else if (power_compare(ch, victim) > 75) {
      act("You punch $N solidly in the jaw.", ch, NULL, victim, TO_CHAR);
      act("$n punches you solidly in the jaw.", ch, NULL, victim, TO_VICT);
      act("$n punches $N solidly in the jaw.", ch, NULL, victim, TO_NOTVICT);
      WAIT_STATE(ch, PULSE_PER_SECOND * 2);
    }
    else {
      act("You throw a punch at $N but $E easily blocks it.", ch, NULL, victim, TO_CHAR);
      act("$n throws a punch at you but you easily block it.", ch, NULL, victim, TO_VICT);
      act("$n throws a punch at $N but $E easily blocks it.", ch, NULL, victim, TO_NOTVICT);
      WAIT_STATE(ch, PULSE_PER_SECOND * 5);
    }

    if (!guestmonster(ch) && !guestmonster(victim)) {
      victim->fistfighting = ch;
      victim->fisttimer = 0;
      victim->fistattack = 0;
    }
  }

  _DOFUN(do_headbutt) {
    CHAR_DATA *victim;
    char arg1[MSL];

    argument = one_argument_nouncap(argument, arg1);

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }
    
    if (IS_FLAG(ch->act, PLR_SHROUD) != IS_FLAG(victim->act, PLR_SHROUD)) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (ch->played / 3600 < 75 && ch->pcdata->account->maxhours < 100) {
      send_to_char("You cannot do that yet.\n\r", ch);
      return;
    }

    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    
    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    
    if (IS_NPC(victim)) {
      send_to_char("Not on NPCS.\n\r", ch);
      return;
    }
    
    if (is_pinned(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    
    if (is_safe(ch, victim)) {
      send_to_char("For some reason you can't bring yourself to do that.\n\r", ch);
      return;
    }
    
    if (in_public(ch, victim) && victim->race == RACE_CIVILIAN) {
      send_to_char("You'd certainly get in trouble with the police if you did that.\n\r", ch);
      return;
    }

    if (in_fistfight(ch) && in_fistfight(victim)) {
      send_to_char("You're in a fist fight, try punching them.\n\r", ch);
      return;
    }

    if (is_ghost(victim)) {
      send_to_char("You would butt only air./n/r", ch);
      return;
    }

    // ghostie check and limit for headbutt -Discordance
    if (is_ghost(ch)) {
      if (is_manifesting(ch)) {
        if (deplete_ghostpool(ch, GHOST_MANIFESTATION) == FALSE) {
          send_to_char("You can't muster the strength to manifest your will any more today.\n\r", ch);
          return;
        }
      }
      else {
        send_to_char("You must be prepared to manifest your will.\n\r", ch);
        return;
      }
    }
    
    if (!guestmonster(ch) && !guestmonster(victim)) {
      victim->fistfighting = ch;
      victim->fisttimer = 0;
      victim->fistattack = 0;
    }

    if (ch->wounds >= 2)
    ch->heal_timer += 1500;
    if (victim->wounds >= 2)
    victim->heal_timer += 500;

    if (is_pinned(victim)) {
      free_string(victim->pcdata->pinned_by);
      victim->pcdata->pinned_by = str_dup("");
    }

    if (power_compare(ch, victim) > 50) {
      act("You headbutt $N.", ch, NULL, victim, TO_CHAR);
      act("$n headbutts you.", ch, NULL, victim, TO_VICT);
      act("$n headbutts $N.", ch, NULL, victim, TO_NOTVICT);
      WAIT_STATE(ch, PULSE_PER_SECOND * 12);
    }
    else {
      act("You headbutt $N before reeling back in pain.", ch, NULL, victim, TO_CHAR);
      act("$n heabutts you before reeling back in pain.", ch, NULL, victim, TO_VICT);
      act("$n headbutts $N before reeling back in pain.", ch, NULL, victim, TO_NOTVICT);
      WAIT_STATE(ch, PULSE_PER_SECOND * 15);
    }
  }

  _DOFUN(do_groinkick) {
    CHAR_DATA *victim;
    char arg1[MSL];

    argument = one_argument_nouncap(argument, arg1);

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }
    
    if (IS_FLAG(ch->act, PLR_SHROUD) != IS_FLAG(victim->act, PLR_SHROUD)) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (ch->played / 3600 < 75 && ch->pcdata->account->maxhours < 100) {
      send_to_char("You cannot do that yet.\n\r", ch);
      return;
    }

    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    
    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    
    if (IS_NPC(victim)) {
      send_to_char("Not on NPCS.\n\r", ch);
      return;
    }
    
    if (is_pinned(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    
    if (is_safe(ch, victim)) {
      send_to_char("For some reason you can't bring yourself to do that.\n\r", ch);
      return;
    }
    
    if (in_public(ch, victim) && victim->race == RACE_CIVILIAN) {
      send_to_char("You'd certainly get in trouble with the police if you did that.\n\r", ch);
      return;
    }

    if (in_fistfight(ch) && in_fistfight(victim)) {
      send_to_char("You're in a fist fight, try punching them.\n\r", ch);
      return;
    }

    if (is_ghost(victim)) {
      send_to_char("The ghost's groin is but an illusion./n/r", ch);
      return;
    }

    // ghostie check and limit for groin kick -Discordance
    if (is_ghost(ch)) {
      if (is_manifesting(ch)) {
        if (deplete_ghostpool(ch, GHOST_MANIFESTATION) == FALSE) {
          send_to_char("You can't muster the strength to manifest your will any more today.\n\r", ch);
          return;
        }
      }
      else {
        send_to_char("You must be prepared to manifest your will.\n\r", ch);
        return;
      }
    }

    if (!guestmonster(ch) && !guestmonster(victim)) {
      victim->fistfighting = ch;
      victim->fisttimer = 0;
      victim->fistattack = 0;
    }

    if (ch->wounds >= 2)
    ch->heal_timer += 1500;
    if (victim->wounds >= 2)
    victim->heal_timer += 500;

    if (is_pinned(victim)) {
      free_string(victim->pcdata->pinned_by);
      victim->pcdata->pinned_by = str_dup("");
    }

    if (power_compare(ch, victim) > 150 || (victim->pcdata->penis > 0 && power_compare(ch, victim) > 30)) {
      act("You kick $N between the legs, making $M stagger in pain.", ch, NULL, victim, TO_CHAR);
      act("$n kicks you between the legs, making you stagger in pain.", ch, NULL, victim, TO_VICT);
      act("$n kicks $N between the legs, making $M stagger in pain.", ch, NULL, victim, TO_NOTVICT);
      WAIT_STATE(ch, PULSE_PER_SECOND * 2);
    }
    else {
      act("You kick $N between the legs.", ch, NULL, victim, TO_CHAR);
      act("$n kicks you between the legs.", ch, NULL, victim, TO_VICT);
      act("$n kicks $N between the legs.", ch, NULL, victim, TO_NOTVICT);
      WAIT_STATE(ch, PULSE_PER_SECOND * 3);
    }
  }

  _DOFUN(do_knockoutpunch) {
    CHAR_DATA *victim;
    char arg1[MSL];

    argument = one_argument_nouncap(argument, arg1);

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }
    
    if (IS_NPC(victim))
    return;
  
    if (IS_FLAG(ch->act, PLR_SHROUD) != IS_FLAG(victim->act, PLR_SHROUD)) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (ch->pcdata->patrol_status >= PATROL_PREYING && ch->pcdata->patrol_status <= PATROL_STALKING) {
      send_to_char("You have to catch them first.\n\r", ch);
      return;
    }

    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    
    if (is_pinned(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    
    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    
    if (is_safe(ch, victim)) {
      send_to_char("For some reason you can't bring yourself to do that.\n\r", ch);
      return;
    }
    
    if (in_public(ch, victim)) {
      if (!IS_FLAG(ch->act, PLR_SHROUD) || !room_ambush(ch->in_room)) {
        send_to_char("It's a bit public of an area for kidnappings.\n\r", ch);
        return;
      }
    }
    
    if (ch->played / 3600 < 75 && ch->pcdata->account->maxhours < 100) {
      send_to_char("You cannot do that yet.\n\r", ch);
      return;
    }

    if (institute_room(ch->in_room)) {
      send_to_char("Institute security would stop you from doing that.\n\r", ch);
      return;
    }

    if (in_fistfight(ch) && in_fistfight(victim)) {
      send_to_char("You're in a fist fight, try punching them.\n\r", ch);
      return;
    }

    if (is_ghost(victim)) {
      send_to_char("Your fist would find only air.\n\r", ch);
      return;
    }

    // ghostie check and limit for knockout punch -Discordance
    if (is_ghost(ch)) {
      if (is_manifesting(ch)) {
        if (deplete_ghostpool(ch, GHOST_MANIFESTATION) == FALSE) {
          send_to_char("You can't muster the strength to project your will any more today.\n\r", ch);
          return;
        }
      }
      else {
        send_to_char("You must be prepared to manifest your will.\n\r", ch);
        return;
      }
    }

    if (!guestmonster(ch) && !guestmonster(victim)) {
      victim->fistfighting = ch;
      victim->fisttimer = 0;
      victim->fistattack = 0;
    }
    
    if (ch->wounds >= 2)
    ch->heal_timer += 1500;
    if (victim->wounds >= 2)
    victim->heal_timer += 500;

    if (is_pinned(victim)) {
      free_string(victim->pcdata->pinned_by);
      victim->pcdata->pinned_by = str_dup("");
    }

    if (victim->pcdata->trance > 0)
    victim->pcdata->trance = -20;

    if (is_helpless(victim) || (power_compare(ch, victim) > 500 && !room_hostile(ch->in_room) && victim->spentexp < 300000)) {
      act("You punch $N solidly in the jaw, knocking $M out cold.", ch, NULL, victim, TO_CHAR);
      act("$n punches you solidly in the jaw, knocking you out cold.", ch, NULL, victim, TO_VICT);
      act("$n punches $N solidly in the jaw, knocking $M out cold.", ch, NULL, victim, TO_NOTVICT);
      victim->pcdata->sleeping = 300;
    }
    else if (power_compare(ch, victim) > 200) {
      act("You punch $N solidly in the jaw, sending $M reeling.", ch, NULL, victim, TO_CHAR);
      act("$n punches you solidly in the jaw, sending you reeling.", ch, NULL, victim, TO_VICT);
      act("$n punches $N solidly in the jaw, sending $M reeling.", ch, NULL, victim, TO_NOTVICT);
      WAIT_STATE(ch, PULSE_PER_SECOND * 2);
    }
    else if (power_compare(ch, victim) > 75) {
      act("You punch $N solidly in the jaw.", ch, NULL, victim, TO_CHAR);
      act("$n punches you solidly in the jaw.", ch, NULL, victim, TO_VICT);
      act("$n punches $N solidly in the jaw.", ch, NULL, victim, TO_NOTVICT);
      WAIT_STATE(ch, PULSE_PER_SECOND * 2);
    }
    else {
      act("You throw a punch at $N but $E easily blocks it.", ch, NULL, victim, TO_CHAR);
      act("$n throws a punch at you but you easily block it.", ch, NULL, victim, TO_VICT);
      act("$n throws a punch at $N but $E easily blocks it.", ch, NULL, victim, TO_NOTVICT);
      WAIT_STATE(ch, PULSE_PER_SECOND * 5);
    }
  }

  _DOFUN(do_pin) {
    CHAR_DATA *victim;
    char arg1[MSL];

    argument = one_argument_nouncap(argument, arg1);

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }
    if (is_prisoner(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (is_pinned(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    // added NPC check for possible crash cause- Discordance
    if (IS_NPC(victim)) {
      send_to_char("Not on NPCs.\n\r", ch);
      return;
    }
    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (is_safe(ch, victim)) {
      send_to_char("For some reason you can't bring yourself to do that.\n\r", ch);
      return;
    }
    if (in_public(ch, victim) && victim->race == RACE_CIVILIAN) {
      send_to_char("You'd certainly get in trouble with the police if you did that.\n\r", ch);
      return;
    }
    if (in_fistfight(ch) && in_fistfight(victim)) {
      send_to_char("You're in a fist fight, try punching them.\n\r", ch);
      return;
    }

    if (is_ghost(victim)) {
      send_to_char("Restraining a ghost is not so simple.", ch);
      return;
    }

    // ghostie check and limit for pin -Discordance
    if (is_ghost(ch)) {
      if (is_manifesting(ch)) {
        if (deplete_ghostpool(ch, GHOST_MANIFESTATION) == FALSE) {
          send_to_char("You can't muster the strength to project your will any more today.\n\r", ch);
          return;
        }
      }
      else {
        send_to_char("You must be prepared to manifest your will.\n\r", ch);
        return;
      }
    }
    if (room_ambushing(ch->in_room)) {
      send_to_char("The room is a bit tense for that.\n\r", ch);
      return;
    }
    if (room_hostile(ch->in_room)) {
      start_hostilefight(ch);
      return;
    }

    if (ch->wounds >= 2)
    ch->heal_timer += 1500;
    if (victim->wounds >= 2)
    victim->heal_timer += 500;

    if (victim->pcdata->trance > 0)
    victim->pcdata->trance = -20;

    int chdex = get_skill(ch, SKILL_DEXTERITY);
    int vicdex = get_skill(victim, SKILL_DEXTERITY);
    if (victim->spentrpexp < 10000 && victim->spentexp < 10000 && victim->played / 3600 < 40)
    vicdex = UMIN(vicdex, 0);
    if (ch->spentrpexp < 10000 && ch->spentexp < 10000 && ch->played / 3600 < 40)
    chdex = UMIN(chdex, 0);

    if (IS_FLAG(victim->act, PLR_GUEST) && victim->pcdata->guest_type == GUEST_CARDINAL)
    vicdex *= 10;
    if (higher_power(victim) || guestmonster(victim))
    vicdex *= 10;

    if (chdex >= vicdex || overwhelm(ch, victim)) {
      act("You grab a hold of $N.", ch, NULL, victim, TO_CHAR);
      act("$n grabs a hold of $N.", ch, NULL, victim, TO_ROOM);
      send_to_char("Type escape to try and break free.\n\r", victim);
      WAIT_STATE(victim, PULSE_PER_SECOND * 3);
      WAIT_STATE(ch, PULSE_PER_SECOND * 3);
      free_string(victim->pcdata->pinned_by);
      victim->pcdata->pinned_by = str_dup(ch->name);
    }
    else {
      act("You try to grab a hold of $N.", ch, NULL, victim, TO_CHAR);
      act("$n tries to grab a hold of you.", ch, NULL, victim, TO_VICT);
      act("$n tries to grab a hold of $N.", ch, NULL, victim, TO_ROOM);
      WAIT_STATE(victim, PULSE_PER_SECOND * 3);
      WAIT_STATE(ch, PULSE_PER_SECOND * 3);
    }
  }

  _DOFUN(do_escape) {
    CHAR_DATA *fch;

    if (ch->in_room == NULL) {
      return;
    }

    if(!IS_NPC(ch) && ch->pcdata->patrol_status == PATROL_PREY)
    {
      do_function(ch, &do_preyescape, argument);
      return;
    }

    if (safe_strlen(ch->pcdata->pinned_by) < 2) {
      send_to_char("You aren't being pinned.\n\r", ch);
      return;
    }
    fch = get_char_world_pc(ch->pcdata->pinned_by);

    if (fch == NULL || fch->in_room == NULL || fch->in_room != ch->in_room) {
      send_to_char("You aren't being pinned.\n\r", ch);
      return;
    }

    int chdex = get_skill(ch, SKILL_STRENGTH);
    int vicdex = get_skill(fch, SKILL_STRENGTH);
    if (fch->spentrpexp < 10000 && fch->spentexp < 10000 && fch->played / 3600 < 40)
    vicdex = UMIN(vicdex, 0);
    if (ch->spentrpexp < 10000 && ch->spentexp < 10000 && ch->played / 3600 < 40)
    chdex = UMIN(chdex, 0);

    if (chdex >= vicdex && !overwhelm(fch, ch)) {
      act("$n pulls out of $N's grasp.", ch, NULL, fch, TO_NOTVICT);
      act("You pull out of $N's grasp.", ch, NULL, fch, TO_CHAR);
      act("$n pulls out of your grasp.", ch, NULL, fch, TO_VICT);
      dact("$n pulls out of $N's grasp.", ch, NULL, fch, DISTANCE_NEAR);

      free_string(ch->pcdata->pinned_by);
      ch->pcdata->pinned_by = str_dup("");
    }
    else {
      act("$n tries to pull out of $N's grasp.", ch, NULL, fch, TO_NOTVICT);
      act("You try to pull out of $N's grasp.", ch, NULL, fch, TO_CHAR);
      act("$n tries to pull out of your grasp.", ch, NULL, fch, TO_VICT);
      dact("$n tries to pull out of $N's grasp.", ch, NULL, fch, DISTANCE_NEAR);
    }
    WAIT_STATE(fch, PULSE_VIOLENCE);
  }

  _DOFUN(do_facesteal) {
    CHAR_DATA *victim;
    char arg1[MSL];

    if (get_skill(ch, SKILL_FACESTEALING) < 1) {
      send_to_char("You don't have that ability.\n\r", ch);
      return;
    }

    if (ch->shape != SHAPE_HUMAN) {
      send_to_char("You can only do this in human shape.\n\r", ch);
      return;
    }

    if (!str_cmp(argument, "")) {
      if (ch->pcdata->true_id == 0) {
        send_to_char("You already wear your true face.\n\r", ch);
        return;
      }
      else {
        ch->id = ch->pcdata->true_id;
        ch->pcdata->true_id = 0;
        send_to_char("You return to your true face.\n\r", ch);
        return;
      }
    }

    argument = one_argument_nouncap(argument, arg1);

    if ((victim = get_char_distance(ch, arg1, 2)) == NULL) {
      if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
    }

    if (IS_NPC(victim)) {
      send_to_char("Must target PCs.\n\r", ch);
      return;
    }

    if (ch->pcdata->true_id == 0) {
      ch->pcdata->true_id = ch->id;
    }
    ch->id = victim->id;
    send_to_char("You psychically steal their face.\n\r", ch);
  }

  _DOFUN(do_tackle) {
    CHAR_DATA *victim;
    char arg1[MSL];
    argument = one_argument_nouncap(argument, arg1);

    if ((victim = get_char_fight(ch, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }
    if (get_dist(ch->in_room->x, ch->in_room->y, victim->in_room->x, victim->in_room->y) > 3) {
      send_to_char("They're too far away.\n\r", ch);
      return;
    }
    if (ch->in_room == NULL || victim->in_room == NULL || ch->in_room == victim->in_room) {
      send_to_char("They're too close.\n\r", ch);
      return;
    }
    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    else {
      send_to_char("For some reason you can't bring yourself to do that.\n\r", ch);
      return;
    }
    if (in_public(ch, victim)) {
      send_to_char("You'd certainly get in trouble with the police if you did that.\n\r", ch);
      return;
    }
    if (in_fight(victim)) {
      send_to_char("That area is a bit crowded.\n\r", ch);
      return;
    }

    if (is_ghost(victim)) {
      act("You try to tackle $N, but land on your face instead.\n\r", ch, NULL, victim, TO_CHAR);
      act("$n tries to tackle you, but lands on $s face instead.\n\r.", ch, NULL, victim, TO_VICT);
      act("$n tries to tackle $N, but lands on $s face instead.\n\r", ch, NULL, victim, TO_ROOM);
      return;
    }

    if (is_ghost(ch)) {
      send_to_char("Such dynamism is no longer necessary./n/r", ch);
      return;
    }

    act("$n leaps out of the room.", ch, NULL, NULL, TO_ROOM);

    ROOM_INDEX_DATA *orig = ch->in_room;

    char_from_room(ch);
    char_to_room(ch, victim->in_room);

    act("$n leaps into the room.", ch, NULL, NULL, TO_ROOM);
    act("You leap into the room.", ch, NULL, NULL, TO_CHAR);

    for (DescList::iterator it = descriptor_list.begin();
    it != descriptor_list.end(); ++it) {
      DESCRIPTOR_DATA *d = *it;

      if (d->connected == CON_PLAYING && IS_AWAKE(d->character)) {
        CHAR_DATA *fch = d->character;
        if (!IS_NPC(fch) && fch->in_room != NULL && fch->in_room == orig) {

          if (fch->master == ch || ch->master == fch || (ch->master == fch->master && ch->master != NULL)) {
            char_from_room(fch);
            char_to_room(fch, ch->in_room);
            act("You follow $N", fch, NULL, ch, TO_CHAR);
          }
        }
      }
    }
    start_fight(ch, victim);

    WAIT_STATE(ch, PULSE_PER_SECOND * 3);
  }

  int karma_focus_cost(int exist)
  {
    return (exist+1)*15000;

    if(exist == 0)
    return 20000;
    else if(exist == 1)
    return 40000;
    else if(exist == 2)
    return 60000;
    else if(exist == 3)
    return 80000;
    else if(exist == 4)
    return 100000;
    else
    return pow(2, exist+1)*20000;
  }

  _DOFUN(do_karma) {
    if (is_gm(ch))
    return;
    if (IS_FLAG(ch->act, PLR_GUEST))
    return;
    char arg[MSL];
    argument = one_argument_nouncap(argument, arg);
    char arg2[MSL];
    argument = one_argument_nouncap(argument, arg2);



    if (str_cmp(arg, "buy")) {
      send_to_char("Syntax:Karma buy Cap/Experience/RPExperience/Influence/Respect/Cash/Dreamexp (amount)/Karma buy Focus/Karma buy origin (origin stat).\n\r", ch);
      return;
    }
    if (!str_cmp(arg2, "focus")) {
      int cost = karma_focus_cost(ch->pcdata->extra_focus);
      if(cost > available_karma(ch)) {
        printf_to_char(ch, "You would need %d karma to buy that.\n\r", cost);
        return;
      }
      ch->pcdata->extra_focus += 1;
      ch->pcdata->account->karma -= cost;
      ch->spentkarma += cost;
      send_to_char("Done.\n\r", ch);
      return;
    }
    else if (!str_cmp(arg2, "origin")) {
      if(available_karma(ch) < 10000) {
        send_to_char("You would need 10000 karma to buy that.\n\r", ch);
        return;
      }
      int pointer = 0;
      for (int i = 0; i < SKILL_USED; i++) {
        if (!str_cmp(skill_table[i].name, argument)) {
          pointer = skill_table[i].vnum;
        }
      }
      if (pointer == 0) {
        send_to_char("That is not a valid origin stat.\n\r", ch);
        return;
      }
      if(skilltype(pointer) != STYPE_ORIGIN) {
        send_to_char("That is not a valid origin stat.\n\r", ch);
        return;
      }
      ch->pcdata->bonus_origin = pointer;
      ch->pcdata->account->karma -= 10000;
      ch->spentkarma += 10000;
      send_to_char("Done.\n\r", ch);
    }


    int amount = atoi(argument);

    if (amount < 1 || amount > 1000000 || amount > available_karma(ch)) {
      send_to_char("Syntax:Karma buy Cap/Experience/RPExperience/Influence/Respect/Cash/Dreamexp (amount)/Karma buy Focus/Karma buy origin (origin stat).\n\r", ch);
      return;
    }

    if (!str_cmp(arg2, "xpcap")) {
      ch->pcdata->exp_cap += amount * 25;
      ch->pcdata->account->karma -= amount;
      ch->spentkarma += amount;
      send_to_char("Done.\n\r", ch);
    }
    else if (!str_cmp(arg2, "rpxpcap")) {
      ch->pcdata->rpexp_cap += amount * 25;
      ch->pcdata->account->karma -= amount;
      ch->spentkarma += amount;
      send_to_char("Done.\n\r", ch);
    }
    else if (!str_cmp(arg2, "Experience")) {
      ch->pcdata->account->xp += amount * 50;
      ch->pcdata->account->karma -= amount;
      ch->spentkarma += amount;
      send_to_char("Done.\n\r", ch);
    }
    else if (!str_cmp(arg2, "RPExperience")) {
      ch->pcdata->account->rpxp += amount * 10;
      ch->pcdata->account->karma -= amount;
      ch->spentkarma += amount;
      send_to_char("Done.\n\r", ch);
    }
    else if (!str_cmp(arg2, "Dreamexp")) {
      ch->pcdata->dexp += amount * 10;
      ch->pcdata->account->karma -= amount;
      ch->spentkarma += amount;
      send_to_char("Done.\n\r", ch);

    }
    else if (!str_cmp(arg2, "Influence")) {
      if(ch->pcdata->influence + amount*50 > 100000)
      {
        send_to_char("You can't have more than 100k influence at a time.\n\r", ch);
        return;
      }
      ch->pcdata->influence += amount * 50;
      if (ch->faction != 0)
      ch->pcdata->super_influence += amount * 25;
      ch->pcdata->account->karma -= amount;
      ch->spentkarma += amount * 4 / 5;
      send_to_char("Done.\n\r", ch);
    }
    else if (!str_cmp(arg2, "Respect")) {
      give_respect(ch, amount * 5, "Karma.", ch->faction);
      ch->pcdata->account->karma -= amount;
      ch->spentkarma += amount * 4 / 5;
      send_to_char("Done.\n\r", ch);
    }
    else if (!str_cmp(arg2, "Cash")) {
      ch->money += amount * 50;
      ch->pcdata->account->karma -= amount;
      ch->spentkarma += amount * 3 / 5;
      send_to_char("Done.\n\r", ch);
    }
    else
    send_to_char("Syntax:Karma buy Cap/Experience/RPExperience/Influence/Respect/Cash/Dreamexp (amount)/Karma buy Focus/Karma buy origin (origin stat).\n\r", ch);
  }

  _DOFUN(do_release) {

    for (CharList::iterator it = ch->in_room->people->begin();
    it != ch->in_room->people->end();) {
      CHAR_DATA *fch = *it;
      ++it;

      if (fch == NULL)
      break;

      if (is_pinned(fch) && !str_cmp(fch->pcdata->pinned_by, ch->name)) {
        act("$n releases $N.", ch, NULL, fch, TO_NOTVICT);
        act("You release $N.", ch, NULL, fch, TO_CHAR);
        act("$n releases you.", ch, NULL, fch, TO_VICT);
        dact("$n releases $N.", ch, NULL, fch, DISTANCE_NEAR);
        free_string(fch->pcdata->pinned_by);
        fch->pcdata->pinned_by = str_dup("");
      }
    }
    WAIT_STATE(ch, PULSE_VIOLENCE);
  }

  void hospital_gown_char(CHAR_DATA *ch) {
    int iWear;
    OBJ_DATA *obj;
    for (iWear = 0; iWear < MAX_WEAR; iWear++) {
      if ((obj = get_eq_char(ch, iWear)) == NULL)
      continue;
      unequip_char_silent(ch, obj);
      SET_BIT(obj->extra_flags, ITEM_WARDROBE);
      obj->stash_room = ROOM_INDEX_CLINICSTORE;
    }
    for (obj = ch->carrying; obj != NULL; obj = obj->next_content) {
      if (IS_SET(!obj->extra_flags, ITEM_WARDROBE)) {
        SET_BIT(obj->extra_flags, ITEM_WARDROBE);
        obj->stash_room = ROOM_INDEX_CLINICSTORE;
      }
    }
    obj = create_object(get_obj_index(84), 0);
    obj_to_char(obj, ch);
    wear_obj(ch, obj, TRUE, TRUE);
  }

  _DOFUN(do_admit) {
    char buf[MSL];
    ROOM_INDEX_DATA *room;
    if (ch->in_room == NULL || district_room(ch->in_room) != DISTRICT_INSTITUTE) {
      send_to_char("There's no admitting nurse here.\n\r", ch);
      return;
    }

    if (IS_FLAG(ch->act, PLR_DEAD)) {
      send_to_char("Were only you admitted prior to succumbing to your wounds./n/r", ch);
      return;
    }
    if (ch->wounds <= 1 && !IS_FLAG(ch->affected_by, AFF_STAKED)) {
      send_to_char("The nurse inspects you and then stares at you for a few moments before handing you a single bandaid.\n\r", ch);
      return;
    }
    if (ch->wounds <= 2 && get_skill(ch, SKILL_WEALTH) < 0) {
      send_to_char("The nurse informs you that your insurance won't cover your stay.\n\r", ch);
      return;
    }
    if (get_skill(ch, SKILL_WEALTH) >= 3) {
      room = get_room_index(1605);
      if (room_pop(room) > 0) {
        room = get_room_index(9363);
      }
      if (room_pop(room) > 1) {
        room = get_room_index(1605);
      }
    }
    else {
      room = get_room_index(1605);
      if (room_pop(room) > 1) {
        room = get_room_index(9363);
      }
    }
    hospital_gown_char(ch);
    if (IS_FLAG(ch->affected_by, AFF_STAKED)) {
      act("$n is rushed to surgery to have the stake removed from $s chest.", ch, NULL, NULL, TO_CHAR);
      act("You are rushed to surgery to have the stake removed from your chest.", ch, NULL, NULL, TO_ROOM);
      REMOVE_FLAG(ch->affected_by, AFF_STAKED);
      ch->pcdata->mark_timer[0] = 12 * 30 * 1;
      free_string(ch->pcdata->mark[0]);
      sprintf(buf, "%s has a heavy bandage over %s upper chest.`x\n\r", (ch->sex == SEX_MALE) ? "He" : "She", (ch->sex == SEX_MALE) ? "his" : "her");
      ch->pcdata->mark[0] = str_dup(buf);
    }
    else {
      act("The nurse takes your details, and escorts you to one of the patient rooms where she does a few basic health checks and lets you know that the doctor will be with you shortly.", ch, NULL, NULL, TO_CHAR);
      act("The nurse takes $n's details and escorts $m to one of the patient rooms.", ch, NULL, NULL, TO_ROOM);
    }
    char_from_room(ch);
    char_to_room(ch, room);
    act("The nurse escorts $n in and does a few basic health checks before letting $m know that the doctor will check up on $m shortly.", ch, NULL, NULL, TO_ROOM);
  }

  _DOFUN(do_blindfold) {
    CHAR_DATA *victim;
    char arg1[MSL];

    if ((victim = get_char_world_pc(argument)) != NULL && victim->pcdata->ghost_room == ch->in_room->vnum && (IS_FLAG(victim->act, PLR_GHOSTWALKING) || victim->pcdata->spectre > 0)) {
      if (is_helpless(ch)) {
        send_to_char("You can't do that.\n\r", ch);
        return;
      }

      if (is_ghost(ch)) {
        send_to_char("You can't get a grip on them.\n\r", ch);
        return;
      }

      if (IS_FLAG(victim->comm, COMM_BLINDFOLD)) {
        REMOVE_FLAG(victim->comm, COMM_BLINDFOLD);
        act("You remove $N's blindfold.", ch, NULL, victim, TO_CHAR);
        act("$n removes $N's blindfold.", ch, NULL, victim, TO_NOTVICT);
        act("You feel something happen to your body.", ch, NULL, victim, TO_VICT);
      }
      else {
        act("You blindfold $N.", ch, NULL, victim, TO_CHAR);
        act("$n blindfolds $N.", ch, NULL, victim, TO_NOTVICT);
        act("You feel something happen to your body.", ch, NULL, victim, TO_VICT);
        SET_FLAG(victim->comm, COMM_BLINDFOLD);
      }
      return;
    }
    argument = one_argument_nouncap(argument, arg1);

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (is_ghost(victim)) {
      send_to_char("The dead see in ways no blindfold can hinder.\n\r", ch);
      return;
    }

    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }

    if (is_animal(ch) && get_animal_genus(ch, ANIMAL_ACTIVE) != GENUS_HYBRID)
    return;

    if (is_pinned(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (IS_NPC(victim)) {
      send_to_char("Not on NPCS.\n\r", ch);
      return;
    }

    if (!is_helpless(victim) && victim != ch) {
      send_to_char("Might help if you tie them up first.\n\r", ch);
      return;
    }

    // ghostie check and limit for blindfold -Discordance
    if (is_ghost(ch)) {
      if (is_manifesting(ch)) {
        if (deplete_ghostpool(ch, GHOST_MANIFESTATION) == FALSE) {
          send_to_char("You can't muster the strength to manifest your will any more today.\n\r", ch);
          return;
        }
      }
      else {
        send_to_char("You must be prepared to manifest your will.\n\r", ch);
        return;
      }
    }

    if (IS_FLAG(victim->comm, COMM_BLINDFOLD)) {
      REMOVE_FLAG(victim->comm, COMM_BLINDFOLD);
      act("You remove $N's blindfold.", ch, NULL, victim, TO_CHAR);
      act("$n removes $N's blindfold.", ch, NULL, victim, TO_NOTVICT);
      act("$n removes your blindfold.", ch, NULL, victim, TO_VICT);
    }
    else {
      act("You blindfold $N.", ch, NULL, victim, TO_CHAR);
      act("$n blindfolds $N.", ch, NULL, victim, TO_NOTVICT);
      act("$n blindfolds you.", ch, NULL, victim, TO_VICT);
      SET_FLAG(victim->comm, COMM_BLINDFOLD);
    }
  }

  _DOFUN(do_desclock) {
    CHAR_DATA *victim;
    char arg1[MSL];

    argument = one_argument_nouncap(argument, arg1);

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (is_pinned(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (IS_NPC(victim)) {
      send_to_char("Not on NPCS.\n\r", ch);
      return;
    }
    if (higher_power(victim)) {
      send_to_char("That seems beyond you.\n\r", ch);
      return;
    }

    if (!is_helpless(victim)) {
      send_to_char("Might help if you tie them up first.\n\r", ch);
      return;
    }

    if (is_ghost(ch)) {
      send_to_char("They are as the day they died.\n\r", ch);
      return;
    }

    captive_command(ch, victim);

    if (!str_cmp(argument, "longterm")) {
      if (under_understanding(victim, ch)) {
        if(!str_cmp(ch->pcdata->fixation_name, victim->name) && ch->pcdata->fixation_level >= 3 && ch->pcdata->fixation_charges > 0) {
          ch->pcdata->fixation_charges--;
          victim->pcdata->desclock = UMAX(current_time+(3600*24*7), ch->pcdata->fixation_timeout);
          send_to_char("Done.\n\r", ch);
          return;
        }
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }

      victim->pcdata->desclock = 777600;
    }
    else {
      victim->pcdata->desclock = UMAX(victim->pcdata->desclock, 17280);
    }

    send_to_char("Done.\n\r", ch);
  }

  void captive_command(CHAR_DATA *ch, CHAR_DATA *victim) {
    if (IS_NPC(ch) || IS_NPC(victim))
    return;

    if (ch->played / 3600 < 75 && ch->pcdata->account->maxhours < 100 && is_dreaming(victim))
    do_function(victim, &do_wake, "");

    if (!is_ghost(ch) && victim->desc == NULL && number_percent() % 9 == 0) {
      char buf[MSL];
      sprintf(buf, "You half awaken to %s standing over you during the night.", ch->pcdata->intro_desc);
      message_to_char(victim->name, buf);
    }
    else if (is_ghost(ch) && victim->desc == NULL && number_percent() % 9 == 0) {
      message_to_char(
      victim->name, "You have a vague recollection of sleepwalking during the night.");
    }
  }

  _DOFUN(do_pledge) {
    return;
    char buf[MSL];

    if (ch->played / 3600 < 15) {
      send_to_char("Play a little more first.\n\r", ch);
      return;
    }

    if (safe_strlen(argument) < 2) {
      free_string(ch->pcdata->pledge);
      ch->pcdata->pledge = str_dup("");
      send_to_char("Pledge cleared.\n\r", ch);
    }
    else {
      free_string(ch->pcdata->pledge);
      ch->pcdata->pledge = str_dup(argument);
      printf_to_char(ch, "You pledge your blood to %s.\n\r", argument);
      sprintf(buf, "$n pledges their blood to %s.", argument);
      act(buf, ch, NULL, NULL, TO_ROOM);
    }
  }

  char *habit_level(int habit, int level) {
    switch (habit) {
    case HABIT_EATING:
      if (level == 0) {
        return "Normal";
      }
      else if (level == 1) {
        return "FastFood";
      }
      else if (level == 2) {
        return "Healthy";
      }
      else if (level == 3) {
        return "Restricted";
      }
      else if (level == 4) {
        return "Heavy";
      }
      break;
    case HABIT_FEEDING:
      if (level == 0) {
        return "Careful";
      }
      else if (level == 1) {
        return "Animal";
      }
      else if (level == 2) {
        return "Reckless";
      }
      break;
    case HABIT_LUNACY:
      if (level == 0) {
        return "Calmed";
      }
      else if (level == 1) {
        return "Chained";
      }
      else if (level == 2) {
        return "Careless";
      }
      else if (level == 3) {
        return "Embracing";
      }
      break;
    case HABIT_SMOKING:
    case HABIT_DRINKING:
    case HABIT_DRUGS:
      if (level == 0) {
        return "Never";
      }
      else if (level == 1) {
        return "Rarely";
      }
      else if (level == 2) {
        return "Socially";
      }
      else if (level == 3) {
        return "Regularly";
      }
      else if (level == 4) {
        return "Heavily";
      }
      break;
    case HABIT_SADISM:
    case HABIT_SEX:
    case HABIT_GYM:
    case HABIT_GAMES:
    case HABIT_COMICS:
    case HABIT_TV:
    case HABIT_NOVELS:
    case HABIT_CLUBBING:
    case HABIT_SPORTS:
      if (level == 0) {
        return "Never";
      }
      else if (level == 1) {
        return "Rarely";
      }
      else if (level == 2) {
        return "Monthly";
      }
      else if (level == 3) {
        return "Weekly";
      }
      else if (level == 4) {
        return "Daily";
      }
      break;
    case HABIT_CONCERN:
      if (level == 0) {
        return "Self";
      }
      else if (level == 1) {
        return "Family";
      }
      else if (level == 2) {
        return "Friends";
      }
      else if (level == 3) {
        return "Allies";
      }
      else if (level == 4) {
        return "Neighbors";
      }
      else if (level == 5) {
        return "Archetype";
      }
      else if (level == 6) {
        return "Countrymen";
      }
      else if (level == 7) {
        return "Naturals";
      }
      else if (level == 8) {
        return "Supernaturals";
      }
      else if (level == 9) {
        return "Sentients";
      }
      else if (level == 10) {
        return "Pets";
      }
      else if (level == 11) {
        return "Animals";
      }
      else if (level == 12) {
        return "Plants";
      }
      break;
    case HABIT_DEMOCRACY:
      if (level == 0) {
        return "Absolute";
      }
      else if (level == 1) {
        return "Strong";
      }
      else if (level == 2) {
        return "Weak";
      }
      else if (level == 3) {
        return "Theoretical";
      }
      else if (level == 4) {
        return "Limited";
      }
      else if (level == 5) {
        return "Oligarchic";
      }
      else if (level == 6) {
        return "Dictatorial";
      }
      break;
    case HABIT_EQUALITY:
      if (level == 0) {
        return "Absolute";
      }
      else if (level == 1) {
        return "Strong Redistribution";
      }
      else if (level == 2) {
        return "Weak Redistribution";
      }
      else if (level == 3) {
        return "Theoretical Redistribution";
      }
      else if (level == 4) {
        return "Laissez Faire";
      }
      else if (level == 5) {
        return "Usury Inequality";
      }
      else if (level == 6) {
        return "Aristocratic Inequality";
      }
      break;
    case HABIT_CRUELTY:
      if (level == 0) {
        return "Funny";
      }
      else if (level == 1) {
        return "Fun";
      }
      else if (level == 2) {
        return "Vengeance";
      }
      else if (level == 3) {
        return "Righteous";
      }
      else if (level == 4) {
        return "Punishment";
      }
      else if (level == 5) {
        return "Disincentive";
      }
      else if (level == 6) {
        return "Self Defense";
      }
      else if (level == 7) {
        return "Pacifist";
      }
      break;
    case HABIT_INTEL:
      if (level == 0) {
        return "Very Low";
      }
      else if (level == 1) {
        return "Low";
      }
      else if (level == 2) {
        return "Average";
      }
      else if (level == 3) {
        return "High";
      }
      else if (level == 4) {
        return "Very High";
      }
      break;
    case HABIT_ORIENTATION:
      if (level == 0) {
        return "Straight";
      }
      else if (level == 1) {
        return "Gay";
      }
      else if (level == 2) {
        return "Bisexual";
      }
      else if (level == 3) {
        return "Asexual";
      }
      break;
    case HABIT_SELFESTEEM:
      if (level == 0) {
        return "Normal";
      }
      else if (level == 1) {
        return "Lowish";
      }
      else if (level == 2) {
        return "Highish";
      }
      else if (level == 3) {
        return "Low";
      }
      else if (level == 4) {
        return "High";
      }
      break;
    case HABIT_PROTECTION:
      if (level == 0) {
        return "None";
      }
      else if (level == 1) {
        return "Accident";
      }
      else if (level == 2) {
        return "Pretend";
      }
      else if (level == 3) {
        return "Pullout";
      }
      else if (level == 4) {
        return "Slipoff";
      }
      else if (level == 5) {
        return "Condom";
      }
      break;
    case HABIT_HORMONES:
      if (level == 0) {
        return "Never";
      }
      else if (level == 1) {
        return "Rarely";
      }
      else if (level == 2) {
        return "Sometimes";
      }
      else if (level == 3) {
        return "Mostly";
      }
      else if (level == 4) {
        return "Almost Mostly";
      }
      else if (level == 5) {
        return "Always";
      }
      break;
    case HABIT_SCHOOL:
      if (level == 0) {
        return "Carefree";
      }
      else if (level == 1) {
        return "Slacker";
      }
      else if (level == 2) {
        return "Average";
      }
      else if (level == 3) {
        return "Try-hard";
      }
      else if (level == 4) {
        return "Overachiever";
      }
      break;
    }
    return "";
  }

  _DOFUN(do_habit) {
    int i;
    char arg[MSL];
    argument = one_argument_nouncap(argument, arg);

    if (IS_FLAG(ch->act, PLR_DEAD)) {
      send_to_char("You are as the day you died.\n\r", ch);
      return;
    }
    else if (in_fight(ch)) {
      send_to_char("Not while you're in combat.\n\r", ch);
      return;
    }
    else if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }

    if (!str_cmp(arg, "hunting")) {
      if (ch->pcdata->patrol_habits[PATROL_HUNTHABIT] != 0) {
        ch->pcdata->patrol_habits[PATROL_HUNTHABIT] = 0;
        send_to_char("You no longer seek opportunities to hunt monsters.\n\r", ch);
        return;
      }
      else {
        ch->pcdata->patrol_habits[PATROL_HUNTHABIT] = 1;
        send_to_char("You will now seek opportunities to hunt monsters.\n\r", ch);
        return;
      }
    }
    else if (!str_cmp(arg, "warfare")) {
      if (ch->pcdata->patrol_habits[PATROL_WARHABIT] != 0) {
        ch->pcdata->patrol_habits[PATROL_WARHABIT] = 0;
        send_to_char("You no longer seek opportunities to engage in society warfare.\n\r", ch);
        return;
      }
      else {
        ch->pcdata->patrol_habits[PATROL_WARHABIT] = 1;
        send_to_char("You will now seek opportunities to engage in society warfare.\n\r", ch);
        return;
      }
    }
    else if (!str_cmp(arg, "arcane")) {
      if (ch->pcdata->patrol_habits[PATROL_ARCANEHABIT] != 0) {
        ch->pcdata->patrol_habits[PATROL_ARCANEHABIT] = 0;
        send_to_char("You no longer seek opportunities to use your arcane skills.\n\r", ch);
        return;
      }
      else {
        ch->pcdata->patrol_habits[PATROL_ARCANEHABIT] = 1;
        send_to_char("You will now seek opportunities to use your arcane skills.\n\r", ch);
        return;
      }
    }
    else if (!str_cmp(arg, "spirits") || !str_cmp(arg, "spirit")) {
      if (ch->pcdata->patrol_habits[PATROL_SPIRITHABIT] != 0) {
        ch->pcdata->patrol_habits[PATROL_SPIRITHABIT] = 0;
        send_to_char("You no longer seek opportunities to banish spirits.\n\r", ch);
        return;
      }
      else {
        ch->pcdata->patrol_habits[PATROL_SPIRITHABIT] = 1;
        send_to_char("You will now seek opportunities to banish spirits.\n\r", ch);
        return;
      }
    }
    else if (!str_cmp(arg, "arcanewar") || !str_cmp(arg, "arcanewarfare")) {
      if (ch->pcdata->patrol_habits[PATROL_ARCANEWARHABIT] != 0) {
        ch->pcdata->patrol_habits[PATROL_ARCANEWARHABIT] = 0;
        send_to_char("You no longer seek opportunities to use your arcane skills in combat.\n\r", ch);
        return;
      }
      else {
        ch->pcdata->patrol_habits[PATROL_ARCANEWARHABIT] = 1;
        send_to_char("You will now seek opportunities to use your arcane skills in combat.\n\r", ch);
        return;
      }
    }
    else if (!str_cmp(arg, "diplomatic")) {
      if (ch->pcdata->patrol_habits[PATROL_DIPLOMATICHABIT] != 0) {
        ch->pcdata->patrol_habits[PATROL_DIPLOMATICHABIT] = 0;
        send_to_char("You no longer seek opportunities to use your diplomatic skills.\n\r", ch);
        return;
      }
      else {
        ch->pcdata->patrol_habits[PATROL_DIPLOMATICHABIT] = 1;
        send_to_char("You will now seek opportunities to use your diplomatic skills.\n\r", ch);
        return;
      }
    }
    else if (!str_cmp(arg, "reckless")) {
      if (ch->pcdata->patrol_habits[PATROL_RECKLESSHABIT] != 0) {
        ch->pcdata->patrol_habits[PATROL_RECKLESSHABIT] = 0;
        send_to_char("You no longer behave recklessly.\n\r", ch);
        return;
      }
      else {
        ch->pcdata->patrol_habits[PATROL_RECKLESSHABIT] = 1;
        send_to_char("You now behave recklessly.\n\r", ch);
        return;
      }
    }
    else if (!str_cmp(arg, "predator")) {
      if (ch->pcdata->patrol_habits[PATROL_PREDATORHABIT] != 0) {
        ch->pcdata->patrol_habits[PATROL_PREDATORHABIT] = 0;
        send_to_char("You no longer seek opportunities to be a predator.\n\r", ch);
        return;
      }
      else {
        ch->pcdata->patrol_habits[PATROL_PREDATORHABIT] = 1;
        send_to_char("You will now seek opportunities to be a predator.\n\r", ch);
        return;
      }
    }
    else if (!str_cmp(arg, "feeding") && is_vampire(ch)) {
      for (i = 0; i < 5; i++) {
        if (!str_cmp(argument, habit_level(HABIT_FEEDING, i))) {
          ch->pcdata->habit[HABIT_FEEDING] = i;
          printf_to_char(ch, "Your feeding habit is set to %s.\n\r", habit_level(HABIT_FEEDING, i));
          return;
        }
      }
      send_to_char("Invalid Option, valid options are: ", ch);
      for (i = 0; i < 5; i++) {
        printf_to_char(ch, " %s", habit_level(HABIT_FEEDING, i));
      }
      send_to_char("\n\r", ch);
      if (ch->played / 3600 > 20) {
        AFFECT_DATA af;
        af.where = TO_AFFECTS;
        af.type = 0;
        af.level = 10;
        af.duration = 12 * 60 * 10;
        af.location = APPLY_NONE;
        af.modifier = 0;
        af.caster = NULL;
        af.weave = FALSE;
        af.bitvector = AFF_WEAKEN;
        affect_to_char(ch, &af);
      }

      return;
    }
    else if (!str_cmp(arg, "lunacy") && is_werewolf(ch)) {
      for (i = 0; i < 5; i++) {
        if (!str_cmp(argument, habit_level(HABIT_LUNACY, i)) && safe_strlen(argument) > 1) {
          ch->pcdata->habit[HABIT_LUNACY] = i;
          printf_to_char(ch, "Your lunacy habit is set to %s.\n\r", habit_level(HABIT_LUNACY, i));
          return;
        }
      }
      send_to_char("Invalid Option, valid options are: ", ch);
      for (i = 0; i < 5; i++) {
        printf_to_char(ch, " %s", habit_level(HABIT_LUNACY, i));
      }
      send_to_char("\n\r", ch);
      return;
    }
    else if (!str_cmp(arg, "sadism") && is_demonborn(ch)) {
      for (i = 0; i < 5; i++) {
        if (!str_cmp(argument, habit_level(HABIT_SADISM, i))) {
          ch->pcdata->habit[HABIT_SADISM] = i;
          printf_to_char(ch, "Your sadism habit is set to %s.\n\r", habit_level(HABIT_SADISM, i));
          return;
        }
      }
      send_to_char("Invalid Option, valid options are: ", ch);
      for (i = 0; i < 5; i++) {
        printf_to_char(ch, " %s", habit_level(HABIT_SADISM, i));
      }
      send_to_char("\n\r", ch);
      return;
    }
    else if (!str_cmp(arg, "eating")) {
      for (i = 0; i < 5; i++) {
        if (!str_cmp(argument, habit_level(HABIT_EATING, i))) {
          ch->pcdata->habit[HABIT_EATING] = i;
          printf_to_char(ch, "Your eating habit is set to %s.\n\r", habit_level(HABIT_EATING, i));
          return;
        }
      }
      send_to_char("Invalid Option, valid options are: ", ch);
      for (i = 0; i < 5; i++) {
        printf_to_char(ch, " %s", habit_level(HABIT_EATING, i));
      }
      send_to_char("\n\r", ch);
      return;
    }
    else if (!str_cmp(arg, "sex")) {
      for (i = 0; i < 5; i++) {
        if (!str_cmp(argument, habit_level(HABIT_SEX, i))) {
          ch->pcdata->habit[HABIT_SEX] = i;
          printf_to_char(ch, "Your sex habit is set to %s.\n\r", habit_level(HABIT_SEX, i));
          return;
        }
      }
      send_to_char("Invalid Option, valid options are: ", ch);
      for (i = 0; i < 5; i++) {
        printf_to_char(ch, " %s", habit_level(HABIT_SEX, i));
      }
      send_to_char("\n\r", ch);
      return;
    }
    else if (!str_cmp(arg, "protection")) {
      for (i = 0; i < 6; i++) {
        if (!str_cmp(argument, habit_level(HABIT_PROTECTION, i))) {
          ch->pcdata->habit[HABIT_PROTECTION] = i;
          printf_to_char(ch, "Your protection habit is set to %s.\n\r", habit_level(HABIT_PROTECTION, i));
          return;
        }
      }
      send_to_char("Invalid Option, valid options are: ", ch);
      for (i = 0; i < 6; i++) {
        printf_to_char(ch, " %s", habit_level(HABIT_PROTECTION, i));
      }
      send_to_char("\n\r", ch);
      return;
    }
    else if (!str_cmp(arg, "hormones") || !str_cmp(arg, "contraceptives") || !str_cmp(arg, "hormonal") || !str_cmp(arg, "estrogen")) {
      for (i = 0; i < 6; i++) {
        if (!str_cmp(argument, habit_level(HABIT_HORMONES, i))) {
          ch->pcdata->habit[HABIT_HORMONES] = i;
          printf_to_char(ch, "Your hormones habit is set to %s.\n\r", habit_level(HABIT_HORMONES, i));
          return;
        }
      }
      send_to_char("Invalid Option, valid options are: ", ch);
      for (i = 0; i < 6; i++) {
        printf_to_char(ch, " %s", habit_level(HABIT_HORMONES, i));
      }
      send_to_char("\n\r", ch);
      return;
    }
    else if (!str_cmp(arg, "smoking")) {
      for (i = 0; i < 5; i++) {
        if (!str_cmp(argument, habit_level(HABIT_SMOKING, i))) {
          ch->pcdata->habit[HABIT_SMOKING] = i;
          printf_to_char(ch, "Your smoking habit is set to %s.\n\r", habit_level(HABIT_SMOKING, i));
          return;
        }
      }
      send_to_char("Invalid Option, valid options are: ", ch);
      for (i = 0; i < 5; i++) {
        printf_to_char(ch, " %s", habit_level(HABIT_SMOKING, i));
      }
      send_to_char("\n\r", ch);
      return;
    }
    else if (!str_cmp(arg, "drinking")) {
      for (i = 0; i < 5; i++) {
        if (!str_cmp(argument, habit_level(HABIT_DRINKING, i))) {
          ch->pcdata->habit[HABIT_DRINKING] = i;
          printf_to_char(ch, "Your drinking habit is set to %s.\n\r", habit_level(HABIT_DRINKING, i));
          return;
        }
      }
      send_to_char("Invalid Option, valid options are: ", ch);
      for (i = 0; i < 5; i++) {
        printf_to_char(ch, " %s", habit_level(HABIT_DRINKING, i));
      }
      send_to_char("\n\r", ch);
      return;
    }
    else if (!str_cmp(arg, "gym")) {
      for (i = 0; i < 5; i++) {
        if (!str_cmp(argument, habit_level(HABIT_GYM, i))) {
          ch->pcdata->habit[HABIT_GYM] = i;
          printf_to_char(ch, "Your gym habit is set to %s.\n\r", habit_level(HABIT_GYM, i));
          return;
        }
      }
      send_to_char("Invalid Option, valid options are: ", ch);
      for (i = 0; i < 5; i++) {
        printf_to_char(ch, " %s", habit_level(HABIT_GYM, i));
      }
      send_to_char("\n\r", ch);
      return;
    }
    else if (!str_cmp(arg, "drug")) {
      for (i = 0; i < 5; i++) {
        if (!str_cmp(argument, habit_level(HABIT_DRUGS, i))) {
          ch->pcdata->habit[HABIT_DRUGS] = i;
          printf_to_char(ch, "Your drug habit is set to %s.\n\r", habit_level(HABIT_DRUGS, i));
          return;
        }
      }
      send_to_char("Invalid Option, valid options are: ", ch);
      for (i = 0; i < 5; i++) {
        printf_to_char(ch, " %s", habit_level(HABIT_DRUGS, i));
      }
      send_to_char("\n\r", ch);
      return;
    }
    else if (!str_cmp(arg, "gaming")) {
      for (i = 0; i < 5; i++) {
        if (!str_cmp(argument, habit_level(HABIT_GAMES, i))) {
          ch->pcdata->habit[HABIT_GAMES] = i;
          printf_to_char(ch, "Your gaming habit is set to %s.\n\r", habit_level(HABIT_GAMES, i));
          return;
        }
      }
      send_to_char("Invalid Option, valid options are: ", ch);
      for (i = 0; i < 5; i++) {
        printf_to_char(ch, " %s", habit_level(HABIT_GAMES, i));
      }
      send_to_char("\n\r", ch);
      return;
    }
    else if (!str_cmp(arg, "comics")) {
      for (i = 0; i < 5; i++) {
        if (!str_cmp(argument, habit_level(HABIT_COMICS, i))) {
          ch->pcdata->habit[HABIT_COMICS] = i;
          printf_to_char(ch, "Your comics habit is set to %s.\n\r", habit_level(HABIT_COMICS, i));
          return;
        }
      }
      send_to_char("Invalid Option, valid options are: ", ch);
      for (i = 0; i < 5; i++) {
        printf_to_char(ch, " %s", habit_level(HABIT_COMICS, i));
      }
      send_to_char("\n\r", ch);
      return;
    }
    else if (!str_cmp(arg, "tv")) {
      for (i = 0; i < 5; i++) {
        if (!str_cmp(argument, habit_level(HABIT_TV, i))) {
          ch->pcdata->habit[HABIT_TV] = i;
          printf_to_char(ch, "Your tv habit is set to %s.\n\r", habit_level(HABIT_TV, i));
          return;
        }
      }
      send_to_char("Invalid Option, valid options are: ", ch);
      for (i = 0; i < 5; i++) {
        printf_to_char(ch, " %s", habit_level(HABIT_TV, i));
      }
      send_to_char("\n\r", ch);
      return;
    }
    else if (!str_cmp(arg, "novels")) {
      for (i = 0; i < 5; i++) {
        if (!str_cmp(argument, habit_level(HABIT_NOVELS, i))) {
          ch->pcdata->habit[HABIT_NOVELS] = i;
          printf_to_char(ch, "Your novels habit is set to %s.\n\r", habit_level(HABIT_NOVELS, i));
          return;
        }
      }
      send_to_char("Invalid Option, valid options are: ", ch);
      for (i = 0; i < 5; i++) {
        printf_to_char(ch, " %s", habit_level(HABIT_NOVELS, i));
      }
      send_to_char("\n\r", ch);
      return;
    }
    else if (!str_cmp(arg, "clubbing")) {
      for (i = 0; i < 5; i++) {
        if (!str_cmp(argument, habit_level(HABIT_CLUBBING, i))) {
          ch->pcdata->habit[HABIT_CLUBBING] = i;
          printf_to_char(ch, "Your clubbing habit is set to %s.\n\r", habit_level(HABIT_CLUBBING, i));
          return;
        }
      }
      send_to_char("Invalid Option, valid options are: ", ch);
      for (i = 0; i < 5; i++) {
        printf_to_char(ch, " %s", habit_level(HABIT_CLUBBING, i));
      }
      send_to_char("\n\r", ch);
      return;
    }
    else if (!str_cmp(arg, "sports")) {
      for (i = 0; i < 5; i++) {
        if (!str_cmp(argument, habit_level(HABIT_SPORTS, i))) {
          ch->pcdata->habit[HABIT_SPORTS] = i;
          printf_to_char(ch, "Your sports habit is set to %s.\n\r", habit_level(HABIT_SPORTS, i));
          return;
        }
      }
      send_to_char("Invalid Option, valid options are: ", ch);
      for (i = 0; i < 5; i++) {
        printf_to_char(ch, " %s", habit_level(HABIT_SPORTS, i));
      }
      send_to_char("\n\r", ch);
      return;
    }
    else if (!str_cmp(arg, "concern")) {
      for (i = 0; i < 13; i++) {
        if (!str_cmp(argument, habit_level(HABIT_CONCERN, i))) {
          ch->pcdata->habit[HABIT_CONCERN] = i;
          printf_to_char(ch, "Your circle of concern is set to %s.\n\r", habit_level(HABIT_CONCERN, i));
          return;
        }
      }
      send_to_char("Invalid Option, valid options are: ", ch);
      for (i = 0; i < 13; i++)
      printf_to_char(ch, " %s", habit_level(HABIT_CONCERN, i));
      send_to_char("\n\r", ch);
      return;
    }
    else if (!str_cmp(arg, "democracy")) {
      for (i = 0; i < 7; i++) {
        if (!str_cmp(argument, habit_level(HABIT_DEMOCRACY, i))) {
          ch->pcdata->habit[HABIT_DEMOCRACY] = i;
          int level = i;
          printf_to_char(ch, "Your attitude to democracy set to to %s.\n\r", habit_level(HABIT_DEMOCRACY, i));
          if (level == 0)
          send_to_char("Absolute democracies are not very representational and rigidly oppose any influence on democracy.\n\r", ch);
          else if (level == 1)
          send_to_char("Strong democracies have stringent laws and spend sigificant resources ensuring democracy is democratic.\n\r", ch);
          else if (level == 2)
          send_to_char("Weak democracies have some weak laws or regulations to attempt to democracy democratic.\n\r", ch);
          else if (level == 3)
          send_to_char("Theoretical democracies have some laws or regulations to keep democracy democratic, but not any that actually work or are enforced.\n\r", ch);
          else if (level == 4)
          send_to_char("Limited democracies restrict voting rights to some sub-group, such as landowners or members of a particular ethnocultural group.\n\r", ch);
          else if (level == 5)
          send_to_char("Oligarchies aren't democratic at all, but rather have governments run by small groups of individuals.\n\r", ch);
          else if (level == 6)
          send_to_char("Dicatoriships aren't democratic at all, but rather have governments run by a single individual.\n\r", ch);
          return;
        }
      }
      send_to_char("Invalid Option, valid options are: ", ch);
      for (i = 0; i < 7; i++)
      printf_to_char(ch, " %s", habit_level(HABIT_DEMOCRACY, i));
      send_to_char("\n\r", ch);
      return;
    }
    else if (!str_cmp(arg, "equality")) {
      for (i = 0; i < 7; i++) {
        if (!str_cmp(argument, habit_level(HABIT_EQUALITY, i))) {
          int level = i;
          ch->pcdata->habit[HABIT_EQUALITY] = i;
          printf_to_char(ch, "Your attitude to equality set to to %s.\n\r", habit_level(HABIT_EQUALITY, i));
          if (level == 0)
          send_to_char("Absolute equality requires that all people have exactly the same amount as each other, and usually have to be state-run.\n\r", ch);
          if (level == 1)
          send_to_char("Strong redistribution makes the poor and rich relatively equal, with the rich only having about twice as much as the poor, but involves heavy taxes to achieve this of usually over 90% on some earnings.\n\r", ch);
          if (level == 2)
          send_to_char("Weak redistribution makes the poor and rich more equal than they would otherwise be, but not by that much, with the highest tax rates still below 50%\n\r", ch);
          if (level == 3)
          send_to_char("Theoretical redistribution includes progressive systems, but they either do not work or are insufficient to keep up with naturally growing inequality.\n\r", ch);
          if (level == 4)
          send_to_char("Laissez Faire economies have no wealth or incoming redistribution systems.\n\r", ch);
          if (level == 5)
          send_to_char("Usury Inequality promotes growing inequality through empowering those who already have money through charging interest or rents on their assets.\n\r", ch);
          if (level == 6)
          send_to_char("Aristocratic Inequality promotes inequality through state intervention that distributes wealth to the chosen few, nobles or party members or the like.\n\r", ch);
          return;
        }
      }
      send_to_char("Invalid Option, valid options are: ", ch);
      for (i = 0; i < 7; i++)
      printf_to_char(ch, " %s", habit_level(HABIT_EQUALITY, i));
      send_to_char("\n\r", ch);
      return;
    }
    else if (!str_cmp(arg, "cruelty")) {
      for (i = 0; i < 8; i++) {
        if (!str_cmp(argument, habit_level(HABIT_CRUELTY, i))) {
          int level = i;

          ch->pcdata->habit[HABIT_CRUELTY] = i;
          printf_to_char(ch, "Your attitude to cruelty set to to %s.\n\r", habit_level(HABIT_CRUELTY, i));
          if (level == 0)
          send_to_char("Your character thinks it is fine to be cruel to people whenever it's funny.\n\r", ch);
          if (level == 1)
          send_to_char("Your character thinks it is fine to be cruel to people whenever it would be enjoyable.\n\r", ch);
          if (level == 2)
          send_to_char("Your character thinks it is fine to be cruel to people whenever they have first been cruel to them.\n\r", ch);
          if (level == 3)
          send_to_char("Your character thinks it is fine to be cruel to people if they are a bad person.\n\r", ch);
          if (level == 4)
          send_to_char("Your character thinks it is fine to be cruel to people if they have first been cruel to someone else.\n\r", ch);
          if (level == 5)
          send_to_char("Your character thinks it is fine to be cruel to people if it will or might change their behaviour, or the behaviour of others, in some important way.\n\r", ch);
          if (level == 6)
          send_to_char("Your character thinks it is fine to be cruel to people if it will or might stop other ongoing cruelty by them.\n\r", ch);
          if (level == 7)
          send_to_char("Your character thinks it is never fine to be cruel to others.\n\r", ch);
          return;
        }
      }
      send_to_char("Invalid Option, valid options are: ", ch);
      for (i = 0; i < 8; i++)
      printf_to_char(ch, " %s", habit_level(HABIT_CRUELTY, i));
      send_to_char("\n\r", ch);
      return;
    }
    else if (!str_cmp(arg, "intelligence")) {
      for (i = 0; i < 5; i++) {
        if (!str_cmp(argument, habit_level(HABIT_INTEL, i))) {
          ch->pcdata->habit[HABIT_INTEL] = i;
          printf_to_char(ch, "Your intelligence set to to %s.\n\r", habit_level(HABIT_INTEL, i));
          return;
        }
      }
      send_to_char("Invalid Option, valid options are: ", ch);
      for (i = 0; i < 5; i++)
      printf_to_char(ch, " %s", habit_level(HABIT_INTEL, i));
      send_to_char("\n\r", ch);
      return;
    }
    else if (!str_cmp(arg, "orientation")) {
      for (i = 0; i < 4; i++) {
        if (!str_cmp(argument, habit_level(HABIT_ORIENTATION, i))) {
          ch->pcdata->habit[HABIT_ORIENTATION] = i;
          printf_to_char(ch, "Your orientation set to %s.\n\r", habit_level(HABIT_ORIENTATION, i));
          return;
        }
      }
      send_to_char("Invalid Option, valid options are: ", ch);
      for (i = 0; i < 5; i++) {
        printf_to_char(ch, " %s", habit_level(HABIT_ORIENTATION, i));
      }
      send_to_char("\n\r", ch);
      return;
    }
    else if (!str_cmp(arg, "selfesteem")) {
      for (i = 0; i < 5; i++) {
        if (!str_cmp(argument, habit_level(HABIT_SELFESTEEM, i))) {
          ch->pcdata->habit[HABIT_SELFESTEEM] = i;
          printf_to_char(ch, "Your self esteem set to %s.\n\r", habit_level(HABIT_SELFESTEEM, i));
          return;
        }
      }
      send_to_char("Invalid Option, valid options are: ", ch);
      for (i = 0; i < 5; i++) {
        printf_to_char(ch, " %s", habit_level(HABIT_SELFESTEEM, i));
      }
      send_to_char("\n\r", ch);
      return;
    }
    else {
      if (is_vampire(ch))
      printf_to_char(
      ch, "Feeding: %s\n\r", habit_level(HABIT_FEEDING, ch->pcdata->habit[HABIT_FEEDING]));
      if (is_werewolf(ch))
      printf_to_char(
      ch, "Lunacy: %s\n\r", habit_level(HABIT_LUNACY, ch->pcdata->habit[HABIT_LUNACY]));
      if (is_demonborn(ch))
      printf_to_char(
      ch, "Sadism: %s\n\r", habit_level(HABIT_SADISM, ch->pcdata->habit[HABIT_SADISM]));

      printf_to_char(ch, "Eating: %s\n\r", habit_level(HABIT_EATING, ch->pcdata->habit[HABIT_EATING]));
      printf_to_char(ch, "Sex: %s\n\r", habit_level(HABIT_SEX, ch->pcdata->habit[HABIT_SEX]));
      printf_to_char(
      ch, "Protection: %s\n\r", habit_level(HABIT_PROTECTION, ch->pcdata->habit[HABIT_PROTECTION]));
      if (ch->pcdata->penis == 0)
      printf_to_char(
      ch, "Contraceptives: %s\n\r", habit_level(HABIT_HORMONES, ch->pcdata->habit[HABIT_HORMONES]));
      else
      printf_to_char(
      ch, "Estrogen: %s\n\r", habit_level(HABIT_HORMONES, ch->pcdata->habit[HABIT_HORMONES]));
      printf_to_char(
      ch, "Smoking: %s\n\r", habit_level(HABIT_SMOKING, ch->pcdata->habit[HABIT_SMOKING]));
      printf_to_char(
      ch, "Drinking: %s\n\r", habit_level(HABIT_DRINKING, ch->pcdata->habit[HABIT_DRINKING]));
      printf_to_char(ch, "Drug: %s\n\r", habit_level(HABIT_DRUGS, ch->pcdata->habit[HABIT_DRUGS]));
      printf_to_char(ch, "Gym: %s\n\r", habit_level(HABIT_GYM, ch->pcdata->habit[HABIT_GYM]));
      printf_to_char(ch, "Gaming: %s\n\r", habit_level(HABIT_GAMES, ch->pcdata->habit[HABIT_GAMES]));
      printf_to_char(ch, "Comics: %s\n\r", habit_level(HABIT_COMICS, ch->pcdata->habit[HABIT_COMICS]));
      printf_to_char(ch, "Tv: %s\n\r", habit_level(HABIT_TV, ch->pcdata->habit[HABIT_TV]));
      printf_to_char(ch, "Novels: %s\n\r", habit_level(HABIT_NOVELS, ch->pcdata->habit[HABIT_NOVELS]));
      printf_to_char(
      ch, "Clubbing: %s\n\r", habit_level(HABIT_CLUBBING, ch->pcdata->habit[HABIT_CLUBBING]));
      printf_to_char(ch, "Sports: %s\n\r", habit_level(HABIT_SPORTS, ch->pcdata->habit[HABIT_SPORTS]));
      printf_to_char(
      ch, "Orientation: %s\n\r", habit_level(HABIT_ORIENTATION, ch->pcdata->habit[HABIT_ORIENTATION]));
      printf_to_char(
      ch, "Selfesteem: %s\n\r", habit_level(HABIT_SELFESTEEM, ch->pcdata->habit[HABIT_SELFESTEEM]));
      printf_to_char(
      ch, "Concern: %s\n\r", habit_level(HABIT_CONCERN, ch->pcdata->habit[HABIT_CONCERN]));
      printf_to_char(
      ch, "Democracy: %s\n\r", habit_level(HABIT_DEMOCRACY, ch->pcdata->habit[HABIT_DEMOCRACY]));
      printf_to_char(
      ch, "Equality: %s\n\r", habit_level(HABIT_EQUALITY, ch->pcdata->habit[HABIT_EQUALITY]));
      printf_to_char(
      ch, "Cruelty: %s\n\r", habit_level(HABIT_CRUELTY, ch->pcdata->habit[HABIT_CRUELTY]));
      printf_to_char(ch, "Intelligence: %s\n\r", habit_level(HABIT_INTEL, ch->pcdata->habit[HABIT_INTEL]));
      printf_to_char(
      ch, "Reckless: %s\n\r", (ch->pcdata->patrol_habits[PATROL_RECKLESSHABIT] == 0) ? "No" : "Yes");
      printf_to_char(ch, "Hunting: %s\n\r", (ch->pcdata->patrol_habits[PATROL_HUNTHABIT] == 0) ? "No" : "Yes");
      printf_to_char(
      ch, "Predator: %s\n\r", (ch->pcdata->patrol_habits[PATROL_PREDATORHABIT] == 0) ? "No" : "Yes");
      printf_to_char(ch, "Warfare: %s\n\r", (ch->pcdata->patrol_habits[PATROL_WARHABIT] == 0) ? "No" : "Yes");
      printf_to_char(
      ch, "Arcane: %s\n\r", (ch->pcdata->patrol_habits[PATROL_ARCANEHABIT] == 0) ? "No" : "Yes");
      printf_to_char(
      ch, "ArcaneWarfare: %s\n\r", (ch->pcdata->patrol_habits[PATROL_ARCANEWARHABIT] == 0) ? "No" : "Yes");
      printf_to_char(
      ch, "Spirit: %s\n\r", (ch->pcdata->patrol_habits[PATROL_SPIRITHABIT] == 0) ? "No" : "Yes");
      printf_to_char(ch, "Diplomatic: %s\n\r", (ch->pcdata->patrol_habits[PATROL_DIPLOMATICHABIT] == 0)
      ? "No" : "Yes");

      send_to_char("Type habit (type) (level) to change your habits.\n\r", ch);
    }
  }

  int belief_match(CHAR_DATA *ch, FACTION_TYPE *fac) {
    int match = 0;
    if (fac->axes[AXES_SUPERNATURAL] == AXES_FARLEFT) {
      if (ch->pcdata->habit[HABIT_CONCERN] == 6 || ch->pcdata->habit[HABIT_CONCERN] == 8)
      match += 50;
      else if (ch->pcdata->habit[HABIT_CONCERN] == 7)
      match -= 50;
      else if (ch->pcdata->habit[HABIT_CONCERN] > 9)
      match -= 20;

      if (ch->pcdata->habit[HABIT_DEMOCRACY] <= 2)
      match -= 20;
      else if (ch->pcdata->habit[HABIT_DEMOCRACY] >= 3)
      match += 20;

      if (ch->pcdata->habit[HABIT_EQUALITY] <= 2)
      match -= 20;
      else if (ch->pcdata->habit[HABIT_EQUALITY] >= 3)
      match += 20;
    }
    else if (fac->axes[AXES_SUPERNATURAL] == AXES_MIDLEFT) {
      if (ch->pcdata->habit[HABIT_CONCERN] == 6 || ch->pcdata->habit[HABIT_CONCERN] == 8)
      match += 20;
      else if (ch->pcdata->habit[HABIT_CONCERN] == 7)
      match -= 20;
      else if (ch->pcdata->habit[HABIT_CONCERN] > 9)
      match -= 10;

      if (ch->pcdata->habit[HABIT_DEMOCRACY] <= 2)
      match -= 10;
      else if (ch->pcdata->habit[HABIT_DEMOCRACY] >= 3)
      match += 10;

      if (ch->pcdata->habit[HABIT_EQUALITY] <= 2)
      match -= 10;
      else if (ch->pcdata->habit[HABIT_EQUALITY] >= 3)
      match += 10;
    }
    else if (fac->axes[AXES_SUPERNATURAL] == AXES_NEARLEFT) {
      if (ch->pcdata->habit[HABIT_CONCERN] == 6 || ch->pcdata->habit[HABIT_CONCERN] == 8)
      match += 10;
      else if (ch->pcdata->habit[HABIT_CONCERN] == 7)
      match -= 10;
      else if (ch->pcdata->habit[HABIT_CONCERN] > 9)
      match -= 5;

      if (ch->pcdata->habit[HABIT_DEMOCRACY] <= 2)
      match -= 5;
      else if (ch->pcdata->habit[HABIT_DEMOCRACY] >= 3)
      match += 5;

      if (ch->pcdata->habit[HABIT_EQUALITY] <= 2)
      match -= 5;
      else if (ch->pcdata->habit[HABIT_EQUALITY] >= 3)
      match += 5;
    }
    else if (fac->axes[AXES_SUPERNATURAL] == AXES_FARRIGHT) {
      if (ch->pcdata->habit[HABIT_CONCERN] == 6 || ch->pcdata->habit[HABIT_CONCERN] == 7)
      match += 50;
      else if (ch->pcdata->habit[HABIT_CONCERN] == 8)
      match -= 20;

      if (ch->pcdata->habit[HABIT_DEMOCRACY] <= 2)
      match -= 5;
      else if (ch->pcdata->habit[HABIT_DEMOCRACY] >= 3)
      match += 5;

      if (ch->pcdata->habit[HABIT_EQUALITY] <= 2)
      match += 10;
      else if (ch->pcdata->habit[HABIT_EQUALITY] >= 3)
      match -= 10;
    }
    else if (fac->axes[AXES_SUPERNATURAL] == AXES_MIDRIGHT) {
      if (ch->pcdata->habit[HABIT_CONCERN] == 6 || ch->pcdata->habit[HABIT_CONCERN] == 7)
      match += 20;
      else if (ch->pcdata->habit[HABIT_CONCERN] == 8)
      match -= 10;

      if (ch->pcdata->habit[HABIT_EQUALITY] <= 2)
      match += 10;
      else if (ch->pcdata->habit[HABIT_EQUALITY] >= 3)
      match -= 10;
    }
    else if (fac->axes[AXES_SUPERNATURAL] == AXES_NEARRIGHT) {
      if (ch->pcdata->habit[HABIT_CONCERN] == 6 || ch->pcdata->habit[HABIT_CONCERN] == 7)
      match += 10;
      else if (ch->pcdata->habit[HABIT_CONCERN] == 8)
      match -= 5;

      if (ch->pcdata->habit[HABIT_EQUALITY] <= 2)
      match += 10;
      else if (ch->pcdata->habit[HABIT_EQUALITY] >= 3)
      match -= 10;
    }
    if (fac->axes[AXES_MATERIAL] == AXES_FARLEFT) {
      if (ch->pcdata->habit[HABIT_EQUALITY] == 5 || ch->pcdata->habit[HABIT_EQUALITY] == 4 || ch->pcdata->habit[HABIT_EQUALITY] == 3)
      match -= 30;
      else if (ch->pcdata->habit[HABIT_EQUALITY] == 6 || ch->pcdata->habit[HABIT_EQUALITY] == 1)
      match += 30;
    }
    else if (fac->axes[AXES_MATERIAL] == AXES_MIDLEFT) {
      if (ch->pcdata->habit[HABIT_EQUALITY] == 5 || ch->pcdata->habit[HABIT_EQUALITY] == 4 || ch->pcdata->habit[HABIT_EQUALITY] == 3)
      match -= 10;
      else if (ch->pcdata->habit[HABIT_EQUALITY] == 6 || ch->pcdata->habit[HABIT_EQUALITY] == 1)
      match += 10;
    }
    else if (fac->axes[AXES_MATERIAL] == AXES_NEARLEFT) {
      if (ch->pcdata->habit[HABIT_EQUALITY] == 5 || ch->pcdata->habit[HABIT_EQUALITY] == 4 || ch->pcdata->habit[HABIT_EQUALITY] == 3)
      match -= 5;
      else if (ch->pcdata->habit[HABIT_EQUALITY] == 6 || ch->pcdata->habit[HABIT_EQUALITY] == 1)
      match += 5;
    }
    else if (fac->axes[AXES_MATERIAL] == AXES_NEUTRAL) {
      if (ch->pcdata->habit[HABIT_EQUALITY] == 1 || ch->pcdata->habit[HABIT_EQUALITY] >= 5)
      match -= 10;
    }
    else if (fac->axes[AXES_MATERIAL] == AXES_FARRIGHT) {
      if (ch->pcdata->habit[HABIT_EQUALITY] == 5 || ch->pcdata->habit[HABIT_EQUALITY] == 4 || ch->pcdata->habit[HABIT_EQUALITY] == 3)
      match += 30;
      else if (ch->pcdata->habit[HABIT_EQUALITY] == 2 || ch->pcdata->habit[HABIT_EQUALITY] == 1)
      match -= 30;
    }
    else if (fac->axes[AXES_MATERIAL] == AXES_MIDRIGHT) {
      if (ch->pcdata->habit[HABIT_EQUALITY] == 5 || ch->pcdata->habit[HABIT_EQUALITY] == 4 || ch->pcdata->habit[HABIT_EQUALITY] == 3)
      match += 10;
      else if (ch->pcdata->habit[HABIT_EQUALITY] == 2 || ch->pcdata->habit[HABIT_EQUALITY] == 1)
      match -= 10;
    }
    else if (fac->axes[AXES_MATERIAL] == AXES_NEARRIGHT) {
      if (ch->pcdata->habit[HABIT_EQUALITY] == 5 || ch->pcdata->habit[HABIT_EQUALITY] == 4 || ch->pcdata->habit[HABIT_EQUALITY] == 3)
      match += 5;
      else if (ch->pcdata->habit[HABIT_EQUALITY] == 2 || ch->pcdata->habit[HABIT_EQUALITY] == 1)
      match -= 5;
    }
    else if (fac->axes[AXES_COMBAT] == AXES_FARLEFT) {
      if (ch->pcdata->habit[HABIT_CRUELTY] >= 6)
      match -= 40;
      else
      match += 10;
    }
    else if (fac->axes[AXES_COMBAT] == AXES_MIDLEFT) {
      if (ch->pcdata->habit[HABIT_CRUELTY] >= 6)
      match -= 20;
      else
      match += 5;
    }
    else if (fac->axes[AXES_COMBAT] == AXES_NEARLEFT) {
      if (ch->pcdata->habit[HABIT_CRUELTY] >= 6)
      match -= 10;
    }

    if (fac->axes[AXES_CORRUPT] == AXES_FARLEFT) {
      if (ch->pcdata->habit[HABIT_CONCERN] >= 7)
      match -= 50;
      else if (ch->pcdata->habit[HABIT_CONCERN] <= 5)
      match += 30;
      if (ch->pcdata->habit[HABIT_DEMOCRACY] <= 1)
      match -= 20;
      if (ch->pcdata->habit[HABIT_EQUALITY] <= 1)
      match -= 50;
      else if (ch->pcdata->habit[HABIT_EQUALITY] == 2)
      match -= 10;
      else
      match += 50;
      if (ch->pcdata->habit[HABIT_CRUELTY] >= 6)
      match -= 50;
      else if (ch->pcdata->habit[HABIT_CRUELTY] <= 3)
      match += 50;
    }
    else if (fac->axes[AXES_CORRUPT] == AXES_MIDLEFT) {
      if (ch->pcdata->habit[HABIT_CONCERN] >= 7)
      match -= 20;
      else if (ch->pcdata->habit[HABIT_CONCERN] <= 5)
      match += 10;
      if (ch->pcdata->habit[HABIT_DEMOCRACY] <= 1)
      match -= 10;
      if (ch->pcdata->habit[HABIT_EQUALITY] <= 1)
      match -= 20;
      else if (ch->pcdata->habit[HABIT_EQUALITY] == 2)
      match -= 5;
      else
      match += 20;
      if (ch->pcdata->habit[HABIT_CRUELTY] >= 6)
      match -= 20;
      else if (ch->pcdata->habit[HABIT_CRUELTY] <= 3)
      match += 20;
    }
    else if (fac->axes[AXES_CORRUPT] == AXES_NEARLEFT) {
      if (ch->pcdata->habit[HABIT_CONCERN] >= 7)
      match -= 10;
      else if (ch->pcdata->habit[HABIT_CONCERN] <= 5)
      match += 5;
      if (ch->pcdata->habit[HABIT_DEMOCRACY] <= 1)
      match -= 5;
      if (ch->pcdata->habit[HABIT_EQUALITY] <= 1)
      match -= 10;
      else if (ch->pcdata->habit[HABIT_EQUALITY] == 2)
      match -= 2;
      else
      match += 10;
      if (ch->pcdata->habit[HABIT_CRUELTY] >= 6)
      match -= 10;
      else if (ch->pcdata->habit[HABIT_CRUELTY] <= 3)
      match += 10;
    }
    else if (fac->axes[AXES_CORRUPT] == AXES_FARRIGHT) {
      if (ch->pcdata->habit[HABIT_CONCERN] >= 7)
      match += 50;
      else if (ch->pcdata->habit[HABIT_CONCERN] <= 5)
      match -= 30;
      if (ch->pcdata->habit[HABIT_DEMOCRACY] <= 1)
      match += 20;
      if (ch->pcdata->habit[HABIT_EQUALITY] <= 1)
      match += 50;
      else if (ch->pcdata->habit[HABIT_EQUALITY] == 2)
      match += 10;
      else
      match -= 50;
      if (ch->pcdata->habit[HABIT_CRUELTY] >= 6)
      match += 50;
      else if (ch->pcdata->habit[HABIT_CRUELTY] <= 3)
      match -= 50;
    }
    else if (fac->axes[AXES_CORRUPT] == AXES_MIDRIGHT) {
      if (ch->pcdata->habit[HABIT_CONCERN] >= 7)
      match += 20;
      else if (ch->pcdata->habit[HABIT_CONCERN] <= 5)
      match -= 15;
      if (ch->pcdata->habit[HABIT_DEMOCRACY] <= 1)
      match += 10;
      if (ch->pcdata->habit[HABIT_EQUALITY] <= 1)
      match += 25;
      else if (ch->pcdata->habit[HABIT_EQUALITY] == 2)
      match += 5;
      else
      match -= 20;
      if (ch->pcdata->habit[HABIT_CRUELTY] >= 6)
      match += 20;
      else if (ch->pcdata->habit[HABIT_CRUELTY] <= 3)
      match -= 20;
    }
    else if (fac->axes[AXES_CORRUPT] == AXES_NEARRIGHT) {
      if (ch->pcdata->habit[HABIT_CONCERN] >= 7)
      match += 10;
      else if (ch->pcdata->habit[HABIT_CONCERN] <= 5)
      match -= 5;
      if (ch->pcdata->habit[HABIT_DEMOCRACY] <= 1)
      match += 5;
      if (ch->pcdata->habit[HABIT_EQUALITY] <= 1)
      match += 10;
      else if (ch->pcdata->habit[HABIT_EQUALITY] == 2)
      match += 2;
      else
      match -= 10;
      if (ch->pcdata->habit[HABIT_CRUELTY] >= 6)
      match += 10;
      else if (ch->pcdata->habit[HABIT_CRUELTY] <= 3)
      match -= 10;
    }
    else if (fac->axes[AXES_CORRUPT] == AXES_NEUTRAL) {
      if (ch->pcdata->habit[HABIT_CONCERN] <= 2 || ch->pcdata->habit[HABIT_CONCERN] >= 7)
      match -= 20;
      if (ch->pcdata->habit[HABIT_DEMOCRACY] <= 1 || ch->pcdata->habit[HABIT_DEMOCRACY] >= 4)
      match -= 20;
      if (ch->pcdata->habit[HABIT_EQUALITY] <= 1 || ch->pcdata->habit[HABIT_EQUALITY] >= 5)
      match -= 20;
    }
    if (fac->axes[AXES_DEMOCRATIC] == AXES_FARLEFT) {
      if (ch->pcdata->habit[HABIT_DEMOCRACY] <= 2)
      match -= 50;
      else if (ch->pcdata->habit[HABIT_DEMOCRACY] >= 4)
      match += 50;
    }
    else if (fac->axes[AXES_DEMOCRATIC] == AXES_MIDLEFT) {
      if (ch->pcdata->habit[HABIT_DEMOCRACY] <= 2)
      match -= 20;
      else if (ch->pcdata->habit[HABIT_DEMOCRACY] >= 4)
      match += 20;
    }
    else if (fac->axes[AXES_DEMOCRATIC] == AXES_NEARLEFT) {
      if (ch->pcdata->habit[HABIT_DEMOCRACY] <= 2)
      match -= 10;
      else if (ch->pcdata->habit[HABIT_DEMOCRACY] >= 4)
      match += 10;
    }
    else if (fac->axes[AXES_DEMOCRATIC] == AXES_FARRIGHT) {
      if (ch->pcdata->habit[HABIT_DEMOCRACY] <= 2)
      match += 50;
      else if (ch->pcdata->habit[HABIT_DEMOCRACY] >= 4)
      match -= 50;
    }
    else if (fac->axes[AXES_DEMOCRATIC] == AXES_MIDRIGHT) {
      if (ch->pcdata->habit[HABIT_DEMOCRACY] <= 2)
      match += 20;
      else if (ch->pcdata->habit[HABIT_DEMOCRACY] >= 4)
      match -= 20;
    }
    else if (fac->axes[AXES_DEMOCRATIC] == AXES_NEARRIGHT) {
      if (ch->pcdata->habit[HABIT_DEMOCRACY] <= 2)
      match += 10;
      else if (ch->pcdata->habit[HABIT_DEMOCRACY] >= 4)
      match -= 10;
    }
    else if (fac->axes[AXES_DEMOCRATIC] == AXES_NEUTRAL) {
      if (ch->pcdata->habit[HABIT_DEMOCRACY] <= 1)
      match -= 20;
      else if (ch->pcdata->habit[HABIT_DEMOCRACY] >= 4)
      match -= 20;
    }

    if (fac->axes[AXES_ANARCHY] == AXES_FARLEFT) {
      if (ch->pcdata->habit[HABIT_DEMOCRACY] <= 1)
      match -= 20;
      else if (ch->pcdata->habit[HABIT_DEMOCRACY] >= 5)
      match -= 10;
      if (ch->pcdata->habit[HABIT_EQUALITY] <= 1)
      match -= 20;
      else if (ch->pcdata->habit[HABIT_EQUALITY] >= 6)
      match -= 20;
      else
      match += 20;
    }
    else if (fac->axes[AXES_ANARCHY] == AXES_MIDLEFT) {
      if (ch->pcdata->habit[HABIT_DEMOCRACY] <= 1)
      match -= 10;
      else if (ch->pcdata->habit[HABIT_DEMOCRACY] >= 5)
      match -= 5;
      if (ch->pcdata->habit[HABIT_EQUALITY] <= 1)
      match -= 10;
      else if (ch->pcdata->habit[HABIT_EQUALITY] >= 6)
      match -= 10;
      else
      match += 10;
    }
    else if (fac->axes[AXES_ANARCHY] == AXES_NEARLEFT) {
      if (ch->pcdata->habit[HABIT_DEMOCRACY] <= 1)
      match -= 5;
      else if (ch->pcdata->habit[HABIT_DEMOCRACY] >= 5)
      match -= 2;
      if (ch->pcdata->habit[HABIT_EQUALITY] <= 1)
      match -= 5;
      else if (ch->pcdata->habit[HABIT_EQUALITY] >= 6)
      match -= 5;
      else
      match += 5;
    }
    else if (fac->axes[AXES_ANARCHY] == AXES_FARRIGHT) {
      if (ch->pcdata->habit[HABIT_DEMOCRACY] <= 1)
      match += 20;
      else if (ch->pcdata->habit[HABIT_DEMOCRACY] >= 5)
      match += 10;
      if (ch->pcdata->habit[HABIT_EQUALITY] <= 1)
      match += 20;
      else if (ch->pcdata->habit[HABIT_EQUALITY] >= 6)
      match += 20;
      else
      match -= 20;
    }
    else if (fac->axes[AXES_ANARCHY] == AXES_MIDRIGHT) {
      if (ch->pcdata->habit[HABIT_DEMOCRACY] <= 1)
      match += 10;
      else if (ch->pcdata->habit[HABIT_DEMOCRACY] >= 5)
      match += 5;
      if (ch->pcdata->habit[HABIT_EQUALITY] <= 1)
      match += 10;
      else if (ch->pcdata->habit[HABIT_EQUALITY] >= 6)
      match += 10;
      else
      match -= 10;
    }
    else if (fac->axes[AXES_ANARCHY] == AXES_NEARRIGHT) {
      if (ch->pcdata->habit[HABIT_DEMOCRACY] <= 1)
      match += 5;
      else if (ch->pcdata->habit[HABIT_DEMOCRACY] >= 5)
      match += 2;
      if (ch->pcdata->habit[HABIT_EQUALITY] <= 1)
      match += 5;
      else if (ch->pcdata->habit[HABIT_EQUALITY] >= 6)
      match += 5;
      else
      match -= 5;
    }
    if (ch->pcdata->habit[HABIT_INTEL] == 4) {
      if (match < 0)
      match *= 4;
      else
      match *= 2;
    }
    else if (ch->pcdata->habit[HABIT_INTEL] == 3) {
      if (match < 0)
      match *= 2;
      else
      match = match * 3 / 2;
    }
    else if (ch->pcdata->habit[HABIT_INTEL] == 1) {
      match = match * 2 / 3;
    }
    else if (ch->pcdata->habit[HABIT_INTEL] == 0) {
      match = match / 2;
    }
    if (has_trust(ch, TRUST_PROMOTIONS, fac->vnum) == FALSE && match < 0)
    match = 25;

    return match;
  }

  _DOFUN(do_makecrystal) {
    int i = atoi(argument);
    if (i < 1 || i > 6) {
      send_to_char("Values are 1-6\n\r", ch);
      return;
    }
    create_crystal(ch->in_room, atoi(argument));
  }

  _DOFUN(do_ambush) {
    if (!IS_FLAG(ch->act, PLR_SHROUD)) {
      send_to_char("You need to be in the nightmare first.\n\r", ch);
      return;
    }
    send_to_char("You begin to manipulate the nightmare to allow for an ambush.\n\r", ch);
    ch->pcdata->ambush = 1;
  }

  bool youngvampire(CHAR_DATA *ch) {
    tm *ptm;
    time_t east_time;

    east_time = current_time;

    ptm = gmtime(&east_time);
    int year = ptm->tm_year + 1900;

    int daysvamp = ptm->tm_mday - ch->pcdata->sire_day;
    int monthsvamp = ptm->tm_mon + 1 - ch->pcdata->sire_month;
    int yearsvamp = year - ch->pcdata->sire_year;

    int days = daysvamp + (monthsvamp * 30) + (yearsvamp * 365);

    char buf[MSL];
    sprintf(buf, "%s %d: %d %d %d/%d %d %d", ch->name, days, ptm->tm_mday, ptm->tm_mon, year, ch->pcdata->sire_day, ch->pcdata->sire_month, ch->pcdata->sire_year);
    bug(buf, 0);

    if (days > 7 && days < 365)
    return TRUE;

    return FALSE;
  }

  int timesinceaccident(CHAR_DATA *ch) {

    if (ch->pcdata->lastaccident == 0)
    return 12;

    int time = ((current_time - ch->pcdata->lastaccident) / 3600 / 24 / 30);

    return time;
  }

  bool illegalstats(CHAR_DATA *ch) { return FALSE; }

  void contact_logon(CHAR_DATA *ch) {
    int infpoints = 0, planningpoints = 0, capitalpoints = 0, politicspoints = 0;
    int infcount = 0, capcount = 0, plancount = 0;

    if (ch->pcdata->account != NULL && ch->pcdata->account->socialcooldown <= current_time) {
      for (int i = 0; i < MAX_CONTACTS; i++) {
        int pointplus = skillpoint(get_skill(ch, contacts_table[i]));
        int xpointplus = pointplus * pointplus * pointplus;
        int newplus = sqrt(((int)(xpointplus)));
        if (ch->pcdata->contact_jobs[i] == CJOB_INFLUENCE && safe_strlen(ch->pcdata->contact_names[i]) > 2 && safe_strlen(ch->pcdata->contact_descs[i]) > 2) {
          infpoints += newplus;
          infcount++;
        }
        if (ch->pcdata->contact_jobs[i] == CJOB_CAPITAL && safe_strlen(ch->pcdata->contact_names[i]) > 2 && safe_strlen(ch->pcdata->contact_descs[i]) > 2) {
          capitalpoints += newplus;
          capcount++;
        }
        if (ch->pcdata->contact_jobs[i] == CJOB_POLITICS && safe_strlen(ch->pcdata->contact_names[i]) > 2 && safe_strlen(ch->pcdata->contact_descs[i]) > 2) {
          politicspoints += newplus;
          politicspoints++;
        }
        if (ch->pcdata->contact_jobs[i] == CJOB_PLANNING && safe_strlen(ch->pcdata->contact_names[i]) > 2 && safe_strlen(ch->pcdata->contact_descs[i]) > 2) {
          planningpoints += newplus;
          plancount++;
        }
      }

      planningpoints = planningpoints * (5 + get_skill(ch, SKILL_MOGULFOCUS)) / 5;
      char buf[MSL];
      sprintf(buf, "CONTACTS: %s, Inf: %d Cap: %d Politics:%d Planning:%d", ch->name, infpoints, capitalpoints, politicspoints, planningpoints);
      log_string(buf);
      infpoints *= 340;
      for (int x = 1; x < infcount; x++)
      infpoints = infpoints * 3 / 4;
      if (prof_focus(ch) == 0)
      infpoints = infpoints * 5 / 10;

      give_influence(ch, UMIN(infpoints, 10000));

      capitalpoints *= 1800;
      for (int x = 1; x < capcount; x++)
      capitalpoints = capitalpoints * 3 / 4;

      if (prof_focus(ch) == 0)
      capitalpoints /= 2;

      ch->pcdata->total_credit += UMIN(capitalpoints, 300000);

      planningpoints *= 350;
      for (int x = 1; x < plancount; x++)
      planningpoints = planningpoints * 4 / 5;
      if (prof_focus(ch) == 0)
      planningpoints = planningpoints * 3 / 4;

      if (planningpoints > 0)
      planningpoints = UMAX(500, planningpoints);

      ch->pcdata->scheme_influence += UMIN(planningpoints, 15000);

      if (politicspoints > 0) {
        give_respect(ch, politicspoints * 150, "Contacts", ch->faction);
        give_respect(ch, politicspoints * 75, "Contacts", ch->factiontwo);
      }
      if (infpoints > 0 || capitalpoints > 0)
      ch->pcdata->account->socialcooldown = current_time + (3600 * 18);
    }
  }

  void werewolf_escape(CHAR_DATA *ch) {
    char_from_room(ch);
    char_to_room(ch, random_inner_forest());

    if (IS_FLAG(ch->act, PLR_BOUND))
    REMOVE_FLAG(ch->act, PLR_BOUND);
    if (IS_FLAG(ch->act, PLR_BOUNDFEET))
    REMOVE_FLAG(ch->act, PLR_BOUNDFEET);
  }

  bool has_narratives(CHAR_DATA *ch) {
    for (int i = 0; i < 50; i++) {
      if (ch->pcdata->narrative_give[i] == 1) {
        return TRUE;
      }
      if (ch->pcdata->narrative_want[i] == 1) {
        return TRUE;
      }
    }
    return FALSE;
  }

  void habit_logon(CHAR_DATA *ch) {
    account_sync(ch);
    if (safe_strlen(ch->pcdata->enraptured) > 2 && !isalive(ch->pcdata->enraptured)) {
      breakcontrol(ch->name, 4);
      send_to_char("You are not longer enraptured.\n\r", ch);
    }
    if (safe_strlen(ch->pcdata->enthralled) > 2 && !isalive(ch->pcdata->enthralled)) {
      breakcontrol(ch->name, 3);
      send_to_char("You are not longer enthralled.\n\r", ch);
    }

    if (safe_strlen(ch->pcdata->pledge) > 2 && !isalive(ch->pcdata->pledge)) {
      free_string(ch->pcdata->pledge);
      ch->pcdata->pledge = str_dup("");
    }
    for (int i = 0; i < 5; i++) {
      if (safe_strlen(ch->pcdata->bonds[i]) > 2 && !isalive(ch->pcdata->bonds[i])) {
        free_string(ch->pcdata->bonds[i]);
        ch->pcdata->bonds[i] = str_dup("");
      }
    }
    for (int i = 0; i < 10; i++) {
      if (safe_strlen(ch->pcdata->relationship[i]) > 2 && !isalive(ch->pcdata->relationship[i])) {
        free_string(ch->pcdata->relationship[i]);
        ch->pcdata->relationship[i] = str_dup("");
        ch->pcdata->relationship_type[i] = 0;
        return;
      }
    }
    if (ch->pcdata->availability == AVAIL_NORMAL)
    printf_to_char(ch, "You have normal availability.\n\r");

    if (ch->played / 3600 > 50 && get_weekday() == 5 && get_hour(NULL) < 16) {
      if (ch->pcdata->account->villain_cooldown <= current_time) {
        if (ch->faction == 0 || clan_lookup(ch->faction) == NULL || clan_lookup(ch->faction)->axes[AXES_CORRUPT] > AXES_NEUTRAL) {
          message_to_char(ch->name, "You haven't praised a villain yet this week.\n\r");
        }
      }
    }
    if (ch->played / 3600 > 10) {

      if (ch->played / 3600 > 15 && safe_strlen(ch->pcdata->history) < 250 && !is_gm(ch) && ch->race != RACE_FANTASY) {
        message_to_char(ch->name, "You should write a history.");
      }
      if (ch->played / 3600 > 20 && !has_narratives(ch) && !is_gm(ch) && ch->race != RACE_FANTASY) {
        message_to_char(ch->name, "You should set your narrative rewards.(Help Narrative)\n\r");
      }
      if (ch->played / 3600 > 15 && safe_strlen(ch->pcdata->home_territory) < 2 && ch->race != RACE_LOCAL && ch->race != RACE_IMPORTANT && ch->race != RACE_CELEBRITY && ch->race != RACE_PILLAR && ch->race != RACE_FACULTY && ch->race != RACE_FANTASY)
      message_to_char(ch->name, "You should pick a territory to associate with.");

      if (ch->spentexp >= 750000 && ch->pcdata->recent_exp <= 0)
      message_to_char(ch->name, "Your combat skill feel rusty.\n\r");
    }

    if (IS_FLAG(ch->act, PLR_GUEST) && !guestplot(ch) && ch->pcdata->guest_type == GUEST_PLOT) {
      message_to_char(ch->name, "You need an active plot to use guests.\n\r");
      real_quit(ch);
      return;
    }
    do_function(ch, &do_imprint, "");
    if (ch->pcdata->account != NULL) {
      for (int i = 0; i < 25; i++) {
        DESCRIPTOR_DATA d;

        d.original = NULL;
        log_string("DESCRIPTOR: Account Checks");

        if (safe_strlen(ch->pcdata->account->characters[i]) > 2 && get_char_world_pc(ch->pcdata->account->characters[i]) == NULL && !load_char_obj(&d, ch->pcdata->account->characters[i])) {
          free_string(ch->pcdata->account->characters[i]);
          ch->pcdata->account->characters[i] = str_dup("");
        }
      }

      save_account(ch->pcdata->account, FALSE);
    }

    if (event_cleanse != 1) {
      for (int i = 0; i < SKILL_USED; i++) {
        int pointer = 0;
        int j;
        if (ch->skills[skill_table[i].vnum] > 0) {
          if (skilltype(skill_table[i].vnum) == STYPE_COMBATFOCUS && overcap_combat_focus(ch)) {
            char buf[MSL];
            sprintf(buf, "AUTONEGTRAIN Over Focus: %s stat too high, %s, %d", ch->name, skill_table[i].name, ch->skills[skill_table[i].vnum]);
            log_string(buf);
            do_function(ch, &do_negtrain, skill_table[i].name);
          }

          if (skilltype(skill_table[i].vnum) == STYPE_ARCANEFOCUS && overcap_arcane_focus(ch)) {
            char buf[MSL];
            sprintf(buf, "AUTONEGTRAIN Over Focus: %s stat too high, %s, %d", ch->name, skill_table[i].name, ch->skills[skill_table[i].vnum]);
            log_string(buf);
            do_function(ch, &do_negtrain, skill_table[i].name);
          }
          if (skilltype(skill_table[i].vnum) == STYPE_PROFFOCUS && overcap_prof_focus(ch)) {
            char buf[MSL];
            sprintf(buf, "AUTONEGTRAIN Over Focus: %s stat too high, %s, %d", ch->name, skill_table[i].name, ch->skills[skill_table[i].vnum]);
            log_string(buf);
            do_function(ch, &do_negtrain, skill_table[i].name);
          }

          ch->skills[skill_table[i].vnum]--;

          if (!has_requirements(ch, skill_table[i].vnum, ch->skills[skill_table[i].vnum] + 1, FALSE)) {
            ch->skills[skill_table[i].vnum]++;
            for (j = 0; j < 6; j++) {
              if (ch->skills[skill_table[i].vnum] == skill_table[i].levels[j])
              pointer = j;
            }
            if (pointer == 0)
            return;
            char buf[MSL];
            sprintf(buf, "AUTONEGTRAIN: %s stat too high, %s, %d", ch->name, skill_table[i].name, ch->skills[skill_table[i].vnum]);
            log_string(buf);
            do_function(ch, &do_negtrain, skill_table[i].name);
          }
          else {
            ch->skills[skill_table[i].vnum]++;
          }
        }
      }
    }

    if (is_vampire(ch) && event_aegis == 0) {
      if (ch->pcdata->habit[HABIT_FEEDING] == 0 && !is_abom(ch)) {
        if (youngvampire(ch) && timesinceaccident(ch) > 3 && ch->played / 3600 > 85 && number_percent() % 5 == 0) {
          send_to_char("You killed someone while feeding last night.\n\r", ch);

          AFFECT_DATA af;
          af.where = TO_AFFECTS;
          af.type = 0;
          af.level = 10;
          af.duration = 12 * 60 * 8;
          af.location = APPLY_NONE;
          af.modifier = 0;
          af.caster = NULL;
          af.weave = FALSE;
          af.bitvector = AFF_MARKED;
          affect_to_char(ch, &af);

          habit_corpse(ch, "Heart failure");
          coverup_cost(ch, 1);
          ch->pcdata->lastaccident = current_time;
        }
        else if (number_range(1, 2000) % 300 == 100 && ch->pcdata->lastaccident + (3600 * 24 * 7 * 4) <
            current_time) {
          send_to_char("You killed someone while feeding last night.\n\r", ch);

          AFFECT_DATA af;
          af.where = TO_AFFECTS;
          af.type = 0;
          af.level = 10;
          af.duration = 12 * 60 * 8;
          af.location = APPLY_NONE;
          af.modifier = 0;
          af.caster = NULL;
          af.weave = FALSE;
          af.bitvector = AFF_MARKED;
          affect_to_char(ch, &af);

          habit_corpse(ch, "Heart failure");
          coverup_cost(ch, 1);
          ch->pcdata->lastaccident = current_time;
        }
        else if (number_range(1, 2000) % 100 == 50 || (get_skill(ch, SKILL_HYPNOTISM) < 1 && number_percent() % 2 == 0)) {
          send_to_char("You wake up hungry.\n\r", ch);

          AFFECT_DATA af;
          af.where = TO_AFFECTS;
          af.type = 0;
          af.level = 10;
          af.duration = 12 * 60 * 2;
          af.location = APPLY_NONE;
          af.modifier = 0;
          af.caster = NULL;
          af.weave = FALSE;
          af.bitvector = AFF_WEAKEN;
          affect_to_char(ch, &af);
        }
      }
      else if (ch->pcdata->habit[HABIT_FEEDING] == 2 && !is_abom(ch)) {
        if (youngvampire(ch) && timesinceaccident(ch) > 3 && ch->played / 3600 > 85 && number_percent() % 3 == 0) {
          send_to_char("You killed someone while feeding last night.\n\r", ch);

          AFFECT_DATA af;
          af.where = TO_AFFECTS;
          af.type = 0;
          af.level = 10;
          af.duration = 12 * 60 * 8;
          af.location = APPLY_NONE;
          af.modifier = 0;
          af.caster = NULL;
          af.weave = FALSE;
          af.bitvector = AFF_MARKED;
          affect_to_char(ch, &af);

          habit_corpse(ch, "Heart failure");
          coverup_cost(ch, 1);
          ch->pcdata->lastaccident = current_time;
        }
        else if (number_range(1, 2000) % 100 == 25 && ch->pcdata->lastaccident + (3600 * 24 * 7 * 4) <
            current_time) {
          send_to_char("You killed someone while feeding last night.\n\r", ch);

          AFFECT_DATA af;
          af.where = TO_AFFECTS;
          af.type = 0;
          af.level = 10;
          af.duration = 12 * 60 * 8;
          af.location = APPLY_NONE;
          af.modifier = 0;
          af.caster = NULL;
          af.weave = FALSE;
          af.bitvector = AFF_MARKED;
          affect_to_char(ch, &af);

          habit_corpse(ch, "Heart failure");
          coverup_cost(ch, 1);
          ch->pcdata->lastaccident = current_time;

        }
        else if ((get_skill(ch, SKILL_HYPNOTISM) < 1 && number_percent() % 4 == 0)) {
          send_to_char("You wake up hungry.\n\r", ch);

          AFFECT_DATA af;
          af.where = TO_AFFECTS;
          af.type = 0;
          af.level = 10;
          af.duration = 12 * 60 * 2;
          af.location = APPLY_NONE;
          af.modifier = 0;
          af.caster = NULL;
          af.weave = FALSE;
          af.bitvector = AFF_WEAKEN;
          affect_to_char(ch, &af);
        }
      }
    }

    if (is_werewolf(ch) && event_aegis == 0 && (ch->pcdata->lastshift != 0 || ch->pcdata->lastshift > current_time - (3600 * 24 * 7 * 10))) {
      if (full_moon() == TRUE) {
        if (!is_abom(ch) && ch->pcdata->lastaccident == 0 && ch->played / 3600 > 200) {
          send_to_char("You killed someone while shifted during lunacy last night.\n\r", ch);
          werewolf_escape(ch);

          AFFECT_DATA af;
          af.where = TO_AFFECTS;
          af.type = 0;
          af.level = 10;
          af.duration = 12 * 60 * 8;
          af.location = APPLY_NONE;
          af.modifier = 0;
          af.caster = NULL;
          af.weave = FALSE;
          af.bitvector = AFF_MARKED;
          affect_to_char(ch, &af);

          coverup_cost(ch, 2);
          habit_corpse(ch, "Animal attack");
          ch->pcdata->lastaccident = current_time;

        }
        else if (ch->pcdata->habit[HABIT_LUNACY] == 3 && !is_abom(ch) && ch->pcdata->lastaccident + (3600 * 24 * 7 * 4 * 2) <
            current_time) {
          if (number_percent() % 2 == 0) {
            send_to_char("You killed someone while shifted during lunacy last night.\n\r", ch);
            werewolf_escape(ch);

            AFFECT_DATA af;
            af.where = TO_AFFECTS;
            af.type = 0;
            af.level = 10;
            af.duration = 12 * 60 * 8;
            af.location = APPLY_NONE;
            af.modifier = 0;
            af.caster = NULL;
            af.weave = FALSE;
            af.bitvector = AFF_MARKED;
            affect_to_char(ch, &af);

            coverup_cost(ch, 2);
            habit_corpse(ch, "Animal attack");
            ch->pcdata->lastaccident = current_time;

          }
          else {
            send_to_char("You seriously hurt someone while shifted during lunacy last night.\n\r", ch);
            werewolf_escape(ch);
            if (number_percent() % 4 == 0) {
              NEWS_TYPE *news;

              news = new_news();
              news->timer = 1000;
              free_string(news->message);
              news->message = str_dup("An animal attack is reported to have occured in Haven last night.");
              free_string(news->author);
              news->author = str_dup("Town Events");
              NewsVect.push_back(news);
            }

            AFFECT_DATA af;
            af.where = TO_AFFECTS;
            af.type = 0;
            af.level = 10;
            af.duration = 12 * 60 * 4;
            af.location = APPLY_NONE;
            af.modifier = 0;
            af.caster = NULL;
            af.weave = FALSE;
            af.bitvector = AFF_MARKED;
            affect_to_char(ch, &af);

            ch->pcdata->lastaccident = current_time;
          }
        }
        else if (ch->pcdata->habit[HABIT_LUNACY] == 1 && !is_abom(ch) && ch->pcdata->lastaccident + (3600 * 24 * 7 * 4 * 5) <
            current_time) {
          if (number_percent() % 2 == 0) {
            send_to_char("You killed someone while shifted during lunacy last night.\n\r", ch);
            werewolf_escape(ch);

            AFFECT_DATA af;
            af.where = TO_AFFECTS;
            af.type = 0;
            af.level = 10;
            af.duration = 12 * 60 * 8;
            af.location = APPLY_NONE;
            af.modifier = 0;
            af.caster = NULL;
            af.weave = FALSE;
            af.bitvector = AFF_MARKED;
            affect_to_char(ch, &af);

            coverup_cost(ch, 2);
            habit_corpse(ch, "Animal attack");
            ch->pcdata->lastaccident = current_time;

          }
          else {
            send_to_char("You seriously hurt someone while shifted during lunacy last night.\n\r", ch);
            werewolf_escape(ch);
            if (number_percent() % 4 == 0) {
              NEWS_TYPE *news;
              news = new_news();
              news->timer = 1000;
              free_string(news->message);
              news->message = str_dup("An animal attack is reported to have occured in Haven last night.");
              free_string(news->author);
              news->author = str_dup("Town Events");
              NewsVect.push_back(news);
            }

            AFFECT_DATA af;
            af.where = TO_AFFECTS;
            af.type = 0;
            af.level = 10;
            af.duration = 12 * 60 * 4;
            af.location = APPLY_NONE;
            af.modifier = 0;
            af.caster = NULL;
            af.weave = FALSE;
            af.bitvector = AFF_MARKED;
            affect_to_char(ch, &af);
            ch->pcdata->lastaccident = current_time;
          }
        }
        else if (ch->pcdata->habit[HABIT_LUNACY] == 0 && !is_abom(ch) && ch->pcdata->lastaccident + (3600 * 24 * 7 * 4 * 2) <
            current_time) {
          if (number_range(1, 10000) % 900 == 100) {
            if (number_percent() % 2 == 0) {
              send_to_char("You killed someone while shifted during lunacy last night.\n\r", ch);
              werewolf_escape(ch);

              AFFECT_DATA af;
              af.where = TO_AFFECTS;
              af.type = 0;
              af.level = 10;
              af.duration = 12 * 60 * 8;
              af.location = APPLY_NONE;
              af.modifier = 0;
              af.caster = NULL;
              af.weave = FALSE;
              af.bitvector = AFF_MARKED;
              affect_to_char(ch, &af);

              coverup_cost(ch, 2);
              habit_corpse(ch, "Animal attack");
              ch->pcdata->lastaccident = current_time;

            }
            else {
              send_to_char("You seriously hurt someone while shifted during lunacy last night.\n\r", ch);
              werewolf_escape(ch);
              if (number_percent() % 4 == 0) {
                NEWS_TYPE *news;

                news = new_news();
                news->timer = 1000;
                free_string(news->message);
                news->message = str_dup("An animal attack is reported to have occured in Haven last night.");
                free_string(news->author);
                news->author = str_dup("Town Events");
                NewsVect.push_back(news);
              }

              AFFECT_DATA af;
              af.where = TO_AFFECTS;
              af.type = 0;
              af.level = 10;
              af.duration = 12 * 60 * 4;
              af.location = APPLY_NONE;
              af.modifier = 0;
              af.caster = NULL;
              af.weave = FALSE;
              af.bitvector = AFF_MARKED;
              affect_to_char(ch, &af);
              ch->pcdata->lastaccident = current_time;
            }
          }
        }
        else if (ch->pcdata->habit[HABIT_LUNACY] == 2 && !is_abom(ch) && ch->pcdata->lastaccident + (3600 * 24 * 7 * 4 * 2) <
            current_time) {
          if (number_percent() % 2 == 0) {
            send_to_char("You killed someone while shifted during lunacy last night.\n\r", ch);
            werewolf_escape(ch);

            AFFECT_DATA af;
            af.where = TO_AFFECTS;
            af.type = 0;
            af.level = 10;
            af.duration = 12 * 60 * 8;
            af.location = APPLY_NONE;
            af.modifier = 0;
            af.caster = NULL;
            af.weave = FALSE;
            af.bitvector = AFF_MARKED;
            affect_to_char(ch, &af);

            coverup_cost(ch, 2);
            habit_corpse(ch, "Animal attack");
            ch->pcdata->lastaccident = current_time;
          }
          else {
            send_to_char("You seriously hurt someone while shifted during lunacy last night.\n\r", ch);
            werewolf_escape(ch);
            if (number_percent() % 4 == 0) {
              NEWS_TYPE *news;

              news = new_news();
              news->timer = 1000;
              free_string(news->message);
              news->message = str_dup("An animal attack is reported to have occured in Haven last night.");
              free_string(news->author);
              news->author = str_dup("Town Events");
              NewsVect.push_back(news);
            }

            AFFECT_DATA af;
            af.where = TO_AFFECTS;
            af.type = 0;
            af.level = 10;
            af.duration = 12 * 60 * 4;
            af.location = APPLY_NONE;
            af.modifier = 0;
            af.caster = NULL;
            af.weave = FALSE;
            af.bitvector = AFF_MARKED;
            affect_to_char(ch, &af);
            ch->pcdata->lastaccident = current_time;
          }
        }
      }
    }

    if (is_demonborn(ch)) {
      int percent = ch->pcdata->habit[HABIT_SADISM] * 10;
      if (number_percent() < percent) {
        send_to_char("You did something mean to someone yesterday.\n\r", ch);
      }
      else {
        percent *= 3;
        if (number_percent() > percent) {
          send_to_char("You wake up with an irritating stress headache.\n\r", ch);

          AFFECT_DATA af;
          af.where = TO_AFFECTS;
          af.type = 0;
          af.level = 10;
          af.duration = 12 * 60 * 1;
          af.location = APPLY_NONE;
          af.modifier = 0;
          af.caster = NULL;
          af.weave = FALSE;
          af.bitvector = AFF_WEAKEN;
          affect_to_char(ch, &af);
        }
      }
    }
    int behave = 0;
    if (!is_vampire(ch) && ch->pcdata->habit[HABIT_EATING] == 3 && number_percent() % 2 == 0) {
      send_to_char("You wake up hungry.\n\r", ch);

      AFFECT_DATA af;
      af.where = TO_AFFECTS;
      af.type = 0;
      af.level = 10;
      af.duration = 12 * 60;
      af.location = APPLY_NONE;
      af.modifier = 0;
      af.caster = NULL;
      af.weave = FALSE;
      af.bitvector = AFF_WEAKEN;
      affect_to_char(ch, &af);
      behave += 30;
    }

    behave += ch->pcdata->habit[HABIT_SMOKING];
    behave += ch->pcdata->habit[HABIT_DRINKING];
    behave += ch->pcdata->habit[HABIT_DRUGS];

    behave -= 2;

    behave -= ch->pcdata->habit[HABIT_GAMES];
    behave -= ch->pcdata->habit[HABIT_COMICS];
    behave -= ch->pcdata->habit[HABIT_NOVELS];

    ch->rpexp += ch->pcdata->habit[HABIT_NOVELS];

    if (ch->pcdata->habit[HABIT_DRINKING] >= 2) {
      int percent = ch->pcdata->habit[HABIT_SADISM] * 10;
      if (number_percent() < percent) {
        send_to_char("You wake up with a hangover.\n\r", ch);
        AFFECT_DATA af;
        af.where = TO_AFFECTS;
        af.type = 0;
        af.level = 10;
        af.duration = 12 * 60 * 1;
        af.location = APPLY_NONE;
        af.modifier = 0;
        af.caster = NULL;
        af.weave = FALSE;
        af.bitvector = AFF_WEAKEN;
        affect_to_char(ch, &af);
      }
    }
    if (ch->sex == SEX_FEMALE) {
      behave--;
      behave += ch->pcdata->habit[HABIT_CLUBBING];
    }
    social_behave_mod(ch, behave, "Habit logon.");

    ch->pcdata->fatigue += ch->pcdata->habit[HABIT_GYM] * 100;
    ch->pcdata->fatigue += ch->pcdata->habit[HABIT_CLUBBING] * 50;

    if (ch->pcdata->habit[HABIT_EATING] == 1)
    ch->pcdata->fatigue -= 250;
    if (ch->pcdata->habit[HABIT_EATING] == 4)
    ch->pcdata->fatigue -= 250;
  }

  _DOFUN(do_credits) {

    char arg[MSL];

    argument = one_argument_nouncap(argument, arg);
    if (!str_cmp(arg, "bandaid")) {
      if (ch->pcdata->account->bandaids <= 0 || ch->wounds <= 0 || ch->wounds > 2) {
        send_to_char("You don't have any bandaids, or you're not wounded, or you're too badly wounded\n\r", ch);
        return;
      }

      if (ch->in_room == NULL || !institute_room(ch->in_room)) {
        send_to_char("You need to be in the institute to do that.\n\r", ch);
        return;
      }
      if (ch->wounds == 2) {
        ch->wounds = 1;
        ch->heal_timer = 25000;
      }
      else if (ch->wounds == 1) {
        ch->wounds = 0;
        ch->heal_timer = 0;
      }

      send_to_char("You use your magic bandaid.\n\r", ch);
      ch->pcdata->account->bandaids--;
      return;
    }

    if (!str_cmp(arg, "rename")) {

      if (ch->pcdata->account->renames <= 0) {
        send_to_char("You don't have enough renames available.\n\r", ch);
        return;
      }
      if (rename_account(ch, argument) == TRUE) {
        ch->pcdata->account->renames--;
      }
    }

    if (!str_cmp(arg, "manifestation")) {
      if (available_donated(ch) < 750 && ch->race != RACE_DREAMCHILD) {
        send_to_char("You don't have enough credit for that.\n\r", ch);
        return;
      }
      free_string(ch->pcdata->caura);
      ch->pcdata->caura = str_dup(argument);

      printf_to_char(ch, "Your new dream manifestation string is: `r%s`x\n\r", ch->pcdata->caura);
      return;
    }
    if (!str_cmp(arg, "discname")) {
      if (available_donated(ch) < 1750) {
        send_to_char("You don't have enough credit for that.\n\r", ch);
        return;
      }
      if (in_fight(ch)) {
        send_to_char("Not while you're in combat.\n\r", ch);
        return;
      }
      free_string(ch->pcdata->cdisc_name);
      ch->pcdata->cdisc_name = str_dup(argument);

      printf_to_char(ch, "Your new custom discipline name is: %s\n\r", ch->pcdata->cdisc_name);
      return;
    }

    if (!str_cmp(arg, "walk")) {
      if (available_donated(ch) < 1250) {
        send_to_char("You don't have enough credit for that.\n\r", ch);
        return;
      }
      free_string(ch->pcdata->cwalk);
      ch->pcdata->cwalk = str_dup(argument);

      printf_to_char(ch, "Your new walk is: %s\n\r", ch->pcdata->cwalk);
      return;
    }
    // Changed it so that custom rank is displayed immediately upon being set and
    // added a check for rank length - Discordance
    if (!str_cmp(arg, "rank")) {
      if (available_donated(ch) < 2000) {
        send_to_char("You don't have enough credit for that.\n\r", ch);
        return;
      }
      else if (safe_strlen_color(str_dup(argument)) <= 1) {
        send_to_char("A custom rank must be longer than one character.\n\r", ch);
        return;
      }
      else if (safe_strlen_color(str_dup(argument)) > 12) {
        send_to_char("A custom rank must be 12 characters or less.\n\r", ch);
        return;
      }

      free_string(ch->pcdata->crank);
      ch->pcdata->crank = str_dup(argument);
      ch->pcdata->rank_type = 4;
      printf_to_char(ch, "`cYour new rank is`g:`x %s\n\r", ch->pcdata->crank);
      return;
    }

    printf_to_char(ch, "`cCommunity Credits`g:`x %d`x\n\r", available_donated(ch));
    printf_to_char(ch, "`cAccount Renames`g:`x   %d`x\n\r", ch->pcdata->account->renames);
    printf_to_char(ch, "`cRecolors`g:`x          %d`x\n\r", ch->pcdata->account->colours);
    printf_to_char(ch, "`cShadow attacks`g:`x    %d`x\n\r", available_donated(ch) / 500);
    printf_to_char(ch, "`cBandaids`g:`x          %d`x\n\r", ch->pcdata->account->bandaids);

    if (available_donated(ch) >= 750)
    send_to_char("`cCustom Manifestation`g:`x       Active`x\n\r", ch);
    else
    send_to_char("`cCustom Manifestation`g:`x       `DInactive`x\n\r", ch);

    if (available_donated(ch) >= 1000)
    send_to_char("`cOOC Channel`g:`x       Online`x\n\r", ch);
    else
    send_to_char("`cOOC Channel`g:`x       `DOffline`x\n\r", ch);

    if (available_donated(ch) >= 1250)
    send_to_char("`cCustom Walk`g:`x       Active`x\n\r", ch);
    else
    send_to_char("`cCustom Walk`g:`x       `DInactive`x\n\r", ch);

    if (available_donated(ch) >= 2000)
    send_to_char("`cCustom Rank`g:`x       Active`x\n\r", ch);
    else
    send_to_char("`cCustom Rank`g:`x       `DInactive`x\n\r", ch);

    if (available_donated(ch) >= 3000)
    send_to_char("`cLegends Channel`g:`x   Online`x\n\r", ch);
    else
    send_to_char("`cLegends Channel`g:`x   `DOffline`x\n\r", ch);
  }

  bool in_fistfight(CHAR_DATA *ch) {
    if (ch->fistfighting != NULL && institute_room(ch->in_room)) {
      if (clinic_staff(ch, FALSE) || college_staff(ch, FALSE)) {
        if (!clinic_staff(ch->fistfighting, FALSE) && !college_staff(ch->fistfighting, FALSE)) {
          ch->fistfighting->fistfighting = NULL;
          ch->fistfighting = NULL;
          return FALSE;
        }
      }
    }

    if (ch->fistfighting != NULL && ch->fistfighting->in_room == ch->in_room && ch->fistattack != 0)
    return TRUE;

    return FALSE;
  }

  int get_fistpower(CHAR_DATA *ch) {
    int chspent = UMAX(ch->spentexp, 1);

    int power = chspent / 10000;
    power = UMAX(power, 5);

    // 1-50ish

    power += get_skill(ch, SKILL_STRENGTH) * 15;
    power += get_skill(ch, SKILL_MARTIAL) * 5;

    power += UMAX(ch->disciplines[DIS_STRIKING], ch->disciplines[DIS_GRAPPLE]);

    if (ch->spentrpexp < 10000 && ch->spentexp < 10000 && ch->played / 3600 < 40)
    power /= 4;

    return power;
  }

  int get_endurance(CHAR_DATA *ch) {
    int chspent = UMAX(ch->spentexp, 1);

    int power = chspent / 10000;
    power = UMAX(power, 5);

    power += 10;
    // 1-50ish

    power += get_skill(ch, SKILL_FASTREFLEXES) * 5;
    power += get_skill(ch, SKILL_ACROBATICS) * 5;
    power += get_skill(ch, SKILL_STAMINA) * 10;

    power += get_skill(ch, SKILL_DEXTERITY) * 15;

    power += UMAX(ch->disciplines[DIS_STRIKING], ch->disciplines[DIS_GRAPPLE]);

    power *= 2;

    if (ch->spentrpexp < 10000 && ch->spentexp < 10000 && ch->played / 3600 < 40)
    power /= 4;

    return power;
  }

  void fistfight(CHAR_DATA *ch) {
    if (ch->fistfighting == NULL || ch->fistfighting->in_room != ch->in_room)
    return;

    CHAR_DATA *victim = ch->fistfighting;
    if (guestmonster(ch) || guestmonster(victim)) {
      ch->fistfighting = NULL;
      victim->fistfighting = NULL;
    }

    if (ch->endurance == 0)
    ch->endurance = get_endurance(ch);

    if (victim->endurance == 0)
    victim->endurance = get_endurance(victim);

    int dam = get_fistpower(ch) / 5;

    dam *= 5;

    if (ch->fistattack == FIST_HIGH && victim->guard == GUARD_HIGH) {
      dam /= 2;
      victim->endurance -= dam;
      if (victim->endurance <= 0) {
        if (victim->wounds == 0) {
          victim->endurance = get_endurance(victim);
          if (victim->wounds < 2)
          wound_char(victim, 1);
          else
          victim->heal_timer = victim->heal_timer * 4 / 3;
          act("$n breaks $N's nose with a punch.", ch, NULL, victim, TO_NOTVICT);
          act("$n breaks your nose with a punch.", ch, NULL, victim, TO_VICT);
          act("You break $N's nose with a punch.", ch, NULL, victim, TO_CHAR);
          if (is_sparring_room(victim->in_room))
          victim->heal_timer /= 25;
        }
        else {
          victim->pcdata->sleeping = 300;
          act("$n knocks $N out with a punch.", ch, NULL, victim, TO_NOTVICT);
          act("$n knocks you out with a punch.", ch, NULL, victim, TO_VICT);
          act("You knock $N out with a punch.", ch, NULL, victim, TO_CHAR);
          victim->fisttimer = 0;
          victim->fistattack = 0;
          ch->fistfighting = NULL;
          ch->fistattack = FIST_RETREAT;
        }
      }
      else if (victim->endurance < get_endurance(victim) / 2) {
        act("$n delivers a partially blocked punch to $N's head, making $M stagger.", ch, NULL, victim, TO_NOTVICT);
        act("$n delivers a partially blocked punch to your head, making you stagger.", ch, NULL, victim, TO_VICT);
        act("You deliver a partially blocked punch to $N's head, making $M stagger.", ch, NULL, victim, TO_CHAR);
      }
      else {
        act("$n delivers a partially blocked punch to $N's head.", ch, NULL, victim, TO_NOTVICT);
        act("$n delivers a partially blocked punch to your head.", ch, NULL, victim, TO_VICT);
        act("You deliver a partially blocked punch to $N's head.", ch, NULL, victim, TO_CHAR);
      }
    }
    else if (ch->fistattack == FIST_HIGH) {
      victim->endurance -= dam;
      if (victim->endurance <= 0) {
        if (victim->wounds == 0) {
          victim->endurance = get_endurance(victim);
          wound_char(victim, 1);
          act("$n breaks $N's nose with a punch.", ch, NULL, victim, TO_NOTVICT);
          act("$n breaks your nose with a punch.", ch, NULL, victim, TO_VICT);
          act("You break $N's nose with a punch.", ch, NULL, victim, TO_CHAR);
          if (is_sparring_room(victim->in_room))
          victim->heal_timer /= 25;
        }
        else {
          victim->pcdata->sleeping = 300;
          act("$n knocks $N out with a punch.", ch, NULL, victim, TO_NOTVICT);
          act("$n knocks you out with a punch.", ch, NULL, victim, TO_VICT);
          act("You knock $N out with a punch.", ch, NULL, victim, TO_CHAR);
          victim->fisttimer = 0;
          victim->fistattack = 0;
          ch->fistfighting = NULL;
          ch->fistattack = FIST_RETREAT;
        }
      }
      else if (victim->endurance < get_endurance(victim) / 2) {
        act("$n delivers a punch to $N's head, making $M stagger.", ch, NULL, victim, TO_NOTVICT);
        act("$n delivers a punch to your head, making you stagger.", ch, NULL, victim, TO_VICT);
        act("You deliver a punch to $N's head, making $M stagger.", ch, NULL, victim, TO_CHAR);
      }
      else {
        act("$n delivers a punch to $N's head.", ch, NULL, victim, TO_NOTVICT);
        act("$n delivers a punch to your head.", ch, NULL, victim, TO_VICT);
        act("You deliver a punch to $N's head.", ch, NULL, victim, TO_CHAR);
      }
    }
    else if (ch->fistattack == FIST_LOW && victim->guard == GUARD_LOW) {
      dam /= 2;
      victim->endurance -= dam;
      if (victim->endurance <= 0) {
        if (victim->wounds == 0) {
          victim->endurance = get_endurance(victim);
          wound_char(victim, 1);
          act("$n bruises $N's ribs with a punch.", ch, NULL, victim, TO_NOTVICT);
          act("$n brusies your ribs with a punch.", ch, NULL, victim, TO_VICT);
          act("You bruise $N's ribs with a punch.", ch, NULL, victim, TO_CHAR);
          if (is_sparring_room(victim->in_room))
          victim->heal_timer /= 25;
        }
        else {
          if (victim->wounds < 2)
          wound_char(victim, 1);
          else
          victim->heal_timer = victim->heal_timer * 4 / 3;
          act("$n cracks $N's ribs with a punch, causing $M to fall to the ground.", ch, NULL, victim, TO_NOTVICT);
          act("$n cracks your ribs with a punch, causing you to fall to the ground.", ch, NULL, victim, TO_VICT);
          act("You crack $N's ribs with a punch. causing $M to fall to the ground", ch, NULL, victim, TO_CHAR);
          victim->fisttimer = 0;
          victim->fistattack = 0;
          ch->fistfighting = NULL;
          ch->fistattack = FIST_RETREAT;
          if (is_sparring_room(victim->in_room))
          victim->heal_timer /= 25;
        }
      }
      else if (victim->endurance < get_endurance(victim) / 2) {
        act("$n delivers a partially blocked punch to $N's torso, making $M stagger.", ch, NULL, victim, TO_NOTVICT);
        act("$n delivers a partially blocked punch to your torso, making you stagger.", ch, NULL, victim, TO_VICT);
        act("You deliver a partially blocked punch to $N's torso, making $M stagger.", ch, NULL, victim, TO_CHAR);
      }
      else {
        act("$n delivers a partially blocked punch to $N's torso.", ch, NULL, victim, TO_NOTVICT);
        act("$n delivers a partially blocked punch to your torso.", ch, NULL, victim, TO_VICT);
        act("You deliver a partially blocked punch to $N's torso.", ch, NULL, victim, TO_CHAR);
      }
    }
    else if (ch->fistattack == FIST_LOW) {
      victim->endurance -= dam;
      if (victim->endurance <= 0) {
        if (victim->wounds == 0) {
          victim->endurance = get_endurance(victim);
          wound_char(victim, 1);
          act("$n bruises $N's ribs with a punch.", ch, NULL, victim, TO_NOTVICT);
          act("$n brusies your ribs with a punch.", ch, NULL, victim, TO_VICT);
          act("You bruise $N's ribs with a punch.", ch, NULL, victim, TO_CHAR);
          if (is_sparring_room(victim->in_room))
          victim->heal_timer /= 25;
        }
        else {
          if (victim->wounds < 2)
          wound_char(victim, 1);
          else
          victim->heal_timer = victim->heal_timer * 4 / 3;
          act("$n cracks $N's ribs with a punch, causing $M to fall to the ground.", ch, NULL, victim, TO_NOTVICT);
          act("$n cracks your ribs with a punch, causing you to fall to the ground.", ch, NULL, victim, TO_VICT);
          act("You crack $N's ribs with a punch. causing $M to fall to the ground", ch, NULL, victim, TO_CHAR);
          victim->fisttimer = 0;
          victim->fistattack = 0;
          ch->fistfighting = NULL;
          ch->fistattack = FIST_RETREAT;
          if (is_sparring_room(victim->in_room))
          victim->heal_timer /= 25;
        }
      }
      else if (victim->endurance < get_endurance(victim) / 2) {
        act("$n delivers a punch to $N's torso, making $M stagger.", ch, NULL, victim, TO_NOTVICT);
        act("$n delivers a punch to your torso, making you stagger.", ch, NULL, victim, TO_VICT);
        act("You deliver a punch to $N's torso, making $M stagger.", ch, NULL, victim, TO_CHAR);
      }
      else {
        act("$n delivers a punch to $N's torso.", ch, NULL, victim, TO_NOTVICT);
        act("$n delivers a punch to your torso.", ch, NULL, victim, TO_VICT);
        act("You deliver a punch to $N's torso.", ch, NULL, victim, TO_CHAR);
      }
    }
    else if (ch->fistattack == FIST_RETREAT) {
      act("$n retreats from the fist fight.", ch, NULL, victim, TO_ROOM);
      act("You retreat from the fist fight.", ch, NULL, victim, TO_CHAR);
      ch->fisttimer = 0;
      ch->fistattack = 0;
      return;
    }

    ch->fisttimer = 180;
    //    printf_to_char(victim, "%d", victim->endurance);
  }

  _DOFUN(do_implantdream) {
    char arg1[MSL];
    CHAR_DATA *victim;
    if(!higher_power(ch))
    {
      send_to_char("Only Eidolons can do that.\n\r", ch);
      return;
    }
    argument = one_argument_nouncap(argument, arg1);
    struct stat sb;
    char buf[MIL];
    Buffer outbuf;
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    d.original = NULL;
    if (safe_strlen(arg1) < 2)
    {
      send_to_char("Syntax: implantdream (target) (message)\n\r", ch);
      return;
    }
    if (safe_strlen(argument) < 2)
    {
      send_to_char("Syntax: implantdream (target) (message)\n\r", ch);
      return;
    }

    if ((victim = get_char_world_pc(arg1)) != NULL) // Victim is online.
    online = TRUE;
    else {
      if (!load_char_obj(&d, arg1)) {
        return;
      }

      sprintf(buf, "%s%s", PLAYER_DIR, capitalize(arg1));
      stat(buf, &sb);
      victim = d.character;
    }
    if (IS_NPC(victim)) {
      if (!online)
      free_char(victim);
      return;
    }
    if(light_level(victim->in_room) > 50)
    {
      send_to_char("That room isn't dark enough.\n\r", ch);
      return;
    }
    free_string(victim->pcdata->implant_dream);
    victim->pcdata->implant_dream = str_dup(argument);
    send_to_char("Done.\n\r", ch);
    save_char_obj(victim, FALSE, FALSE);
    if (!online)
    free_char(victim);
  }

  int eidilon_clan_lookup(char *argument) {
    struct stat sb;
    char buf[MIL];
    Buffer outbuf;
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    CHAR_DATA *victim;
    d.original = NULL;
    if (safe_strlen(argument) < 2)
    return 0;

    if ((victim = get_char_world_pc(argument)) != NULL) // Victim is online.
    online = TRUE;
    else {
      if (!load_char_obj(&d, argument)) {
        return 0;
      }

      sprintf(buf, "%s%s", PLAYER_DIR, capitalize(argument));
      stat(buf, &sb);
      victim = d.character;
    }
    if (IS_NPC(victim)) {
      if (!online)
      free_char(victim);
      return 0;
    }
    int point = victim->pcdata->eidilon_of;
    if (!online)
    free_char(victim);
    return point;


  }

  void offline_reward(char *argument, int type, int amount, CHAR_DATA *restrict) {
    struct stat sb;
    char buf[MIL];
    Buffer outbuf;
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    CHAR_DATA *victim;
    d.original = NULL;
    if (safe_strlen(argument) < 2)
    return;

    if ((victim = get_char_world_pc(argument)) != NULL) // Victim is online.
    online = TRUE;
    else {
      if (!load_char_obj(&d, argument)) {
        return;
      }

      sprintf(buf, "%s%s", PLAYER_DIR, capitalize(argument));
      stat(buf, &sb);
      victim = d.character;
    }
    if (IS_NPC(victim)) {
      if (!online)
      free_char(victim);
      return;
    }

    if (restrict != NULL) {
      if (same_player(victim, restrict) || (victim->pcdata->account != NULL && restrict->pcdata->account != NULL && victim->pcdata->account == restrict->pcdata->account)) {
        if (!online)
        free_char(victim);
        return;
      }
    }

    if (type == TYPE_KARMA) {
      victim->karma += amount;
      victim->pcdata->earned_karma += amount;
    }
    else if (type == TYPE_DEXP) {
      victim->pcdata->dexp += amount;
    }

    save_char_obj(victim, FALSE, FALSE);

    if (!online)
    free_char(victim);
  }

  _DOFUN(do_influence) {
    char arg1[MSL];
    char arg2[MSL];
    int amount = 0;
    argument = one_argument_nouncap(argument, arg1);
    argument = one_argument_nouncap(argument, arg2);

    if (!str_cmp(arg1, "buy")) {
      if (!str_cmp(arg2, "money")) {
        if (ch->played / 3600 < 20) {
          send_to_char("Play the game a bit more first.\n\r", ch);
          return;
        }
        amount = atoi(argument);
        if (amount < 1 || amount > ch->pcdata->influence) {
          send_to_char("Syntax: Influence buy money (amount)\n\r", ch);
          return;
        }
        ch->money += 2 * amount;
        ch->pcdata->influence -= amount;
        send_to_char("Done.\n\r", ch);
      }
      else if (!str_cmp(arg2, "experience")) {
        amount = atoi(argument);
        if (amount < 1 || amount > ch->pcdata->influence) {
          send_to_char("Syntax: Influence buy experience (amount)\n\r", ch);
          return;
        }
        ch->pcdata->account->xp += amount / 2;
        ch->pcdata->influence -= amount;
        send_to_char("Done.\n\r", ch);
      }
      else
      send_to_char("Syntax: Influence buy money/experience (amount)\n\r", ch);

      return;
    }
    else if (!str_cmp(arg1, "sell")) {
      if (!str_cmp(arg2, "Money")) {
        if (ch->played / 3600 < 20) {
          send_to_char("Play the game a bit more first.\n\r", ch);
          return;
        }

        amount = atoi(argument);
        if (amount < 1 || amount > ch->money / 100) {
          send_to_char("Syntax: Influence sell money (amount)\n\r", ch);
          return;
        }
        ch->money -= amount * 100;
        ch->pcdata->influence += amount * 10;
        send_to_char("Done.\n\r", ch);
        return;
      }
      else if (!str_cmp(arg2, "experience")) {
        amount = atoi(argument);
        if (amount < 1 || amount > ch->pcdata->account->xp) {
          send_to_char("Syntax: Influence sell experience (amount)\n\r", ch);
          return;
        }
        ch->pcdata->account->xp -= amount;
        ch->pcdata->influence += amount;
        send_to_char("Done.\n\r", ch);
        return;
      }
    }
    send_to_char("Syntax: Influence buy/sell money/experience (amount)\n\r", ch);
  }

  _DOFUN(do_bloodaura) {
    CHAR_DATA *victim;
    char arg1[MSL];
    char buf[MSL];
    struct stat sb;
    DESCRIPTOR_DATA d;
    bool online = FALSE;

    if(ch->pcdata->summary_type == SUMMARY_VICTIMIZER)
    {
      CHAR_DATA *target = ch->pcdata->summary_target;
      if(target == NULL)
      return;
      if(!str_cmp(argument, "yes"))
      {
        ch->pcdata->summary_blood = 1;
        if(safe_strlen(ch->pcdata->summary_content) < 2)
        {
          send_to_char("You will take blood, use content (emote text) to write the content of your summary.\n\r", ch);
          return;
        }
        process_emote(ch, NULL, EMOTE_EMOTE, ch->pcdata->summary_content);
        ch->pcdata->summary_stage = SUM_STAGE_WAITING;
        target->pcdata->summary_stage = SUM_STAGE_CONTENT;
        send_to_char("You can now write your own content pose in response, use content (emote text) to do so. You can also set how much life force you think would be taken from you if your captor is feeding from your psychic distress, use lifeforce (1-100) to set this. You can also set if you would give up intel, use intel (yes/no) to set this.\n\r", target);
        return;

      }
      else if(!str_cmp(argument, "no"))
      {
        ch->pcdata->summary_blood = 2;
        if(safe_strlen(ch->pcdata->summary_content) < 2)
        {
          send_to_char("You will not take blood, use content (emote text) to write the content of your summary.\n\r", ch);
          return;
        }
        process_emote(ch, NULL, EMOTE_EMOTE, ch->pcdata->summary_content);
        ch->pcdata->summary_stage = SUM_STAGE_WAITING;
        target->pcdata->summary_stage = SUM_STAGE_CONTENT;
        send_to_char("You can now write your own content pose in response, use content (emote text) to do so. You can also set how much life force you think would be taken from you if your captor is feeding from your psychic distress, use lifeforce (1-100) to set this. You can also set if you would give up intel, use intel (yes/no) to set this.\n\r", target);
        return;
      }
    }

    if (!is_leader(ch, ch->faction) && !IS_IMMORTAL(ch) && !is_second(ch, ch->faction)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (is_helpless(ch)) {
      send_to_char("You're not free to do that.\n\r", ch);
      return;
    }
    if (ch->faction == 0 || clan_lookup(ch->faction) == NULL || clan_lookup(ch->faction)->resource < 6500) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }

    argument = one_argument_nouncap(argument, arg1);

    if (safe_strlen(arg1) < 2)
    return;

    if (!str_cmp(arg1, "cloaked") || !str_cmp(arg1, "masked")) {
      bool found = FALSE;
      CHAR_DATA *to;
      for (DescList::iterator it = descriptor_list.begin();
      it != descriptor_list.end(); ++it) {
        DESCRIPTOR_DATA *d = *it;

        if (d != NULL && d->character != NULL && d->connected == CON_PLAYING) {
          to = d->character;
          if (IS_NPC(to))
          continue;
          if (to == ch)
          continue;
          if (to->in_room == NULL || ch->in_room == NULL)
          continue;

          if (!str_cmp(arg1, "cloaked") && IS_FLAG(to->comm, COMM_CLOAKED)) {
            if (IS_AFFECTED(to, AFF_MARKED) && has_proxy(ch)) {
              to->pcdata->bloodaura = 60 * 50;
              send_to_char("You mark them for their crimes.\n\r", ch);
              found = TRUE;
            }
            else if (IS_AFFECTED(to, AFF_MARKED2) && (ch->faction == to->faction || to->faction == 0)) {
              to->pcdata->bloodaura = 60 * 50;
              send_to_char("You mark them for their crimes.\n\r", ch);
              found = TRUE;
            }
            else if (IS_AFFECTED(to, AFF_MARKED3)) {
              to->pcdata->bloodaura = 60 * 50;
              send_to_char("You mark them for their crimes.\n\r", ch);
              found = TRUE;
            }
          }
          if (!str_cmp(arg1, "masked") && is_masked(to)) {
            if (IS_AFFECTED(to, AFF_MARKED) && has_proxy(ch)) {
              to->pcdata->bloodaura = 60 * 50;
              send_to_char("You mark them for their crimes.\n\r", ch);
              found = TRUE;
            }
            else if (IS_AFFECTED(to, AFF_MARKED2) && (ch->faction == to->faction || to->faction == 0)) {
              to->pcdata->bloodaura = 60 * 50;
              send_to_char("You mark them for their crimes.\n\r", ch);
              found = TRUE;
            }
            else if (IS_AFFECTED(to, AFF_MARKED3)) {
              to->pcdata->bloodaura = 60 * 50;
              send_to_char("You mark them for their crimes.\n\r", ch);
              found = TRUE;
            }
          }
          if (found == FALSE) {
            send_to_char("The magic backlashes against you.\n\r", ch);
            wound_char_noregen(ch, 1);
          }
          return;
        }
      }
    }

    if ((victim = get_char_world(ch, arg1)) == NULL) {
      if ((victim = get_char_world_pc(arg1)) == NULL) {
        log_string("DESCRIPTOR: Bloodaura");

        if (!load_char_obj(&d, arg1)) {
          printf_to_char(ch, "\n\r%s is not a character!\n\r", capitalize(arg1));
          return;
        }
        sprintf(buf, "%s%s", PLAYER_DIR, capitalize(arg1));
        stat(buf, &sb);
        victim = d.character;
      }
      else
      online = TRUE;
    }
    else
    online = TRUE;

    if (victim == NULL || !victim)
    return;

    if (IS_IMMORTAL(ch) && victim->pcdata->bloodaura > 0) {
      victim->pcdata->bloodaura = 0;
      send_to_char("You remove their bloodaura.\n\r", ch);
      save_char_obj(victim, FALSE, FALSE);
      if (!online)
      free_char(victim);
      return;
    }

    if (IS_AFFECTED(victim, AFF_MARKED) && has_proxy(ch)) {
      victim->pcdata->bloodaura = 60 * 50;
      send_to_char("You mark them for their crimes.\n\r", ch);
      save_char_obj(victim, FALSE, FALSE);
      if (!online)
      free_char(victim);
      return;
    }
    else if (IS_AFFECTED(victim, AFF_MARKED2) && (ch->faction == victim->faction || victim->faction == 0)) {
      victim->pcdata->bloodaura = 60 * 50;
      send_to_char("You mark them for their crimes.\n\r", ch);
      save_char_obj(victim, FALSE, FALSE);
      if (!online)
      free_char(victim);
      return;
    }
    else if (IS_AFFECTED(victim, AFF_MARKED3)) {
      victim->pcdata->bloodaura = 60 * 50;
      send_to_char("You mark them for their crimes.\n\r", ch);
      save_char_obj(victim, FALSE, FALSE);
      if (!online)
      free_char(victim);
      return;
    }
    else if (IS_IMMORTAL(ch)) {
      victim->pcdata->bloodaura = 60 * 50;
      send_to_char("You mark them for their crimes.\n\r", ch);
      save_char_obj(victim, FALSE, FALSE);
      if (!online)
      free_char(victim);
      return;
    }
    else if (!IS_AFFECTED(victim, AFF_MARKED) && !IS_AFFECTED(victim, AFF_MARKED2) && !IS_AFFECTED(victim, AFF_MARKED3)) {
      send_to_char("The magic backlashes against you.\n\r", ch);
      wound_char_noregen(ch, 1);
      if (!online)
      free_char(victim);
    }
    else {
      send_to_char("You can't do that.\n\r", ch);
      if (!online)
      free_char(victim);
      return;
    }
    if (ch->pcdata->proxies > 0)
    ch->pcdata->proxies--;
  }

  void under_taint(CHAR_DATA *ch, CHAR_DATA *victim, int time) {
    AFFECT_DATA af;
    af.where = TO_AFFECTS;
    af.type = 0;
    af.level = 10;
    af.duration = time;
    af.location = APPLY_NONE;
    af.modifier = 0;
    af.caster = NULL;
    af.weave = FALSE;
    if (ch->faction == victim->faction && ch->faction != 0)
    af.bitvector = AFF_MARKED2;
    else if (is_masked(ch) || IS_FLAG(ch->comm, COMM_CLOAKED))
    af.bitvector = AFF_MARKED3;
    else
    af.bitvector = AFF_MARKED;

    affect_to_char(ch, &af);
  }

  _DOFUN(do_cannibalize) {
    CHAR_DATA *victim;
    char arg1[MSL];
    char arg2[MSL];

    argument = one_argument_nouncap(argument, arg1);
    argument = one_argument_nouncap(argument, arg2);

    if ((victim = get_char_world_pc(arg1)) != NULL && victim->pcdata->ghost_room == ch->in_room->vnum && (IS_FLAG(victim->act, PLR_GHOSTWALKING) || victim->pcdata->spectre > 0)) {
      if (is_helpless(ch)) {
        send_to_char("You can't do that.\n\r", ch);
        return;
      }

      if (is_ghost(ch)) {
        send_to_char("You can't get a grip on them.\n\r", ch);
        return;
      }

      wound_char_absolute(victim, 1);
      victim->pcdata->mark_timer[1] = 100;
      free_string(victim->pcdata->mark[1]);
      victim->pcdata->mark[1] = str_dup(argument);
      act("You eat some of their flesh.", ch, NULL, NULL, TO_CHAR);
      act("$n eats some of $N's flesh.", ch, NULL, victim, TO_NOTVICT);
      act("You feel a sudden, mysterious pain.", ch, NULL, victim, TO_VICT);
      return;
    }

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (is_pinned(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (!is_helpless(victim)) {
      send_to_char("You'd have to subdue them first.\n\r", ch);
      return;
    }

    if (is_ghost(victim)) {
      send_to_char("Wounding the dead is not so easy.", ch);
      return;
    }

    if (is_ghost(ch)) {
      send_to_char("Wounding the living is not so easy any more.", ch);
    }

    captive_command(ch, victim);

    wound_char_absolute(victim, 1);
    victim->pcdata->mark_timer[1] = 100;
    free_string(victim->pcdata->mark[1]);
    victim->pcdata->mark[1] = str_dup(argument);
    act("You eat some of their flesh.", ch, NULL, NULL, TO_CHAR);
    act("$n eats some of $N's flesh.", ch, NULL, victim, TO_NOTVICT);
    act("$n eats some of your flesh.", ch, NULL, victim, TO_VICT);
    return;
  }

  _DOFUN(do_understanding) {
    if (!str_cmp(argument, "all")) {
      ch->pcdata->understandtoggle = 1;
      send_to_char("Next time you logon your understanding protection will be back to global.\n\r", ch);
    }
    else if (!str_cmp(argument, "none")) {
      free_string(ch->pcdata->understanding);
      ch->pcdata->understanding = str_dup("None");
      ch->pcdata->understandtoggle = 0;
      send_to_char("You are no longer protected by the understanding.\n\r", ch);
      nounderglow(ch);
    }
    char arg1[MSL];
    argument = one_argument_nouncap(argument, arg1);
    if (!str_cmp(arg1, "request")) {
      char arg2[MSL];
      argument = one_argument_nouncap(argument, arg2);
      CHAR_DATA *victim;

      if ((victim = get_char_room(ch, NULL, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      send_to_char("Request sent.\n\r", ch);
      if (safe_strlen(argument) > 2) {
        printf_to_char(victim, "Someone thinks it might be appropriate for you to lower your understanding protection because %s.\n\r", argument);
      }
      else
      printf_to_char(victim, "Someone thinks it might be appropriate for you to lower your understanding protection.\n\r", ch);

    }
    else {
      if (!str_cmp(ch->pcdata->understanding, "None")) {
        send_to_char("You need to re-enable global protection first.\n\r", ch);
        return;
      }
      CHAR_DATA *victim;

      if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }

      free_string(ch->pcdata->understanding);
      ch->pcdata->understanding = str_dup(victim->name);
      ch->pcdata->understandtoggle = 0;
      act("You are no longer protected by the understanding against $N.", ch, NULL, victim, TO_CHAR);
      if (can_shroud(victim))
      act("$n starts to emit a faint red aura.", ch, NULL, victim, TO_VICT);
    }
  }

  _DOFUN(do_offworld) {
    CHAR_DATA *victim;
    char arg1[MSL];

    argument = one_argument_nouncap(argument, arg1);

    if (is_helpless(ch) || in_fight(ch) || room_hostile(ch->in_room))
    return;

    if (!str_cmp(arg1, "join")) {
      if (ch->pcdata->influence < 5000 || ch->rpexp < 1000) {
        send_to_char("You need 5k influence and 1k rp xp for that.\n\r", ch);
        return;
      }
      victim = get_char_world_pc(argument);
      if (victim == NULL) {
        send_to_char("Your contacts can't locate them right now.\n\r", ch);
        return;
      }
      if (!offworld(victim)) {
        send_to_char("Your contacts can't locate them offworld..\n\r", ch);
        ch->pcdata->influence -= 5000;
        ch->rpexp -= 1000;
        return;
      }
      ch->pcdata->influence -= 5000;
      ch->rpexp -= 1000;
      ch->pcdata->timebanished = victim->pcdata->timebanished;
      act("A distortion in the air forms and $n steps through it.", ch, NULL, NULL, TO_ROOM);
      char_from_room(ch);
      char_to_room(ch, victim->in_room);
      act("A distortion forms in the air and $n steps through it.", ch, NULL, NULL, TO_ROOM);
      send_to_char("Your contacts locate your target and quickly open a distorion in the air which you step through.\n\r", ch);
      return;
    }
    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }
    if (!is_helpless(victim) && ch != victim) {
      send_to_char("They must be helpless first.\n\r", ch);
      return;
    }
    if (ch == victim) {
      if (ch->pcdata->influence < 5000 || ch->rpexp < 1000) {
        send_to_char("You'd need 5k influence and 1k rpexp to do that.\n\r", ch);
        return;
      }
    }
    else {
      if (ch->pcdata->influence < 20000 || ch->rpexp < 3000) {
        send_to_char("You'd need 20k influence and 3k rpexp to do that.\n\r", ch);
        return;
      }
    }

    if (!str_cmp(argument, "wilds")) {
      act("A distortion opens in the air and $n is sucked suddenly through it.", victim, NULL, NULL, TO_ROOM);
      char_from_room(victim);
      char_to_room(victim, get_room_index(25600));
      act("A distortion opens in the air and $n thrown through it from the other side.", victim, NULL, NULL, TO_ROOM);
      send_to_char("A distortion opens in the air and you are suddenly sucked through it.\n\r", victim);
      if (IS_FLAG(victim->act, PLR_BOUND))
      REMOVE_FLAG(victim->act, PLR_BOUND);
      if (IS_FLAG(victim->act, PLR_BOUNDFEET))
      REMOVE_FLAG(victim->act, PLR_BOUNDFEET);

      if (ch == victim) {
        ch->pcdata->influence -= 5000;
        ch->rpexp -= 1000;
      }
      else {
        ch->pcdata->influence -= 20000;
        ch->rpexp -= 3000;
      }

      victim->pcdata->timebanished = current_time + (3600 * 24 * 20);
      victim->pcdata->ghost_room = 25600;

      return;
    }
    else if (!str_cmp(argument, "pastwilds")) {
      act("A distortion opens in the air and $n is sucked suddenly through it.", victim, NULL, NULL, TO_ROOM);
      char_from_room(victim);
      char_to_room(victim, get_room_index(25600));
      act("A distortion opens in the air and $n thrown through it from the other side.", victim, NULL, NULL, TO_ROOM);
      send_to_char("A distortion opens in the air and you are suddenly sucked through it.\n\r", victim);
      if (IS_FLAG(victim->act, PLR_BOUND))
      REMOVE_FLAG(victim->act, PLR_BOUND);
      if (ch == victim) {
        ch->pcdata->influence -= 5000;
        ch->rpexp -= 1000;
      }
      else {
        ch->pcdata->influence -= 20000;
        ch->rpexp -= 3000;
      }
      victim->pcdata->timebanished = current_time + (3600 * 24 * 2);
      if (ch == victim) {
        victim->pcdata->deaged -= 1500;
        victim->pcdata->agemod += 1500;
      }
      else {
        victim->pcdata->deaged -= 750;
        victim->pcdata->agemod += 750;
      }
      victim->pcdata->ghost_room = 25600;

      return;
    }
    else if (!str_cmp(argument, "other")) {
      act("A distortion opens in the air and $n is sucked suddenly through it.", victim, NULL, NULL, TO_ROOM);
      char_from_room(victim);
      char_to_room(victim, get_room_index(25500));
      act("A distortion opens in the air and $n thrown through it from the other side.", victim, NULL, NULL, TO_ROOM);
      send_to_char("A distortion opens in the air and you are suddenly sucked through it.\n\r", victim);
      if (IS_FLAG(victim->act, PLR_BOUND))
      REMOVE_FLAG(victim->act, PLR_BOUND);
      if (ch == victim) {
        ch->pcdata->influence -= 5000;
        ch->rpexp -= 1000;
      }
      else {
        ch->pcdata->influence -= 20000;
        ch->rpexp -= 3000;
      }

      victim->pcdata->timebanished = current_time + (3600 * 24 * 20);
      victim->pcdata->ghost_room = 25500;

      return;
    }
    else if (!str_cmp(argument, "godrealm")) {
      act("A distortion opens in the air and $n is sucked suddenly through it.", victim, NULL, NULL, TO_ROOM);
      char_from_room(victim);
      char_to_room(victim, get_room_index(25700));
      act("A distortion opens in the air and $n thrown through it from the other side.", victim, NULL, NULL, TO_ROOM);
      send_to_char("A distortion opens in the air and you are suddenly sucked through it.\n\r", victim);
      if (IS_FLAG(victim->act, PLR_BOUND))
      REMOVE_FLAG(victim->act, PLR_BOUND);
      if (ch == victim) {
        ch->pcdata->influence -= 5000;
        ch->rpexp -= 1000;
      }
      else {
        ch->pcdata->influence -= 20000;
        ch->rpexp -= 3000;
      }

      victim->pcdata->timebanished = current_time + (3600 * 24 * 20);
      victim->pcdata->ghost_room = 25700;
      return;
    }
    else
    send_to_char("Offworld (target) wilds/other/godrealm.\n\r", ch);
  }

  _DOFUN(do_autofire) {
    if (IS_FLAG(ch->comm, COMM_AUTOFIRE)) {
      send_to_char("You turn autofire off.\n\r", ch);
      REMOVE_FLAG(ch->comm, COMM_AUTOFIRE);
    }
    else {
      send_to_char("You turn autofire on.\n\r", ch);
      SET_FLAG(ch->comm, COMM_AUTOFIRE);
    }
  }

  char *random_intro(void) {
    int i = number_percent() % 19;

    if (i == 0)
    return "a shaggy-haired young man";
    else if (i == 1)
    return "a lanky, dark-haired young woman";
    else if (i == 2)
    return "a slender, pale-skinned young man";
    else if (i == 3)
    return "a lanky, dark-haired young woman";
    else if (i == 4)
    return "an overweight, middle-aged man";
    else if (i == 5)
    return "a tanned, curvaceous blonde woman";
    else if (i == 6)
    return "a skinny, freckle-faced young man";
    else if (i == 7)
    return "a willowy, black-tressed woman";
    else if (i == 8)
    return "a reedy, swarthy-skinned man";
    else if (i == 9)
    return "a comely, wavy-haired woman";
    else if (i == 10)
    return "a thin man with numerous tattoos";
    else if (i == 11)
    return "a plain-faced woman with brown hair";
    else if (i == 12)
    return "a plump man with pale, spotty skin";
    else if (i == 13)
    return "a black-haired, clean-shaven man";
    else if (i == 14)
    return "a coltish, red-haired female";
    else if (i == 15)
    return "an athletic young man with a crew-cut";
    else if (i == 16)
    return "a slim, olive-skinned young woman";
    else if (i == 17)
    return "a leggy, strawberry-blonde woman";
    else if (i == 18)
    return "a weak-chinned woman with dusky skin";

    return "a Haven resident";
  }

  void habit_corpse(CHAR_DATA *ch, char *deathcause) {
    char buf[MAX_STRING_LENGTH];
    OBJ_DATA *corpse;
    char name[MSL];

    AFFECT_DATA af;
    af.where = TO_AFFECTS;
    af.type = 0;
    af.level = 10;
    af.duration = 12 * 60 * 4;
    af.location = APPLY_NONE;
    af.modifier = 0;
    af.caster = NULL;
    af.weave = FALSE;
    af.bitvector = AFF_NOUNDERSTANDING;
    affect_to_char(ch, &af);
    nounderglow(ch); // broadcasts aura change

    corpse = create_object(get_obj_index(OBJ_VNUM_CORPSE_NPC), 0);
    corpse->timer = (60 * 72);

    corpse->cost = 0;

    corpse->carried_by = NULL;
    sprintf(name, "%s", random_intro());

    sprintf(buf, "The corpse of %s", name);
    free_string(corpse->short_descr);
    corpse->short_descr = str_dup(buf);

    sprintf(buf, "The corpse of %s", name);
    free_string(corpse->description);
    corpse->description = str_dup(buf);

    sprintf(buf, "corpse %s", name);
    free_string(corpse->name);
    corpse->name = str_dup(buf);

    if (ch->pcdata->penis > 0)
    sprintf(buf, "The cause of death seems to be %s.\nYou collect trace evidence of a male with:\n%s\n%s\nAround %d feet tall and %d years old.\n\r", deathcause, get_forensic_hair(ch), get_natural_eyes(ch), ch->pcdata->height_feet, get_age(ch) - (get_age(ch) % 5));
    else
    sprintf(buf, "The cause of death seems to be %s.\nYou collect trace evidence of a female with:\n%s\n%s\nAround %d feet tall and %d years old.\n\r", deathcause, get_forensic_hair(ch), get_natural_eyes(ch), ch->pcdata->height_feet, get_age(ch) - (get_age(ch) % 5));
    EXTRA_DESCR_DATA *ed;

    for (ed = corpse->extra_descr; ed; ed = ed->next) {
      if (is_name("+forensic", ed->keyword))
      break;
    }

    if (!ed) {
      ed = new_extra_descr();
      ed->keyword = str_dup("+forensic");
      ed->next = corpse->extra_descr;
      corpse->extra_descr = ed;
      free_string(corpse->extra_descr->description);
      corpse->extra_descr->description = str_dup(buf);
    }
    else {
      free_string(ed->description);
      ed->description = str_dup(buf);
    }
    if (ch->in_room != NULL)
    obj_to_room(corpse, ch->in_room);
  }

  bool psychic_vulnerable(CHAR_DATA *ch, CHAR_DATA *victim, bool show) {
    if (event_cleanse == 1 || IS_NPC(victim))
    return FALSE;

    if (mindwarded(victim) || is_helpless(ch) || victim->pcdata->trance < 0 || victim->pcdata->mind_guarded > 0) {
      if (show == TRUE)
      send_to_char("You can't seem to catch their gaze.\n\r", ch);
      return FALSE;
    }

    if (is_neutralized(ch))
    return FALSE;

    if (in_fight(ch)) {
      if (show == TRUE)
      send_to_char("You're a bit busy.\n\r", ch);
      return FALSE;
    }
    if (ch->pcdata->patrol_timer > 0) {
      if (ch->pcdata->patrol_status >= PATROL_PREYING && ch->pcdata->patrol_status <= PATROL_GRABBED) {
        if (show == TRUE)
        send_to_char("You're a bit busy.\n\r", ch);
        return FALSE;
      }
      if (ch->pcdata->patrol_status >= PATROL_WARMOVINGATTACK && ch->pcdata->patrol_status <= PATROL_WAGINGWAR) {
        if (show == TRUE)
        send_to_char("You're a bit busy.\n\r", ch);
        return FALSE;
      }
      if (ch->pcdata->patrol_status >= PATROL_LEADING_ASSAULT && ch->pcdata->patrol_status <= PATROL_ARCANEWAR) {
        if (show == TRUE)
        send_to_char("You're a bit busy.\n\r", ch);
        return FALSE;
      }
    }
    if (is_pinned(ch) || is_helpless(ch)) {
      if (show == TRUE)
      send_to_char("You can't do that.\n\r", ch);
      return FALSE;
    }
    if (is_safe(ch, victim)) {
      if (show == TRUE)
      send_to_char("For some reason you can't bring yourself to do that.\n\r", ch);
      return FALSE;
    }
    if (room_hostile(ch->in_room)) {
      if (show == TRUE)
      start_hostilefight(ch);
      return FALSE;
    }
    if (ch->recent_moved > -300 || victim->recent_moved > -300) {
      if (show == TRUE)
      send_to_char("You must wait for them to settle.\n\r", ch);
      return FALSE;
    }
    return TRUE;
  }

  int dream_power(const FANTASY_TYPE *fant) {
    int strength = 0;
    if (fant->active == FALSE)
    return 0;
    for (int i = 0; i < 200; i++) {
      if (safe_strlen(fant->exit_name[i]) > 1)
      strength += 1000;
    }
    for (int i = 0; i < 200; i++) {
      strength += fant->participant_exp[i];
    }
    return strength;
  }

  int dream_defense(CHAR_DATA *ch) {
    int total = 0;
    for (vector<FANTASY_TYPE *>::iterator it = FantasyVect.begin();
    it != FantasyVect.end(); ++it) {
      if ((*it)->valid == FALSE) {
        continue;
      }
      for (int i = 0; i < 200; i++) {
        if (!str_cmp((*it)->participants[i], ch->name))
        total += dream_power((*it));
      }
    }
    return total;
  }

  _DOFUN(do_dream) {
    char arg[MSL];
    argument = one_argument_nouncap(argument, arg);

    if (is_ghost(ch))
    return;

    if (IS_FLAG(ch->act, PLR_DEAD))
    return;
    if (ch->in_room != NULL && ch->in_room->vnum < 300)
    return;
    if (is_gm(ch))
    return;
    if (ch->pcdata->dexp > 5000000 || ch->pcdata->dexp < 0)
    ch->pcdata->dexp = 0;

    if (!str_cmp(arg, "sell")) {
      char arg2[MSL];
      argument = one_argument_nouncap(argument, arg2);
      if (!str_cmp(arg2, "experience")) {
        int amount = atoi(argument);
        if (amount < 5 || amount > ch->pcdata->dexp) {
          printf_to_char(ch, "Enter an amount between 5 and %d.\n\r", ch->pcdata->dexp);
          return;
        }
        ch->pcdata->dexp -= amount;
        ch->pcdata->account->rpxp += amount / 5;
        printf_to_char(
        ch, "You exchange %d dream experience for %d rp experience.\n\r", amount, amount / 5);
        return;
      }
    }
    if (!str_cmp(arg, "buy")) {
      char arg2[MSL];
      argument = one_argument_nouncap(argument, arg2);
      if (!str_cmp(arg2, "experience")) {
        int amount = atoi(argument);
        if (amount < 1 || amount > ch->pcdata->account->rpxp) {
          printf_to_char(ch, "Enter an amount between 1 and %d.\n\r", ch->pcdata->account->rpxp);
          return;
        }
        if (ch->pcdata->dexp + amount * 2 > 50000) {
          printf_to_char(ch, "You can't buy more than 50k dream experience.\n\r");
          return;
        }
        ch->pcdata->dexp += amount * 2;
        ch->pcdata->account->rpxp -= amount;
        printf_to_char(ch, "You exchange %d rpxp for %d dream exp.\n\r", amount, amount * 2);
        return;
      }
    }

    if (!str_cmp(arg, "")) {
      if (is_dreaming(ch)) {
        send_to_char("You're already dreaming.\n\r", ch);
        return;
      }
      if (IS_FLAG(ch->act, PLR_SHROUD) && !is_helpless(ch)) {
        send_to_char("You're already in the nightmare.\n\r", ch);
        return;
      }
      if (room_fight(ch->in_room, FALSE, FALSE, TRUE)) {
        send_to_char("Everything's too hectic for you to relax.\n\r", ch);
        return;
      }
      if (ch->pcdata->sleeping == 0 && (is_pinned(ch) || in_fight(ch) || is_forcibly_helpless(ch))) {
        send_to_char("You are too stressed to fall asleep right now.\n\r", ch);
        return;
      }
      ch->pcdata->last_dreamworld = recent_dreamworld();
      to_spectre(ch, FALSE);
      act("$n falls asleep.", ch, NULL, NULL, TO_ROOM);
      act("You fall asleep.", ch, NULL, NULL, TO_CHAR);
    }
    else if (!str_cmp(arg, "Name")) {
      if (is_dreaming(ch) && ch->pcdata->dream_controller == 0 && get_skill(ch, SKILL_DREAMING) == 0) {
        send_to_char("You can't control this dream.\n\r", ch);
        return;
      }
      free_string(ch->pcdata->dream_intro);
      ch->pcdata->dream_intro = str_dup(argument);
      printf_to_char(ch, "You are now %s in the dream world.\n\r", argument);
    }
    else if (!str_cmp(arg, "Description")) {
      if (is_dreaming(ch) && ch->pcdata->dream_controller == 0 && get_skill(ch, SKILL_DREAMING) == 0) {
        send_to_char("You can't control this dream.\n\r", ch);
        return;
      }
      string_append(ch, &ch->pcdata->dream_description);
    }
    else if (!str_cmp(arg, "believe")) {
      char arg2[MSL];
      argument = one_argument_nouncap(argument, arg2);
      FANTASY_TYPE *fant = fetch_fantasy(ch, atoi(arg2));
      if (fant == NULL || fant->active == FALSE) {
        send_to_char("No such world.\n\r", ch);
        return;
      }
      if (get_skill(ch, SKILL_SPLITMIND) < 1) {
        send_to_char("You do not have that ability.\n\r", ch);
        return;
      }

      ch->pcdata->dream_identity_timer = 60;
      free_string(ch->pcdata->identity_world);
      ch->pcdata->identity_world = str_dup(fant->name);
      free_string(ch->pcdata->dream_identity);
      ch->pcdata->dream_identity = str_dup("");
      if (safe_strlen(dream_detail(ch, ch->pcdata->identity_world, DREAM_DETAIL_NAME)) > 1) {
        printf_to_char(
        ch, "You believe you are %s from the world of %s.\n\r", dream_detail(ch, ch->pcdata->identity_world, DREAM_DETAIL_NAME), ch->pcdata->identity_world);
      }
      else
      ch->pcdata->dream_identity_timer = 0;
      return;
    }
    else if (!str_cmp(arg, "makebelieve")) {
      CHAR_DATA *victim;
      char arg2[MSL];
      argument = one_argument_nouncap(argument, arg2);
      FANTASY_TYPE *fant = fetch_fantasy(ch, atoi(arg2));
      if (fant == NULL || fant->active == FALSE) {
        send_to_char("No such world.\n\r", ch);
        return;
      }
      if (fant->highlight_time == 0) {
        send_to_char("That world isn't close enough right now.\n\r", ch);
        return;
      }
      if ((victim = get_char_room(ch, NULL, argument)) == NULL) {
        send_to_char("They aren't here.\n\r", ch);
        return;
      }
      if (get_skill(ch, SKILL_SPLITMIND) < 2 && !mindbroken(victim)) {
        send_to_char("You do not have that ability.\n\r", ch);
        return;
      }
      if (!psychic_vulnerable(ch, victim, TRUE))
      return;
      if (IS_FLAG(victim->act, PLR_GUEST))
      return;
      if (higher_power(ch) && power_bound(ch) && !IS_NPC(victim) && str_cmp(ch->pcdata->place, victim->pcdata->place)) {
        send_to_char("Your power is bound.\n\r", ch);
        return;
      }

      int cost = 300;
      cost = cost * get_tier(victim) / get_tier(ch);
      cost = cost * (arcane_focus(victim) + 1) / (arcane_focus(ch) + 1);
      if (get_tier(ch) == 1)
      cost *= 2;
      if (IS_FLAG(victim->comm, COMM_MANDRAKE))
      cost /= 4;
      if (is_weakness(ch, victim))
      cost /= 4;

      if (is_helpless(victim))
      cost = cost * 2 / 3;
      if (mindbroken(victim))
      cost /= 3;

      if (ch->race == RACE_DREAMCHILD && !str_cmp(ch->pcdata->dream_origin, fant->name))
      cost /= 3;

      if (get_lifeforce(ch, TRUE, NULL) - (cost / 100) <= 90) {
        victim->pcdata->dream_identity_timer = 0;
        send_to_char("The attempt fails.\n\r", ch);
        use_lifeforce(ch, 100, "Dream believe");
        return;
      }
      if (mindbroken(victim))
      victim->pcdata->dream_identity_timer = 210;
      else
      victim->pcdata->dream_identity_timer = 60;

      free_string(victim->pcdata->identity_world);
      victim->pcdata->identity_world = str_dup(fant->name);
      free_string(victim->pcdata->dream_identity);
      victim->pcdata->dream_identity = str_dup("");
      if (safe_strlen(dream_detail(victim, victim->pcdata->identity_world, DREAM_DETAIL_NAME)) > 1) {
        printf_to_char(victim, "You believe you are %s from the world of %s.\n\r", dream_detail(victim, victim->pcdata->identity_world, DREAM_DETAIL_NAME), victim->pcdata->identity_world);
        send_to_char("Done.\n\r", ch);
        use_lifeforce(ch, cost, "Dream believe");
      }
      else {
        victim->pcdata->dream_identity_timer = 0;
        send_to_char("The attempt fails.\n\r", ch);
        use_lifeforce(ch, 100, "Dream believe");
      }
      return;
    }
    else if (!str_cmp(arg, "makeidentity")) {
      CHAR_DATA *victim;
      char arg2[MSL];
      argument = one_argument_nouncap(argument, arg2);
      FANTASY_TYPE *fant = fetch_fantasy(ch, atoi(arg2));
      if (fant == NULL || fant->active == FALSE) {
        send_to_char("No such world.\n\r", ch);
        return;
      }
      if (fant->highlight_time == 0) {
        send_to_char("That world isn't close enough right now.\n\r", ch);
        return;
      }

      char arg3[MSL];
      argument = one_argument_nouncap(argument, arg3);
      if ((victim = get_char_room(ch, NULL, arg3)) == NULL) {
        send_to_char("They aren't here.\n\r", ch);
        return;
      }
      if (get_skill(ch, SKILL_SPLITMIND) < 2 && !mindbroken(victim)) {
        send_to_char("You do not have that ability.\n\r", ch);
        return;
      }
      if (!psychic_vulnerable(ch, victim, TRUE))
      return;
      int cost = 450;
      cost = cost * get_tier(victim) / get_tier(ch);
      cost = cost * (arcane_focus(victim) + 1) / (arcane_focus(ch) + 1);
      if (IS_FLAG(victim->comm, COMM_MANDRAKE))
      cost /= 4;
      if (is_weakness(ch, victim))
      cost /= 4;
      if (get_tier(ch) == 1)
      cost *= 2;

      if (is_helpless(victim))
      cost = cost * 2 / 3;
      if (mindbroken(victim))
      cost /= 3;

      if (ch->race == RACE_DREAMCHILD && !str_cmp(ch->pcdata->dream_origin, fant->name))
      cost /= 3;

      if (get_lifeforce(ch, TRUE, NULL) - (cost / 100) <= 90) {
        victim->pcdata->dream_identity_timer = 0;
        send_to_char("The attempt fails.\n\r", ch);
        use_lifeforce(ch, 100, "Dream believe");
        return;
      }

      if (higher_power(ch) && power_bound(ch) && !IS_NPC(victim) && str_cmp(ch->pcdata->place, victim->pcdata->place)) {
        send_to_char("Your power is bound.\n\r", ch);
        return;
      }

      victim->pcdata->dream_identity_timer = 60;
      if (mindbroken(victim))
      victim->pcdata->dream_identity_timer = 180;
      free_string(victim->pcdata->identity_world);
      victim->pcdata->identity_world = str_dup(fant->name);
      free_string(victim->pcdata->dream_identity);
      victim->pcdata->dream_identity = str_dup(argument);
      printf_to_char(victim, "You believe you are %s from the world of %s.\n\r", victim->pcdata->dream_identity, victim->pcdata->identity_world);
      send_to_char("Done.\n\r", ch);
      use_lifeforce(ch, cost, "Dream believe");
      return;
    }

    else if (!str_cmp(arg, "assault")) {
      CHAR_DATA *victim;
      char arg2[MSL];
      argument = one_argument_nouncap(argument, arg2);
      if (ch->pcdata->dream_attack_cool > 0) {
        send_to_char("That's still on cooldown.\n\r", ch);
        return;
      }
      if ((victim = get_char_room(ch, NULL, arg2)) == NULL) {
        send_to_char("They aren't here.\n\r", ch);
        return;
      }
      if (event_cleanse == 1 || IS_NPC(victim))
      return;

      if (mindwarded(victim) || is_helpless(ch) || victim->pcdata->trance < 0 || victim->pcdata->mind_guarded > 0) {
        send_to_char("You can't seem to catch their gaze.\n\r", ch);
        return;
      }

      if (in_fight(ch)) {
        send_to_char("You're a bit busy.\n\r", ch);
        return;
      }
      if (is_pinned(ch) || is_helpless(ch)) {
        send_to_char("You can't do that.\n\r", ch);
        return;
      }
      if (is_safe(ch, victim)) {
        send_to_char("For some reason you can't bring yourself to do that.\n\r", ch);
        return;
      }
      if (room_hostile(ch->in_room) && number_percent() % 2 == 0) {
        start_hostilefight(ch);
        return;
      }
      if (ch->recent_moved > -300 || victim->recent_moved > -300) {
        send_to_char("You must wait for them to settle.\n\r", ch);
        return;
      }
      int chpoint = -1;
      int vicpoint = -1;
      for (vector<FANTASY_TYPE *>::iterator it = FantasyVect.begin();
      it != FantasyVect.end(); ++it) {
        if ((*it)->valid == FALSE || (*it)->active == FALSE) {
          continue;
        }
        if (!str_cmp(ch->pcdata->identity_world, (*it)->name) && ch->pcdata->dream_identity_timer > 0) {
          if (str_cmp(victim->pcdata->identity_world, ch->pcdata->identity_world) || victim->pcdata->dream_identity_timer < 1) {
            send_to_char("You cannot assault them.\n\r", ch);
            return;
          }
          for (int i = 0; i < 200; i++) {
            if (!str_cmp((*it)->participants[i], ch->name))
            chpoint = i;
            if (!str_cmp((*it)->participants[i], victim->name))
            vicpoint = i;
          }
          if (chpoint == -1) {
            send_to_char("You cannot assault them.\n\r", ch);
            return;
          }
          int chtotal = 0;
          int victotal = 0;
          for (int i = 0; i < 30; i++) {
            if (chpoint > -1)
            chtotal += (*it)->participant_stats[chpoint][i] *
            (*it)->stat_offense_power[i];
            if (vicpoint > -1)
            victotal += (*it)->participant_stats[vicpoint][i] *
            (*it)->stat_defense_power[i];
          }

          int statpoint = -1;
          int max = 0;
          if (!str_cmp(argument, "")) {
            for (int i = 0; i < 30; i++) {
              if ((*it)->participant_stats[chpoint][i] *
                  (*it)->stat_offense_power[i] >
                  max) {
                max = (*it)->participant_stats[chpoint][i] *
                (*it)->stat_offense_power[i] >
                max;
                statpoint = i;
              }
            }
          }
          else {
            for (int i = 0; i < 20; i++) {
              if (!str_cmp((*it)->stats[i], argument))
              statpoint = i;
            }
          }
          if (statpoint == -1) {
            send_to_char("You have no offensive stats.\n\r", ch);
            return;
          }
          int maxoff = (*it)->participant_stats[chpoint][statpoint] *
          (*it)->stat_offense_power[statpoint];
          int defpoint = -1;
          max = 0;
          if (vicpoint != -1) {
            for (int i = 0; i < 30; i++) {
              if ((*it)->participant_stats[vicpoint][i] *
                  (*it)->stat_defense_power[i] >
                  max) {
                max = (*it)->participant_stats[vicpoint][i] *
                (*it)->stat_defense_power[i];
                defpoint = i;
              }
            }
          }
          if (ch->race == RACE_DREAMCHILD && !str_cmp(ch->pcdata->dream_origin, (*it)->name))
          use_lifeforce(ch, 100, "Dream Assault");
          else
          use_lifeforce(ch, 300, "Dream Assault");

          int maxdef = max;
          ch->pcdata->dream_attack_cool = 10;
          if (defpoint == -1 && number_range(1, dream_defense(victim)) / 2 > dream_power((*it))) {
            printf_to_char(ch, "You attack %s with %s, but it has no effect.\n\r", PERS(victim, ch), (*it)->stats[statpoint]);
            printf_to_char(victim, "%s attacks you with %s, but it has no effect.\n\r", PERS(ch, victim), (*it)->stats[statpoint]);

            CHAR_DATA *newvict;
            for (CharList::iterator ik = victim->in_room->people->begin();
            ik != victim->in_room->people->end(); ++ik) {
              newvict = *ik;

              if (newvict == NULL || newvict->in_room == NULL || IS_NPC(newvict))
              continue;

              if (!str_cmp(newvict->pcdata->identity_world, victim->pcdata->identity_world) && newvict->pcdata->dream_identity_timer > 0)
              printf_to_char(newvict, "%s attacks %s with %s, but it has no effect.\n\r", PERS(ch, newvict), PERS(victim, newvict), (*it)->stats[statpoint]);
            }
          }
          else if (number_range(0, maxoff + chtotal) >
              number_range(0, maxdef + victotal) || defpoint == -1) {
            printf_to_char(ch, "You attack %s with %s, badly injuring them and knocking them out cold.\n\r", PERS(victim, ch), (*it)->stats[statpoint]);
            printf_to_char(victim, "%s attacks you with %s, badly injuring you and knocking you out cold.\n\r", PERS(ch, victim), (*it)->stats[statpoint]);
            victim->pcdata->sleeping = 300;
            CHAR_DATA *newvict;
            for (CharList::iterator ik = victim->in_room->people->begin();
            ik != victim->in_room->people->end(); ++ik) {
              newvict = *ik;

              if (newvict == NULL || newvict->in_room == NULL || IS_NPC(newvict))
              continue;

              if (!str_cmp(newvict->pcdata->identity_world, victim->pcdata->identity_world) && newvict->pcdata->dream_identity_timer > 0)
              printf_to_char(newvict, "%s attacks %s with %s, badly injuring them and knocking them out cold.\n\r", PERS(ch, newvict), PERS(victim, newvict), (*it)->stats[statpoint]);
            }
          }
          else {
            printf_to_char(ch, "You attack %s with %s, but they successfully defend themselves using %s.\n\r", PERS(victim, ch), (*it)->stats[statpoint], (*it)->stats[defpoint]);
            printf_to_char(victim, "%s attacks you with %s, but you successfully defend yourself with %s.\n\r", PERS(ch, victim), (*it)->stats[statpoint], (*it)->stats[defpoint]);

            CHAR_DATA *newvict;
            for (CharList::iterator ik = victim->in_room->people->begin();
            ik != victim->in_room->people->end(); ++ik) {
              newvict = *ik;

              if (newvict == NULL || newvict->in_room == NULL || IS_NPC(newvict))
              continue;

              if (!str_cmp(newvict->pcdata->identity_world, victim->pcdata->identity_world) && newvict->pcdata->dream_identity_timer > 0)
              printf_to_char(newvict, "%s attacks %s with %s, but they successfully defend themselves with %s.\n\r", PERS(ch, newvict), PERS(victim, newvict), (*it)->stats[statpoint], (*it)->stats[defpoint]);
            }
          }
        }
      }
    }
    else if (!str_cmp(arg, "Invade")) {
      CHAR_DATA *victim;
      char arg2[MSL];
      argument = one_argument_nouncap(argument, arg2);
      if (battleground(ch->in_room)) {
        free_string(ch->pcdata->ritual_dreamworld);
        ch->pcdata->ritual_dreamworld =
        str_dup(fetch_fantasy(ch, atoi(arg2))->name);
        action_prep(ch, 2, argument);
        return;
      }
      if ((victim = get_char_room(ch, NULL, argument)) == NULL) {
        if ((victim = get_char_world_pc(argument)) != NULL && victim->pcdata->ghost_room == ch->in_room->vnum && (IS_FLAG(victim->act, PLR_GHOSTWALKING) || victim->pcdata->spectre > 0)) {
        }
        else {
          send_to_char("They're not close enough.\n\r", ch);
          return;
        }
      }
      if (ch->pcdata->spectre != 2 || !IS_FLAG(ch->act, PLR_SHROUD)) {
        send_to_char("You have to be in the nightmare, and your victim outside it to do that.\n\r,", ch);
        return;
      }
      if (has_weakness(ch, victim)) {
        send_to_char("Their mind is resistant.\n\r", ch);
        return;
      }
      if (guestmonster(victim) || higher_power(victim)) {
        send_to_char("Their mind is resistant.\n\r", ch);
        return;
      }

      if (higher_power(ch) && power_bound(ch) && !IS_NPC(victim) && str_cmp(ch->pcdata->place, victim->pcdata->place)) {
        send_to_char("Your power is bound.\n\r", ch);
        return;
      }

      FANTASY_TYPE *fant = fetch_fantasy(ch, atoi(arg2));
      if (fant == NULL) {
        send_to_char("Syntax, dream invade (dreamworld number) (target)\n\r", ch);
        return;
      }
      if (fant->highlight_time == 0) {
        send_to_char("That world isn't close enough right now.\n\r", ch);
        return;
      }

      if (in_fight(ch)) {
        send_to_char("You're a bit busy.\n\r", ch);
        return;
      }
      if (is_pinned(ch)) {
        send_to_char("You can't do that.\n\r", ch);
        return;
      }
      if (is_helpless(ch)) {
        send_to_char("You can't do that.\n\r", ch);
        return;
      }
      if (IS_NPC(victim)) {
        send_to_char("Not on NPCS.\n\r", ch);
        return;
      }
      if (is_safe(ch, victim)) {
        send_to_char("For some reason you can't bring yourself to do that.\n\r", ch);
        return;
      }
      if (victim->pcdata->dream_cooldown > 0 && !is_gm(ch)) {
        send_to_char("They have had their dreams invaded too recently.\n\r", ch);
        return;
      }
      int cost = 300;
      cost = cost * get_tier(victim) / get_tier(ch);
      cost = cost * (arcane_focus(victim) + 1) / (arcane_focus(ch) + 1);
      if (get_tier(ch) == 1)
      cost *= 2;
      if (IS_FLAG(victim->comm, COMM_MANDRAKE))
      cost /= 4;
      if (is_weakness(ch, victim))
      cost /= 4;

      if (is_helpless(victim))
      cost = cost * 2 / 3;
      if (mindbroken(victim))
      cost /= 3;
      if (ch->race == RACE_DREAMCHILD && !str_cmp(ch->pcdata->dream_origin, fant->name))
      cost /= 3;

      if (get_lifeforce(ch, TRUE, NULL) - (cost / 100) <= 90) {
        send_to_char("The attempt fails.\n\r", ch);
        use_lifeforce(ch, 100, "Dream invade");
        return;
      }
      char buf[MSL];
      sprintf(buf, "suspended%s", victim->name);
      bool suspended = FALSE;
      for (int i = 0; i < 200; i++) {
        if (!str_cmp(buf, fant->participants[i]))
        suspended = TRUE;
      }
      if (suspended == TRUE) {
        for (int i = 0; i < 200; i++) {
          if (!str_cmp(victim->name, fant->participants[i])) {
            free_string(fant->participants[i]);
            fant->participants[i] = str_dup("");
          }
        }
      }
      else {
        for (int i = 0; i < 200; i++) {
          if (!str_cmp(victim->name, fant->participants[i])) {
            free_string(fant->participants[i]);
            fant->participants[i] = str_dup(buf);
          }
        }
      }
      act("$n pushes $s fingers into $N's temples.", ch, NULL, victim, TO_NOTVICT);
      if (IS_FLAG(victim->act, PLR_SHROUD) && victim->pcdata->spectre == 0)
      enter_dreamworld(victim, fant);
      else if (victim->pcdata->spectre == 0) {
        to_spectre(victim, FALSE);
        enter_dreamworld(victim, fant);
      }
      else
      enter_dreamworld(victim, fant);

      enter_dreamworld(ch, fant);
      int point = -1;
      for (int i = 0; i < 200; i++) {
        if (!str_cmp(victim->name, fant->participants[i]))
        point = i;
      }
      victim->pcdata->dream_room = ch->pcdata->dream_room;
      ch->pcdata->tempdreamgodworld = fantasy_number(fant);
      ch->pcdata->tempdreamgodchar = point;
      use_lifeforce(ch, cost, "Dream invasion.");
      villain_mod(ch, 10, "Dream invasion");

      send_to_char("You invade their dreams, use 'wake' to leave the dream early.\n\r", ch);
      send_to_char("You fall asleep.\n\r", victim);
      if (ch->in_room == victim->in_room)
      act("$n and $N fall asleep within seconds of each other.", ch, NULL, victim, TO_NOTVICT);
      else {
        act("$n falls asleep.", victim, NULL, NULL, TO_ROOM);
      }

      victim->pcdata->dream_cooldown = 1;
      return;
    }
    else if (!str_cmp(arg, "Snare")) {
      CHAR_DATA *victim;
      char arg2[MSL];
      argument = one_argument_nouncap(argument, arg2);
      if (battleground(ch->in_room)) {
        free_string(ch->pcdata->ritual_dreamworld);
        ch->pcdata->ritual_dreamworld =
        str_dup(fetch_fantasy(ch, atoi(arg2))->name);
        action_prep(ch, 3, argument);
        return;
      }

      if ((victim = get_char_room(ch, NULL, argument)) == NULL) {
        if ((victim = get_char_world_pc(argument)) != NULL && victim->pcdata->ghost_room == ch->in_room->vnum && (IS_FLAG(victim->act, PLR_GHOSTWALKING) || victim->pcdata->spectre > 0)) {
        }
        else {
          send_to_char("They're not close enough.\n\r", ch);
          return;
        }
      }
      if (!IS_FLAG(ch->act, PLR_SHROUD)) {
        send_to_char("You have to be in the nightmare to do that.\n\r,", ch);
        return;
      }

      FANTASY_TYPE *fant = fetch_fantasy(ch, atoi(arg2));
      if (fant == NULL) {
        send_to_char("Syntax, dream snare (dreamworld number) (target)\n\r", ch);
        return;
      }
      if (!power_fantasy(fant)) {
        send_to_char("That world is not powerful enough to support that.\n\r", ch);
        return;
      }
      if (fant->highlight_time == 0) {
        send_to_char("That world isn't close enough right now.\n\r", ch);
        return;
      }

      if (in_fight(ch)) {
        send_to_char("You're a bit busy.\n\r", ch);
        return;
      }
      if (is_pinned(ch)) {
        send_to_char("You can't do that.\n\r", ch);
        return;
      }
      if (is_helpless(ch)) {
        send_to_char("You can't do that.\n\r", ch);
        return;
      }
      if (IS_NPC(victim)) {
        send_to_char("Not on NPCS.\n\r", ch);
        return;
      }
      if (is_safe(ch, victim)) {
        send_to_char("For some reason you can't bring yourself to do that.\n\r", ch);
        return;
      }
      if (guestmonster(victim) || higher_power(victim)) {
        send_to_char("Their mind is resistant.\n\r", ch);
        return;
      }

      if (victim->pcdata->dream_cooldown > 0 && !is_gm(ch)) {
        send_to_char("They have had their dreams invaded too recently.\n\r", ch);
        return;
      }
      if (has_weakness(ch, victim)) {
        send_to_char("Their mind seems resistant.\n\r", ch);
        return;
      }
      int cost = 900;
      cost = cost * get_tier(victim) / get_tier(ch);
      cost = cost * (arcane_focus(victim) + 1) / (arcane_focus(ch) + 1);
      if (get_tier(ch) == 1)
      cost *= 2;
      if (IS_FLAG(victim->comm, COMM_MANDRAKE))
      cost /= 4;
      if (is_weakness(ch, victim))
      cost /= 4;

      if (is_helpless(victim))
      cost = cost * 2 / 3;
      if (mindbroken(victim))
      cost /= 3;

      if (get_lifeforce(ch, TRUE, NULL) - (cost / 100) <= 90) {
        send_to_char("The attempt fails.\n\r", ch);
        use_lifeforce(ch, 100, "Dream invade");
        return;
      }
      char buf[MSL];
      sprintf(buf, "suspended%s", victim->name);
      bool suspended = FALSE;
      for (int i = 0; i < 200; i++) {
        if (!str_cmp(buf, fant->participants[i]))
        suspended = TRUE;
      }
      if (suspended == TRUE) {
        for (int i = 0; i < 200; i++) {
          if (!str_cmp(victim->name, fant->participants[i])) {
            free_string(fant->participants[i]);
            fant->participants[i] = str_dup("");
          }
        }
      }
      else {
        for (int i = 0; i < 200; i++) {
          if (!str_cmp(victim->name, fant->participants[i])) {
            free_string(fant->participants[i]);
            fant->participants[i] = str_dup(buf);
          }
        }
      }

      act("$n pushes $s fingers into $N's temples.", ch, NULL, victim, TO_NOTVICT);
      if (IS_FLAG(victim->act, PLR_SHROUD) && victim->pcdata->spectre == 0)
      enter_dreamworld(victim, fant);
      else if (victim->pcdata->spectre == 0) {
        to_spectre(victim, FALSE);
        enter_dreamworld(victim, fant);
      }
      else
      enter_dreamworld(victim, fant);
      enter_dreamworld(ch, fant);
      int point = -1;
      for (int i = 0; i < 200; i++) {
        if (!str_cmp(victim->name, fant->participants[i]))
        point = i;
      }
      victim->pcdata->dream_room = ch->pcdata->dream_room;
      ch->pcdata->tempdreamgodworld = fantasy_number(fant);
      ch->pcdata->tempdreamgodchar = point;
      use_lifeforce(ch, cost, "Dream snaring.");
      villain_mod(ch, 20, "Dream snaring");
      send_to_char("You invade their dreams, use 'wake' to leave the dream early.\n\r", ch);
      send_to_char("You fall asleep.\n\r", victim);
      if (ch->in_room == victim->in_room)
      act("$n and $N fall asleep within seconds of each other.", ch, NULL, victim, TO_NOTVICT);
      else {
        act("$n falls asleep.", victim, NULL, NULL, TO_ROOM);
      }
      if (!IS_FLAG(victim->comm, COMM_DREAMSNARED))
      SET_FLAG(victim->comm, COMM_DREAMSNARED);

      victim->pcdata->dream_cooldown = 1;
      return;
    }
    else {
      char buf[MSL];
      sprintf(buf, "%s %s", buf, argument);
      do_function(ch, &do_dreamworld, buf);
    }
  }

  void sympathy_pain(char *name, int level) {
    struct stat sb;
    char buf[MSL];
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    CHAR_DATA *victim;
    char tmp[MSL];
    if (safe_strlen(name) < 2)
    return;

    d.original = NULL;
    if ((victim = get_char_world_pc(name)) != NULL) // Victim is online.
    online = TRUE;
    else {
      log_string("DESCRIPTOR: Sympathy pain");

      if (!load_char_obj(&d, name)) {
        return;
      }

      sprintf(buf, "%s%s", PLAYER_DIR, capitalize(name));
      stat(buf, &sb);
      victim = d.character;
    }
    if (IS_NPC(victim)) {
      if (!online)
      free_char(victim);
      return;
    }
    switch (level) {
    case 0:
      sprintf(tmp, "%s\nYou feel a brief, phantom discomfort.", victim->pcdata->messages);
      free_string(victim->pcdata->messages);
      victim->pcdata->messages = str_dup(tmp);
      if (online)
      send_to_char("You feel a brief, phantom discomfort.", victim);
      break;
    case 1:
      sprintf(tmp, "%s\nYou feel a brief, phantom pain.", victim->pcdata->messages);
      free_string(victim->pcdata->messages);
      victim->pcdata->messages = str_dup(tmp);
      if (online)
      send_to_char("You feel a brief, phantom pain.", victim);
      AFFECT_DATA af;
      af.where = TO_AFFECTS;
      af.type = 0;
      af.level = 10;
      af.duration = 12 * 60 * 1;
      af.location = APPLY_NONE;
      af.modifier = 0;
      af.caster = NULL;
      af.weave = FALSE;
      af.bitvector = AFF_WEAKEN;
      affect_to_char(victim, &af);
      break;
    case 2:
      sprintf(tmp, "%s\nYou feel a brief, stabbing severe phantom pain.", victim->pcdata->messages);
      free_string(victim->pcdata->messages);
      victim->pcdata->messages = str_dup(tmp);
      if (online)
      send_to_char("You feel a brief, stabbing severe phantom pain.", victim);
      wound_char_absolute(victim, 1);
      break;
    case 3:
      sprintf(tmp, "%s\nYou feel a brief, stabbing critical phantom pain.", victim->pcdata->messages);
      free_string(victim->pcdata->messages);
      victim->pcdata->messages = str_dup(tmp);
      if (online)
      send_to_char("You feel a brief, stabbing critical phantom pain.", victim);
      wound_char_absolute(victim, 2);
      break;
    case 4:
      sprintf(tmp, "%s\nYou feel a brief, stabbing critical phantom pain, a sensation like something snapping and then a sudden emptiness.", victim->pcdata->messages);
      free_string(victim->pcdata->messages);
      victim->pcdata->messages = str_dup(tmp);
      if (online)
      send_to_char("You feel a brief, stabbing critical phantom pain, a sensation like something snapping and then a sudden emptiness.", victim);
      wound_char_absolute(victim, 2);
      break;
    case 5:
      sprintf(tmp, "%s\nYou feel a sensation like something snapping and then a sudden emptiness.", victim->pcdata->messages);
      free_string(victim->pcdata->messages);
      victim->pcdata->messages = str_dup(tmp);
      if (online)
      send_to_char("You feel a sensation like something snapping and then a sudden emptiness.", victim);
      break;
    case 6:
      if (is_abom(victim)) {
        sprintf(tmp, "%s\nYou feel a sensation like something snapping and then a sudden emptiness.", victim->pcdata->messages);
        free_string(victim->pcdata->messages);
        victim->pcdata->messages = str_dup(tmp);
        if (online)
        send_to_char("You feel a sensation like something snapping and then a sudden emptiness.", victim);
        real_kill(victim, victim);
      }
      break;
    }
    save_char_obj(victim, FALSE, FALSE);
    if (!online)
    free_char(victim);
  }

  void break_relationship(CHAR_DATA *ch, CHAR_DATA *victim, int type) {
    int victype = type;

    if (type == REL_CHILD)
    victype = REL_PARENT;
    if (type == REL_PARENT)
    victype = REL_CHILD;
    if (type == REL_SIRE)
    victype = REL_SIRELING;
    if (type == REL_SIRELING)
    victype = REL_SIRE;
    if (type == REL_TEACHER)
    victype = REL_STUDENT;
    if (type == REL_STUDENT)
    victype = REL_TEACHER;
    if (type == REL_EMPLOYER)
    victype = REL_EMPLOYEE;
    if (type == REL_EMPLOYEE)
    victype = REL_EMPLOYER;
    if (type == REL_WEAKNESS)
    victype = REL_WEAKNESS_OF;
    if (type == REL_WEAKNESS_OF)
    victype = REL_WEAKNESS;
    if (type == REL_PRAESTES)
    victype = REL_PRAESTES_OF;
    if (type == REL_PRAESTES_OF)
    victype = REL_PRAESTES;

    if (type == REL_PACKMATE) {
      ch->pcdata->packcooldown = current_time + (3600 * 24 * 7);
      victim->pcdata->packcooldown = current_time + (3600 * 24 * 7);
    }
    if (type == REL_TEACHER || type == REL_STUDENT) {
      ch->pcdata->packcooldown = current_time + (3600 * 24 * 14);
      victim->pcdata->packcooldown = current_time + (3600 * 24 * 14);
    }
    if (type == REL_SPOUSE) {
      ch->pcdata->total_money -= 100000;
      victim->pcdata->total_money -= 100000;
    }

    for (int i = 0; i < 10; i++) {
      if (!str_cmp(ch->pcdata->relationship[i], victim->name) && type == ch->pcdata->relationship_type[i]) {
        free_string(ch->pcdata->relationship[i]);
        ch->pcdata->relationship[i] = str_dup("");
        ch->pcdata->relationship_type[i] = 0;
      }
    }
    for (int i = 0; i < 10; i++) {
      if (!str_cmp(victim->pcdata->relationship[i], ch->name) && victype == victim->pcdata->relationship_type[i]) {
        free_string(victim->pcdata->relationship[i]);
        victim->pcdata->relationship[i] = str_dup("");
        victim->pcdata->relationship_type[i] = 0;
      }
    }
  }

  void add_relationship(CHAR_DATA *ch, int type, char *string) {
    for (int i = 0; i < 10; i++) {
      if (ch->pcdata->relationship_type[i] == 0) {
        free_string(ch->pcdata->relationship[i]);
        ch->pcdata->relationship[i] = str_dup(string);
        ch->pcdata->relationship_type[i] = type;
        return;
      }
    }
  }
  bool can_employ(CHAR_DATA *ch, CHAR_DATA *victim) {
    int wealth = get_skill(ch, SKILL_WEALTH);
    wealth -= 1;

    //    if(has_shop(ch))
    //	wealth++;

    for (int i = 0; i < 10; i++) {
      if (ch->pcdata->relationship_type[i] == REL_EMPLOYER)
      wealth--;
    }
    for (int i = 0; i < 10; i++) {
      if (victim->pcdata->relationship_type[i] == REL_EMPLOYEE)
      return FALSE;
    }

    if (wealth < 1)
    return FALSE;

    if (get_skill(ch, SKILL_WEALTH) <= get_skill(victim, SKILL_WEALTH))
    return FALSE;

    return TRUE;
  }

  bool has_relationship_type(CHAR_DATA *ch, int type) {
    for (int i = 0; i < 10; i++) {
      if (ch->pcdata->relationship_type[i] == type)
      return TRUE;
    }
    return FALSE;
  }

  _DOFUN(do_relationship) {
    CHAR_DATA *victim;
    char arg1[MSL];
    char buf[MSL];
    char arg2[MSL];

    argument = one_argument_nouncap(argument, arg1);
    argument = one_argument_nouncap(argument, arg2);
    if (!str_cmp(arg1, "offer")) {

      if ((victim = get_char_room(ch, NULL, arg2)) == NULL || ch == victim) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }

      if (IS_FLAG(ch->act, PLR_GUEST) || IS_FLAG(victim->act, PLR_GUEST)) {
        send_to_char("You can't enter into a relationship with them.\n\r", ch);
        return;
      }

      int count = 0;
      bool hasweakness = FALSE;
      for (int i = 0; i < 10; i++) {
        if (safe_strlen(ch->pcdata->relationship[i]) > 2)
        count++;
        if (ch->pcdata->relationship_type[i] == REL_WEAKNESS)
        hasweakness = TRUE;
        if (ch->pcdata->relationship_type[i] == REL_PRAESTES)
        hasweakness = TRUE;
      }
      if (count == 10) {
        send_to_char("You already have too many relationships.\n\r", ch);
        return;
      }
      count = 0;
      for (int i = 0; i < 10; i++) {
        if (safe_strlen(victim->pcdata->relationship[i]) > 2)
        count++;
      }
      if (count == 10) {
        send_to_char("They already have too many relationships.\n\r", ch);
        return;
      }
      if (!str_cmp(argument, "parent") && (get_age(ch) - 15) > get_age(victim)) {
        victim->pcdata->offering = ch;
        victim->pcdata->offer_type = REL_CHILD;
      }
      else if (!str_cmp(argument, "guardian") && !clinic_patient(ch)) {
        victim->pcdata->offering = ch;
        victim->pcdata->offer_type = REL_WARD;
      }
      else if (!str_cmp(argument, "pact") && higher_power(ch)) {
        victim->pcdata->offering = ch;
        victim->pcdata->offer_type = REL_PACTEE;
      }
      else if (!str_cmp(argument, "weakness") && !hasweakness) {
        victim->pcdata->offering = ch;
        victim->pcdata->offer_type = REL_WEAKNESS;
      }
      else if (!str_cmp(argument, "praestes") && !hasweakness) {
        victim->pcdata->offering = ch;
        victim->pcdata->offer_type = REL_PRAESTES;
      }
      else if (!str_cmp(argument, "spouse")) {
        victim->pcdata->offering = ch;
        victim->pcdata->offer_type = REL_SPOUSE;
      }
      else if (!str_cmp(argument, "sibling")) {
        victim->pcdata->offering = ch;
        victim->pcdata->offer_type = REL_SIBLING;
      }
      else if (!str_cmp(argument, "dating")) {
        victim->pcdata->offering = ch;
        victim->pcdata->offer_type = REL_DATING;
      }
      else if (!str_cmp(argument, "packmate")) {
        if (ch->pcdata->packcooldown > current_time) {
          send_to_char("You can't do that yet.\n\r", ch);
          return;
        }
        if (!is_werewolf(ch) || !is_werewolf(victim)) {
          send_to_char("You can't do that.\n\r", ch);
          return;
        }

        victim->pcdata->offering = ch;
        victim->pcdata->offer_type = REL_PACKMATE;
      }
      else if (!str_cmp(argument, "sire")) {
        victim->pcdata->offering = ch;
        victim->pcdata->offer_type = REL_SIRELING;
      }
      else if (!str_cmp(argument, "teacher")) {
        if (ch->pcdata->teachercooldown > current_time) {
          send_to_char("You can't do that yet.\n\r", ch);
          return;
        }
        if (has_relationship_type(ch, REL_TEACHER)) {
          send_to_char("You are already a teacher.\n\r", ch);
          return;
        }

        victim->pcdata->offering = ch;
        victim->pcdata->offer_type = REL_STUDENT;
      }
      else {
        send_to_char("Valid types are parent, guardian, spouse, sibling, packmate, sire, teacher, dating, weakness, praestes.\n\r", ch);
        return;
      }

      send_to_char("You make the offer.\n\r", ch);
      printf_to_char(
      victim, "%s wants to become your %s. Type relationship accept %s to agree.\n\r", PERS(ch, victim), argument, PERS(ch, victim));

    }
    else if (!str_cmp(arg1, "accept")) {
      if ((victim = get_char_room(ch, NULL, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }

      if (victim != ch->pcdata->offering) {
        send_to_char("They'd need to make the offer first.\n\r", ch);
        return;
      }

      if (ch->pcdata->offer_type == REL_CHILD) {
        add_relationship(ch, REL_CHILD, victim->name);
        add_relationship(victim, REL_PARENT, ch->name);
      }
      else if (ch->pcdata->offer_type == REL_WARD) {
        add_relationship(ch, REL_WARD, victim->name);
        add_relationship(victim, REL_GUARDIAN, ch->name);
      }
      else if (ch->pcdata->offer_type == REL_PACTEE) {
        add_relationship(ch, REL_PACTEE, victim->name);
        add_relationship(victim, REL_PACTER, ch->name);
      }
      else if (ch->pcdata->offer_type == REL_WEAKNESS) {
        add_relationship(ch, REL_WEAKNESS, victim->name);
        add_relationship(victim, REL_WEAKNESS_OF, ch->name);
      }
      else if (ch->pcdata->offer_type == REL_PRAESTES) {
        add_relationship(ch, REL_PRAESTES, victim->name);
        add_relationship(victim, REL_PRAESTES_OF, ch->name);
      }
      else if (ch->pcdata->offer_type == REL_SPOUSE) {
        add_relationship(ch, REL_SPOUSE, victim->name);
        add_relationship(victim, REL_SPOUSE, ch->name);
      }
      else if (ch->pcdata->offer_type == REL_SIBLING) {
        add_relationship(ch, REL_SIBLING, victim->name);
        add_relationship(victim, REL_SIBLING, ch->name);
      }
      else if (ch->pcdata->offer_type == REL_DATING) {
        add_relationship(ch, REL_DATING, victim->name);
        add_relationship(victim, REL_DATING, ch->name);
      }
      else if (ch->pcdata->offer_type == REL_PACKMATE) {
        add_relationship(ch, REL_PACKMATE, victim->name);
        add_relationship(victim, REL_PACKMATE, ch->name);
      }
      else if (ch->pcdata->offer_type == REL_SIRELING) {
        add_relationship(ch, REL_SIRELING, victim->name);
        add_relationship(victim, REL_SIRE, ch->name);
      }
      else if (ch->pcdata->offer_type == REL_STUDENT) {
        add_relationship(ch, REL_STUDENT, victim->name);
        add_relationship(victim, REL_TEACHER, ch->name);
      }
      else if (ch->pcdata->offer_type == REL_EMPLOYEE) {
        add_relationship(ch, REL_EMPLOYEE, victim->name);
        add_relationship(victim, REL_EMPLOYER, ch->name);
      }
      else {
        return;
      }
      send_to_char("Relationship formed.\n\r", ch);
      send_to_char("Relationship formed.\n\r", victim);

    }
    else if (!str_cmp(arg1, "break")) {
      for (int i = 0; i < 10; i++) {
        if (!str_cmp(arg2, ch->pcdata->relationship[i])) {
          struct stat sb;

          DESCRIPTOR_DATA d;
          bool online = FALSE;

          if (safe_strlen(arg2) < 2)
          return;

          d.original = NULL;
          if ((victim = get_char_world_pc(arg2)) != NULL) // Victim is online.
          online = TRUE;
          else {
            log_string("DESCRIPTOR: Relationship Break");

            if (!load_char_obj(&d, argument)) {
              free_string(ch->pcdata->relationship[i]);
              ch->pcdata->relationship[i] = str_dup("");
              ch->pcdata->relationship_type[i] = 0;
              send_to_char("You break the relationship.\n\r", ch);
              return;
            }

            sprintf(buf, "%s%s", PLAYER_DIR, capitalize(argument));
            stat(buf, &sb);
            victim = d.character;
          }
          if (IS_NPC(victim)) {
            if (!online)
            free_char(victim);
            return;
          }

          if (ch->pcdata->relationship_type[i] == REL_CHILD || ch->pcdata->relationship_type[i] == REL_PARENT || ch->pcdata->relationship_type[i] == REL_SIBLING || ch->pcdata->relationship_type[i] == REL_SIRELING || ch->pcdata->relationship_type[i] == REL_SIRE || ch->pcdata->relationship_type[i] == REL_WARD || ch->pcdata->relationship_type[i] == REL_PACTEE) {
            send_to_char("You can't break that relationship.\n\r", ch);
            if (!online)
            free_char(victim);
            return;
          }
          if (ch->pcdata->relationship_type[i] == REL_WEAKNESS || ch->pcdata->relationship_type[i] == REL_PRAESTES) {
            if (ch->pcdata->weakness_status > WEAKNESS_HAS) {
              send_to_char("You can't break that relationship right now.\n\r", ch);
              if (!online)
              free_char(victim);
              return;
            }
          }

          break_relationship(ch, victim, ch->pcdata->relationship_type[i]);

          save_char_obj(victim, FALSE, FALSE);
          if (!online)
          free_char(victim);

          send_to_char("Done.\n\r", ch);

          return;
        }
      }
    }
    else {
      for (int i = 0; i < 10; i++) {
        switch (ch->pcdata->relationship_type[i]) {
        case REL_CHILD:
          printf_to_char(ch, "You are the child of %s.\n\r", ch->pcdata->relationship[i]);
          break;
        case REL_PARENT:
          printf_to_char(ch, "You are the parent of %s.\n\r", ch->pcdata->relationship[i]);
          break;
        case REL_SPOUSE:
          printf_to_char(ch, "You are the spouse of %s.\n\r", ch->pcdata->relationship[i]);
          break;
        case REL_GUARDIAN:
          printf_to_char(ch, "You are the guardian of %s.\n\r", ch->pcdata->relationship[i]);
          break;
        case REL_WARD:
          printf_to_char(ch, "You are the ward of %s.\n\r", ch->pcdata->relationship[i]);
          break;
        case REL_SIBLING:
          printf_to_char(ch, "You are the sibling of %s.\n\r", ch->pcdata->relationship[i]);
          break;
        case REL_PACKMATE:
          printf_to_char(ch, "You are in a pack with %s.\n\r", ch->pcdata->relationship[i]);
          break;
        case REL_SIRE:
          printf_to_char(ch, "You are the sire of %s.\n\r", ch->pcdata->relationship[i]);
          break;
        case REL_SIRELING:
          printf_to_char(ch, "%s is your sire.\n\r", ch->pcdata->relationship[i]);
          break;
        case REL_TEACHER:
          printf_to_char(ch, "You are the teacher of %s.\n\r", ch->pcdata->relationship[i]);
          break;
        case REL_STUDENT:
          printf_to_char(ch, "%s is your teacher.\n\r", ch->pcdata->relationship[i]);
          break;
        case REL_DATING:
          printf_to_char(ch, "You are dating %s.\n\r", ch->pcdata->relationship[i]);
          break;
        case REL_WEAKNESS:
          printf_to_char(ch, "%s is your weakness.\n\r", ch->pcdata->relationship[i]);
          break;
        case REL_WEAKNESS_OF:
          printf_to_char(ch, "You are the weakness of %s.\n\r", ch->pcdata->relationship[i]);
          break;
        case REL_PRAESTES:
          printf_to_char(ch, "%s is your praestes.\n\r", ch->pcdata->relationship[i]);
          break;
        case REL_PRAESTES_OF:
          printf_to_char(ch, "You are the praestes of %s.\n\r", ch->pcdata->relationship[i]);
          break;
        case REL_PACTEE:
          printf_to_char(ch, "You have a pact with %s.\n\r", ch->pcdata->relationship[i]);
          break;
        case REL_PACTER:
          printf_to_char(ch, "You have a pact with %s.\n\r", ch->pcdata->relationship[i]);
          break;
        }
      }
      send_to_char("Syntax: relationship offer (person) (type), relationship accept (person), relationship break (person).\n\r", ch);
    }
  }

  bool is_sire(CHAR_DATA *sire, CHAR_DATA *sireling) {
    for (int i = 0; i < 10; i++) {
      if (!str_cmp(sire->pcdata->relationship[i], sireling->name) && sire->pcdata->relationship_type[i] == REL_SIRE)
      return TRUE;
    }
    return FALSE;
  }

  _DOFUN(do_scry) {
    if (!is_vampire(ch))
    return;

    if (ch->pcdata->tcooldown > 0) {
      send_to_char("You did that too recently.\n\r", ch);
      return;
    }

    CHAR_DATA *to;
    for (DescList::iterator it = descriptor_list.begin();
    it != descriptor_list.end(); ++it) {
      DESCRIPTOR_DATA *d = *it;

      if (d != NULL && d->character != NULL && d->connected == CON_PLAYING) {
        to = d->character;
        if (IS_NPC(to))
        continue;
        if (to == ch)
        continue;
        if (to->in_room == NULL || ch->in_room == NULL)
        continue;

        if (!is_sire(ch, to))
        continue;

        if (is_asleep(to))
        continue;

        if (silenced(ch) || silenced(to))
        continue;

        if (get_world(ch) != get_world(to))
        continue;

        if ((is_dark(to->in_room) && !can_see_dark(to)) || is_blind(to))
        printf_to_char(ch, "\nThrough %s's eyes you see darkness.\n\r", PERS(to, ch));
        else {
          printf_to_char(ch, "\nThrough %s's eyes you see:\n\r", PERS(to, ch));
          ROOM_INDEX_DATA *orig_room = ch->in_room;
          char_from_room(ch);
          char_to_room(ch, to->in_room);
          do_function(ch, &do_look, "");
          char_from_room(ch);
          char_to_room(ch, orig_room);
        }
      }
    }
    send_to_char("You are unable to locate them.\n\r", ch);
    ch->pcdata->tcooldown = 30;
  }

  void set_offline_pay(char *name, int amount) {
    struct stat sb;
    char buf[MIL];
    Buffer outbuf;
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    CHAR_DATA *victim;

    if (name[0] == '\0') {
      return;
    }

    d.original = NULL;
    if ((victim = get_char_world_pc(name)) != NULL) // Victim is online.
    online = TRUE;
    else {
      log_string("DESCRIPTOR: Set offline pay");

      if (!load_char_obj(&d, name)) {
        return;
      }

      sprintf(buf, "%s%s", PLAYER_DIR, capitalize(name));
      stat(buf, &sb);
      victim = d.character;
    }

    if (IS_NPC(victim)) {
      if (!online)
      free_char(victim);

      return;
    }

    victim->pcdata->payscale = amount;

    save_char_obj(victim, FALSE, FALSE);

    if (!online)
    free_char(victim);
  }

  _DOFUN(do_pay) {
    char arg1[MSL];

    argument = one_argument_nouncap(argument, arg1);

    int amount = atoi(argument);

    for (int i = 0; i < 10; i++) {
      if (!str_cmp(arg1, ch->pcdata->relationship[i]) && ch->pcdata->relationship_type[i] == REL_PARENT && amount >= 0 && amount <= 100) {
        set_offline_pay(ch->pcdata->relationship[i], amount);
        send_to_char("Done.\n\r", ch);
        return;
      }
    }
    for (int i = 0; i < 10; i++) {
      if (!str_cmp(arg1, ch->pcdata->relationship[i]) && ch->pcdata->relationship_type[i] == REL_GUARDIAN && amount >= 0 && amount <= 100) {
        set_offline_pay(ch->pcdata->relationship[i], amount);
        send_to_char("Done.\n\r", ch);
        return;
      }
    }
    for (int i = 0; i < 10; i++) {
      if (!str_cmp(arg1, ch->pcdata->relationship[i]) && ch->pcdata->relationship_type[i] == REL_EMPLOYER && amount >= 25 && amount <= 120) {
        set_offline_pay(ch->pcdata->relationship[i], amount);
        send_to_char("Done.\n\r", ch);
        return;
      }
    }
    send_to_char("Syntax: Pay (person) (amount) Amount is 0-100 for parents, 25-120 for employers.\n\r", ch);
  }

  bool is_natural(ROOM_INDEX_DATA *room) {
    if (room->sector_type == SECT_PARK || room->sector_type == SECT_FOREST || room->sector_type == SECT_CAVE || room->sector_type == SECT_SWAMP || room->sector_type == SECT_BEACH || room->sector_type == SECT_ROCKY)
    return TRUE;

    return FALSE;
  }

  bool has_nonconsume(CHAR_DATA *ch, int item) {
    OBJ_DATA *obj;
    OBJ_DATA *obj_next;

    if (is_gm(ch))
    return TRUE;

    for (obj = ch->carrying; obj != NULL; obj = obj_next) {
      obj_next = obj->next_content;

      if (IS_SET(obj->extra_flags, ITEM_WARDROBE))
      continue;

      if (obj->pIndexData->vnum == item)
      return TRUE;
    }
    if ((obj = get_eqr_char(ch, WEAR_HOLD)) != NULL) {
      if (obj->pIndexData->vnum == item)
      return TRUE;
    }
    if ((obj = get_eqr_char(ch, WEAR_HOLD_2)) != NULL) {
      if (obj->pIndexData->vnum == item)
      return TRUE;
    }

    return FALSE;
  }
  bool has_consume(CHAR_DATA *ch, int item) {
    OBJ_DATA *obj;
    OBJ_DATA *obj_next;

    if (is_gm(ch))
    return TRUE;

    for (obj = ch->carrying; obj != NULL; obj = obj_next) {
      obj_next = obj->next_content;

      if (IS_SET(obj->extra_flags, ITEM_WARDROBE))
      continue;

      if (obj->pIndexData->vnum == item) {
        if (!is_sparring(ch) && (IS_NPC(ch) || ch->pcdata->spectre == 0 || number_percent() % 2 == 0))
        extract_obj(obj);
        return TRUE;
      }
    }
    if ((obj = get_eqr_char(ch, WEAR_HOLD)) != NULL) {
      if (obj->pIndexData->vnum == item) {
        if (!is_sparring(ch) && (IS_NPC(ch) || ch->pcdata->spectre == 0 || number_percent() % 2 == 0)) {
          obj_from_char_silent(obj);
          extract_obj(obj);
        }
        return TRUE;
      }
    }
    if ((obj = get_eqr_char(ch, WEAR_HOLD_2)) != NULL) {
      if (obj->pIndexData->vnum == item) {
        if (!is_sparring(ch) && (IS_NPC(ch) || ch->pcdata->spectre == 0 || number_percent() % 2 == 0)) {
          obj_from_char_silent(obj);
          extract_obj(obj);
        }
        return TRUE;
      }
    }

    return FALSE;
  }

  void usemove(CHAR_DATA *ch) {
    if (ch->fight_fast == TRUE) {
      ch->move_timer += FIGHT_WAIT * fight_speed(ch);
    }
    else {
      if (!IS_FLAG(ch->fightflag, FIGHT_NOMOVE))
      SET_FLAG(ch->fightflag, FIGHT_NOMOVE);
    }
  }
  void useattack(CHAR_DATA *ch) {
    if (ch->fight_fast == TRUE) {
      ch->attack_timer += FIGHT_WAIT * fight_speed(ch);
    }
    else {
      if (!IS_FLAG(ch->fightflag, FIGHT_NOATTACK))
      SET_FLAG(ch->fightflag, FIGHT_NOATTACK);
      ch->actiontimer = UMIN(600, ch->actiontimer + 300);
      printf_to_char(
      ch, "You have %d minutes left to write your attacking/moving emote.\n\r", ch->actiontimer / 60);
    }
  }

  int abilcount(CHAR_DATA *ch) {
    int i, count = 0;
    for (i = 0; i < SKILL_USED; i++) {
      if (skilltype(skill_table[i].vnum) != STYPE_ABILITIES && skilltype(skill_table[i].vnum) != STYPE_SABILITIES)
      continue;
      count += ch->skills[skill_table[i].vnum];
    }

    if (ch->skills[SKILL_GADGETS] >= 2)
    count--;
    if (ch->skills[SKILL_SOLDIER] >= 1)
    count--;
    if (ch->skills[SKILL_SOLDIER] >= 2)
    count--;
    if (ch->skills[SKILL_SOLDIER] >= 4)
    count--;
    if (ch->skills[SKILL_RIOT] >= 1)
    count--;
    if (ch->skills[SKILL_RIOT] >= 4)
    count--;

    if (!is_natural(ch->in_room)) {
      if (ch->skills[SKILL_NATURE] >= 1)
      count--;
      if (ch->skills[SKILL_NATURE] >= 2)
      count--;
      if (ch->skills[SKILL_NATURE] >= 3)
      count--;
      if (ch->skills[SKILL_NATURE] >= 4)
      count--;
    }
    if (IS_SET(ch->in_room->room_flags, ROOM_INDOORS) && !is_raining(ch->in_room) && !is_hailing(ch->in_room) && !is_snowing(ch->in_room)) {
      if (ch->skills[SKILL_WEATHER] >= 5)
      count--;
    }
    if (IS_SET(ch->in_room->room_flags, ROOM_INDOORS)) {
      if (ch->skills[SKILL_WEATHER] >= 3)
      count--;
    }
    if (is_raining(ch->in_room)) {
      if (ch->skills[SKILL_PYRO] >= 5)
      count--;
    }
    if (!is_raining(ch->in_room)) {
      if (ch->skills[SKILL_CRYO] >= 5)
      count--;
    }
    if (ch->skills[SKILL_COMMANDO] >= 2)
    count--;

    if (is_animal(ch))
    return ch->skills[SKILL_BIOMANCY];

    count = UMIN(count, 6);

    return count;
  }

  bool abilcool(CHAR_DATA *ch, int skill, int level) {
    if (is_gm(ch))
    return FALSE;

    int val = (skill * 10) + level;

    for (int i = 0; i < 20; i++) {
      if (ch->pcdata->abilcools[i] == val)
      return TRUE;
    }
    return FALSE;
  }

  int ability_cooldown(CHAR_DATA *ch, int skill) {
    if (skill == SKILL_CRYO || skill == SKILL_PYRO || skill == SKILL_WEATHER || skill == SKILL_NATURE || skill == SKILL_NECRO || skill == SKILL_HAEMOMANCY || skill == SKILL_COMBAT_ILLUSIONS)
    return 1;

    return 2;
  }

  void resetabils(CHAR_DATA *ch) {
    for (int i = 0; i < 20; i++)
    ch->pcdata->abilcools[i] = 0;
    ch->ability_dead = 0;
    send_to_char("Your abilities are refreshed.\n\r", ch);
  }

  void useabil(CHAR_DATA *ch, int skill, int level) {
    ch->doneabil = TRUE;
    if (skill == SKILL_CRYO) {
      equip_focus(ch);
      focus_glow(ch, "glow blue-white");
    }

    if (skill == SKILL_PYRO) {
      equip_focus(ch);
      focus_glow(ch, "glow red-orange");
    }
    if (skill == SKILL_NATURE) {
      equip_focus(ch);
      focus_glow(ch, "glow deep green");
    }
    if (skill == SKILL_WEATHER) {
      if (level == 5) {
        equip_focus(ch);
        focus_glow(ch, "glow deep blue");
      }
      else {
        equip_focus(ch);
        focus_glow(ch, "crackle with lightning");
      }
    }
    if (skill == SKILL_NECRO) {
      equip_focus(ch);
      focus_glow(ch, "turn pure black and suck in ambiant light");
    }
    if (skill == SKILL_HAEMOMANCY) {
      equip_focus(ch);
      focus_glow(ch, "glow deep, dark red");
    }
    if (skill == SKILL_COMBAT_ILLUSIONS) {
      equip_focus(ch);
      focus_glow(ch, "shimmer with prismatic light");
    }

    int val = (skill * 10) + level;
    int count = abilcount(ch);
    count = UMAX(count, 4);
    count = UMIN(10, count);
    for (int i = 0; i < 20; i++) {
      if (ch->pcdata->abilcools[i] == 0) {
        if (count <= 2) {
          if (i >= count - 1) {
            resetabils(ch);
            return;
          }
        }
        else if (count <= 5) {
          if (i >= count) {
            resetabils(ch);
            return;
          }
        }
        else if (count <= 15) {
          if (i >= count - 1) {
            resetabils(ch);
            return;
          }
        }
        if (i >= 10) {
          resetabils(ch);
          return;
        }
        ch->pcdata->abilcools[i] = val;
        return;
      }
    }
    if (in_fight(ch) && ch->fight_fast == FALSE) {
      ch->actiontimer = UMIN(600, ch->actiontimer + 120);
      printf_to_char(
      ch, "You have %d seconds left to write your attacking/moving emote.\n\r", ch->actiontimer);
    }
  }

  bool has_fur(CHAR_DATA *ch) {
    if (IS_NPC(ch)) {
      if (is_npcanimal(ch))
      return TRUE;
      else
      return FALSE;
    }
    if (ch->shape == SHAPE_HUMAN)
    return FALSE;

    if (get_animal_genus(ch, ANIMAL_ACTIVE) == GENUS_MAMMAL)
    return TRUE;

    return FALSE;
  }

  bool has_focus(CHAR_DATA *ch) {
    if (IS_NPC(ch))
    return TRUE;
    OBJ_DATA *obj;
    int iWear;
    for (iWear = 0; iWear < MAX_WEAR; iWear++) {
      if ((obj = get_eq_char(ch, iWear)) != NULL && can_see_obj(ch, obj) && (can_see_wear(ch, iWear))) {
        if (IS_SET(obj->extra_flags, ITEM_WARDROBE))
        continue;

        if (IS_SET(obj->extra_flags, ITEM_FOCUS))
        return TRUE;
      }
    }
    for (obj = ch->carrying; obj != NULL; obj = obj->next_content) {
      if (IS_SET(obj->extra_flags, ITEM_WARDROBE))
      continue;

      if (CAN_WEAR(obj, ITEM_HOLD) && IS_SET(obj->extra_flags, ITEM_FOCUS))
      return TRUE;
    }
    return FALSE;
  }
  
  void equip_focus(CHAR_DATA *ch) {
    if (IS_NPC(ch))
    return;
    OBJ_DATA *obj;
    for (obj = ch->carrying; obj != NULL; obj = obj->next_content) {
      if (IS_SET(obj->extra_flags, ITEM_WARDROBE))
      continue;

      if (IS_SET(obj->extra_flags, ITEM_FOCUS) && CAN_WEAR(obj, ITEM_HOLD)) {
        if (get_eqr_char(ch, WEAR_HOLD) == NULL) {
          equip_char(ch, obj, WEAR_HOLD);
          return;
        }
        else if (get_eqr_char(ch, WEAR_HOLD_2) == NULL) {
          equip_char(ch, obj, WEAR_HOLD_2);
          return;
        }
        else {
          unequip_char(ch, get_eqr_char(ch, WEAR_HOLD));
          equip_char(ch, obj, WEAR_HOLD);
          return;
        }
      }
    }
  }
  
  void focus_glow(CHAR_DATA *ch, char *color) {
    if (IS_NPC(ch))
    return;
    OBJ_DATA *obj;
    int iWear;
    char buf[MSL];
    for (iWear = 0; iWear < MAX_WEAR; iWear++) {
      if ((obj = get_eq_char(ch, iWear)) != NULL && can_see_obj(ch, obj) && (can_see_wear(ch, iWear))) {
        if (IS_SET(obj->extra_flags, ITEM_FOCUS) && number_percent() % 3 == 0) {
          sprintf(buf, "Runes on $n's $p %s.", color);
          act(buf, ch, obj, NULL, TO_ROOM);
          sprintf(buf, "Runes on your $p %s.", color);
          act(buf, ch, obj, NULL, TO_CHAR);

          if (under_opression(ch) && number_percent() % 20 == 0) {
            act("Your $p breaks.", ch, obj, NULL, TO_CHAR);
            extract_obj(obj);
          }
          return;
        }
      }
    }
    for (iWear = 0; iWear < MAX_WEAR; iWear++) {
      if ((obj = get_eq_char(ch, iWear)) != NULL && can_see_obj(ch, obj) && (can_see_wear(ch, iWear))) {
        if (IS_SET(obj->extra_flags, ITEM_FOCUS)) {
          sprintf(buf, "Runes on $n's $p %s.", color);
          act(buf, ch, obj, NULL, TO_ROOM);
          sprintf(buf, "Runes on your $p %s.", color);
          act(buf, ch, obj, NULL, TO_CHAR);
          if (under_opression(ch) && number_percent() % 20 == 0) {
            act("Your $p breaks.", ch, obj, NULL, TO_CHAR);
            extract_obj(obj);
          }

          return;
        }
      }
    }
  }

  int arcane_lifeforce(CHAR_DATA *ch, bool used) {
    int val = get_lifeforce(ch, used, NULL);
    val = UMAX(val, 80);
    val = UMIN(val, 120);
    return val;
  }

  int debuff_multiplier(CHAR_DATA *ch, CHAR_DATA *victim) {
    int chscore = UMIN(get_tier(ch), arcane_focus(ch)) + 1;
    int vicscore = get_tier(victim);
    int modifier = 100 * chscore / vicscore;
    modifier =
    modifier * arcane_lifeforce(ch, TRUE) / arcane_lifeforce(victim, FALSE);
    modifier -= UMIN(75, ch->debuff / 2);
    modifier += victim->negative_magic;
    modifier *= 2;
    modifier = modifier * (100 + soc_wealth_mod(ch, TRUE)) / 100;

    int world = get_world(victim);
    if (world == WORLD_EARTH && modifier > 100) {
      modifier -= 100;
      modifier /= 4;
      modifier += 100;
      modifier = UMAX(modifier, 10);
      modifier = UMIN(modifier, 200);
    }
    else if ((world == WORLD_GODREALM || world == WORLD_WILDS || world == WORLD_HELL) && modifier > 100) {
      modifier -= 100;
      modifier /= 2;
      modifier += 100;
      modifier = UMAX(modifier, 30);
      modifier = UMIN(modifier, 300);
    }
    else if (world == WORLD_OTHER && modifier > 100) {
      modifier = UMAX(modifier, 50);
      modifier = UMIN(modifier, 500);
    }
    char buf[MSL];
    sprintf(buf, "MAGIC Debuff: Ch: %s, Vic: %s, Chscore: %d, vicscore: %d, chlf: %d, viclf: %d, Mod: %d, negmagic: %d, world: %d", ch->name, victim->name, chscore, vicscore, arcane_lifeforce(ch, TRUE), arcane_lifeforce(victim, FALSE), modifier, victim->negative_magic, world);
    log_string(buf);
    int remainder = modifier % 100;

    victim->negative_magic = remainder;
    modifier -= remainder;
    victim->positive_magic /= 2;

    if (victim->modifier == MODIFIER_CURSED)
    modifier = modifier * 5 / 4;

    return modifier;
  }

  int buff_multiplier(CHAR_DATA *ch, CHAR_DATA *victim) {
    int chscore = UMIN(get_tier(ch), arcane_focus(ch)) + 1;
    int vicscore = 2;

    int modifier = 100 * chscore / vicscore;

    modifier = modifier * arcane_lifeforce(ch, TRUE) / 100;

    modifier -= UMIN(75, ch->debuff / 2);

    modifier += victim->positive_magic;

    modifier *= 2;

    modifier = modifier * (100 + soc_wealth_mod(ch, TRUE))/100;

    int world = get_world(victim);
    if (world == WORLD_EARTH && modifier > 100) {
      modifier -= 100;
      modifier /= 4;
      modifier += 100;
      modifier = UMAX(modifier, 10);
      modifier = UMIN(modifier, 200);
    }
    else if ((world == WORLD_GODREALM || world == WORLD_WILDS || world == WORLD_HELL) && modifier > 100) {
      modifier -= 100;
      modifier /= 2;
      modifier += 100;
      modifier = UMAX(modifier, 30);
      modifier = UMIN(modifier, 300);
    }
    else if (world == WORLD_OTHER && modifier > 100) {
      modifier = UMAX(modifier, 50);
      modifier = UMIN(modifier, 500);
    }
    char buf[MSL];
    sprintf(buf, "MAGIC Buff: Ch: %s, Vic: %s, Chscore: %d, vicscore: %d, chlf: %d, Mod: %d, posmagic: %d, world: %d", ch->name, victim->name, chscore, vicscore, arcane_lifeforce(ch, TRUE), modifier, victim->positive_magic, world);
    log_string(buf);

    int remainder = modifier % 100;

    victim->positive_magic = remainder;
    modifier -= remainder;
    victim->negative_magic /= 2;
    return modifier;
  }

  _DOFUN(do_ability) {
    char arg1[MSL];
    char arg2[MSL];
    argument = one_argument_nouncap(argument, arg1);
    if (arg1[0] == '\0') {
      char buf[MSL];
      char string[MSL];
      strcpy(string, "");
      strcpy(buf, "");
      sprintf(buf, "Abilities: ");
      strcat(string, buf);
      if (get_skill(ch, SKILL_GADGETS) >= 2 && has_nonconsume(ch, ITEM_PEPPER) && abilcool(ch, SKILL_GADGETS, 1) == FALSE) {
        sprintf(buf, "pepperspray, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_GADGETS) >= 2 && has_nonconsume(ch, ITEM_BANDAGE) && abilcool(ch, SKILL_GADGETS, 2) == FALSE) {
        sprintf(buf, "triage, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_GADGETS) >= 3 && has_nonconsume(ch, ITEM_TASER) && abilcool(ch, SKILL_GADGETS, 3) == FALSE) {
        sprintf(buf, "taser, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_GADGETS) >= 3 && has_nonconsume(ch, ITEM_TASER) && has_nonconsume(ch, ITEM_TASERDART)
      && abilcool(ch, SKILL_GADGETS, 4) == FALSE) {
        sprintf(buf, "tasergun, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_GADGETS) >= 3 && has_nonconsume(ch, ITEM_TRANQGUN) && has_nonconsume(ch, ITEM_TRANQDART)
      && abilcool(ch, SKILL_GADGETS, 5) == FALSE) {
        sprintf(buf, "tranq, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_MARTIAL) >= 2 && abilcool(ch, SKILL_MARTIAL, 1) == FALSE) {
        sprintf(buf, "grapple, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_MARTIAL) >= 2 && abilcool(ch, SKILL_MARTIAL, 2) == FALSE) {
        sprintf(buf, "trip, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_MARTIAL) >= 3 && abilcool(ch, SKILL_MARTIAL, 3) == FALSE) {
        sprintf(buf, "disarm, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_MARTIAL) >= 3 && abilcool(ch, SKILL_MARTIAL, 4) == FALSE) {
        sprintf(buf, "bodyshield, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_MARTIAL) >= 3 && abilcool(ch, SKILL_MARTIAL, 5) == FALSE) {
        sprintf(buf, "throw, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_SOLDIER) >= 2) {
        sprintf(buf, "suppressor, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_SOLDIER) >= 2) {
        sprintf(buf, "bipod, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_SOLDIER) >= 3 && abilcool(ch, SKILL_SOLDIER, 3) == FALSE) {
        sprintf(buf, "laserdesignate, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_SOLDIER) >= 3 && abilcool(ch, SKILL_SOLDIER, 5) == FALSE) {
        sprintf(buf, "suppressingfire, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_COMMANDO) >= 2 && abilcool(ch, SKILL_COMMANDO, 1) == FALSE) {
        sprintf(buf, "caltrops, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_COMMANDO) >= 3 && abilcool(ch, SKILL_COMMANDO, 3) == FALSE) {
        sprintf(buf, "landmine, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_COMMANDO) >= 3 && abilcool(ch, SKILL_COMMANDO, 4) == FALSE) {
        sprintf(buf, "bola, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_COMMANDO) >= 3 && abilcool(ch, SKILL_COMMANDO, 5) == FALSE) {
        sprintf(buf, "deadswitch, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_RIOT) >= 2 && has_nonconsume(ch, ITEM_GASMASK)) {
        sprintf(buf, "gasmask, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_RIOT) >= 2 && has_nonconsume(ch, ITEM_SMOKEGRENADE) && abilcool(ch, SKILL_RIOT, 2) == FALSE) {
        sprintf(buf, "smokegrenade, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_RIOT) >= 3 && has_nonconsume(ch, ITEM_TEARGRENADE) && abilcool(ch, SKILL_RIOT, 3) == FALSE) {
        sprintf(buf, "teargas, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_RIOT) >= 3 && has_nonconsume(ch, ITEM_FRAGGRENADE) && abilcool(ch, SKILL_RIOT, 5) == FALSE) {
        sprintf(buf, "fraggrenade, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_NATURE) >= 1 && is_natural(ch->in_room) && has_focus(ch) && abilcool(ch, SKILL_NATURE, 1) == FALSE) {
        sprintf(buf, "root, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_NATURE) >= 1 && is_natural(ch->in_room) && has_focus(ch) && abilcool(ch, SKILL_NATURE, 2) == FALSE) {
        sprintf(buf, "quicksand, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_NATURE) >= 1 && is_natural(ch->in_room) && has_focus(ch) && abilcool(ch, SKILL_NATURE, 3) == FALSE) {
        sprintf(buf, "rapidgrowth, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_NATURE) >= 2 && is_natural(ch->in_room) && has_focus(ch) && abilcool(ch, SKILL_NATURE, 4) == FALSE) {
        sprintf(buf, "tremor, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_NATURE) >= 2 && has_focus(ch) && abilcool(ch, SKILL_NATURE, 5) == FALSE) {
        sprintf(buf, "commandbeast, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_PSYCHIC) >= 1) {
        sprintf(buf, "bewilder, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_PSYCHIC) >= 1 && abilcool(ch, SKILL_PSYCHIC, 2) == FALSE) {
        sprintf(buf, "confuse, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_PSYCHIC) >= 1 && abilcool(ch, SKILL_PSYCHIC, 3) == FALSE) {
        sprintf(buf, "doubt, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_PSYCHIC) >= 2 && abilcool(ch, SKILL_PSYCHIC, 4) == FALSE) {
        sprintf(buf, "stasis, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_PSYCHIC) >= 2 && abilcool(ch, SKILL_PSYCHIC, 5) == FALSE) {
        sprintf(buf, "fear, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_COMBAT_ILLUSIONS) >= 1 && has_focus(ch) && abilcool(ch, SKILL_COMBAT_ILLUSIONS, 1) == FALSE) {
        sprintf(buf, "distract, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_COMBAT_ILLUSIONS) >= 1 && has_focus(ch) && abilcool(ch, SKILL_COMBAT_ILLUSIONS, 2) == FALSE) {
        sprintf(buf, "double, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_COMBAT_ILLUSIONS) >= 1 && has_focus(ch) && abilcool(ch, SKILL_COMBAT_ILLUSIONS, 3) == FALSE) {
        sprintf(buf, "cloak, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_COMBAT_ILLUSIONS) >= 2 && has_focus(ch) && abilcool(ch, SKILL_COMBAT_ILLUSIONS, 4) == FALSE) {
        sprintf(buf, "aura, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_COMBAT_ILLUSIONS) >= 2 && has_focus(ch) && abilcool(ch, SKILL_COMBAT_ILLUSIONS, 5) == FALSE) {
        sprintf(buf, "trick, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_HAEMOMANCY) >= 1 && has_focus(ch) && abilcool(ch, SKILL_HAEMOMANCY, 1) == FALSE) {
        sprintf(buf, "burstvessel, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_HAEMOMANCY) >= 1 && has_focus(ch) && abilcool(ch, SKILL_HAEMOMANCY, 2) == FALSE) {
        sprintf(buf, "slowheart, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_HAEMOMANCY) >= 1 && has_focus(ch) && abilcool(ch, SKILL_HAEMOMANCY, 3) == FALSE) {
        sprintf(buf, "declot, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_HAEMOMANCY) >= 2 && has_focus(ch) && abilcool(ch, SKILL_HAEMOMANCY, 4) == FALSE) {
        sprintf(buf, "heartattack, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_HAEMOMANCY) >= 2 && has_focus(ch) && abilcool(ch, SKILL_HAEMOMANCY, 5) == FALSE) {
        sprintf(buf, "bleed, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_TELEKINESIS) >= 1 && abilcool(ch, SKILL_TELEKINESIS, 1) == FALSE) {
        sprintf(buf, "push, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_TELEKINESIS) >= 1 && abilcool(ch, SKILL_TELEKINESIS, 2) == FALSE) {
        sprintf(buf, "pull, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_TELEKINESIS) >= 2 && abilcool(ch, SKILL_TELEKINESIS, 3) == FALSE) {
        sprintf(buf, "tklift, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_TELEKINESIS) >= 2 && abilcool(ch, SKILL_TELEKINESIS, 4) == FALSE) {
        sprintf(buf, "tkthrow, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_TELEKINESIS) >= 2 && abilcool(ch, SKILL_TELEKINESIS, 5) == FALSE) {
        sprintf(buf, "tkjump, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_ANGELCOMBAT) >= 1 && abilcool(ch, SKILL_ANGELCOMBAT, 1) == FALSE) {
        sprintf(buf, "fieryweapon, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_ANGELCOMBAT) >= 1 && abilcool(ch, SKILL_ANGELCOMBAT, 2) == FALSE) {
        sprintf(buf, "incandescence, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_ANGELCOMBAT) >= 2 && abilcool(ch, SKILL_ANGELCOMBAT, 3) == FALSE) {
        sprintf(buf, "heataura, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_ANGELCOMBAT) >= 2 && abilcool(ch, SKILL_ANGELCOMBAT, 4) == FALSE) {
        sprintf(buf, "lightfeet, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_ANGELCOMBAT) >= 2 && abilcool(ch, SKILL_ANGELCOMBAT, 5) == FALSE) {
        sprintf(buf, "burden, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_PRIMALCOMBAT) >= 1 && abilcool(ch, SKILL_PRIMALCOMBAT, 1) == FALSE) {
        sprintf(buf, "takedown, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_PRIMALCOMBAT) >= 1 && abilcool(ch, SKILL_PRIMALCOMBAT, 2) == FALSE) {
        sprintf(buf, "rush, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_PRIMALCOMBAT) >= 2 && abilcool(ch, SKILL_PRIMALCOMBAT, 3) == FALSE) {
        sprintf(buf, "prowl, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_PRIMALCOMBAT) >= 2 && abilcool(ch, SKILL_PRIMALCOMBAT, 4) == FALSE) {
        sprintf(buf, "ferocity, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_PRIMALCOMBAT) >= 2 && abilcool(ch, SKILL_PRIMALCOMBAT, 5) == FALSE) {
        sprintf(buf, "pounce, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_DAYASPECT) >= 1 && abilcool(ch, SKILL_DAYASPECT, 1) == FALSE) {
        sprintf(buf, "messengeraspect, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_DAYASPECT) >= 1 && abilcool(ch, SKILL_DAYASPECT, 2) == FALSE) {
        sprintf(buf, "sunaspect, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_DAYASPECT) >= 2 && abilcool(ch, SKILL_DAYASPECT, 3) == FALSE) {
        sprintf(buf, "warrioraspect, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_DAYASPECT) >= 2 && abilcool(ch, SKILL_DAYASPECT, 4) == FALSE) {
        sprintf(buf, "smithaspect, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_DAYASPECT) >= 2 && abilcool(ch, SKILL_DAYASPECT, 5) == FALSE) {
        sprintf(buf, "healeraspect, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_NIGHTASPECT) >= 1 && abilcool(ch, SKILL_NIGHTASPECT, 1) == FALSE) {
        sprintf(buf, "underworldaspect, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_NIGHTASPECT) >= 1 && abilcool(ch, SKILL_NIGHTASPECT, 2) == FALSE) {
        sprintf(buf, "moonaspect, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_NIGHTASPECT) >= 2 && abilcool(ch, SKILL_NIGHTASPECT, 3) == FALSE) {
        sprintf(buf, "thunderaspect, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_NIGHTASPECT) >= 2 && abilcool(ch, SKILL_NIGHTASPECT, 4) == FALSE) {
        sprintf(buf, "windaspect, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_NIGHTASPECT) >= 2 && abilcool(ch, SKILL_NIGHTASPECT, 5) == FALSE) {
        sprintf(buf, "hunteraspect, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_WEATHER) >= 1 && has_focus(ch) && abilcool(ch, SKILL_WEATHER, 1) == FALSE) {
        sprintf(buf, "gust, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_WEATHER) >= 1 && has_focus(ch) && abilcool(ch, SKILL_WEATHER, 2) == FALSE) {
        sprintf(buf, "thickenair, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_WEATHER) >= 2 && has_focus(ch) && abilcool(ch, SKILL_WEATHER, 3) == FALSE) {
        sprintf(buf, "wind, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_WEATHER) >= 2 && has_focus(ch) && abilcool(ch, SKILL_WEATHER, 4) == FALSE) {
        sprintf(buf, "suffocate, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_WEATHER) >= 2 && has_focus(ch) && abilcool(ch, SKILL_WEATHER, 5) == FALSE) {
        sprintf(buf, "lightningstrike, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_MAGNO) >= 1 && abilcool(ch, SKILL_MAGNO, 1) == FALSE) {
        sprintf(buf, "jam, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_MAGNO) >= 2 && abilcool(ch, SKILL_MAGNO, 2) == FALSE) {
        sprintf(buf, "curvebullets, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_MAGNO) >= 2 && abilcool(ch, SKILL_MAGNO, 3) == FALSE) {
        sprintf(buf, "repel, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_MAGNO) >= 1 && abilcool(ch, SKILL_MAGNO, 4) == FALSE) {
        sprintf(buf, "overload, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_MAGNO) >= 2 && abilcool(ch, SKILL_MAGNO, 5) == FALSE) {
        sprintf(buf, "reflect, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_BIOMANCY) >= 1 && abilcool(ch, SKILL_BIOMANCY, 1) == FALSE) {
        sprintf(buf, "adrenaline, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_BIOMANCY) >= 1 && abilcool(ch, SKILL_BIOMANCY, 2) == FALSE) {
        sprintf(buf, "heal, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_BIOMANCY) >= 2 && abilcool(ch, SKILL_BIOMANCY, 3) == FALSE) {
        sprintf(buf, "resistpain, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_BIOMANCY) >= 2 && abilcool(ch, SKILL_BIOMANCY, 4) == FALSE) {
        sprintf(buf, "recover, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_BIOMANCY) >= 2 && abilcool(ch, SKILL_BIOMANCY, 5) == FALSE) {
        sprintf(buf, "oxygenate, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_CRYO) >= 1 && has_focus(ch) && abilcool(ch, SKILL_CRYO, 1) == FALSE) {
        sprintf(buf, "chill, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_CRYO) >= 1 && has_focus(ch) && abilcool(ch, SKILL_CRYO, 2) == FALSE) {
        sprintf(buf, "reinforce, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_CRYO) >= 2 && has_focus(ch) && abilcool(ch, SKILL_CRYO, 3) == FALSE) {
        sprintf(buf, "stickweapons, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_CRYO) >= 1 && has_focus(ch) && abilcool(ch, SKILL_CRYO, 4) == FALSE) {
        sprintf(buf, "colddiscipline, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_CRYO) >= 2 && has_focus(ch) && abilcool(ch, SKILL_CRYO, 5) == FALSE) {
        sprintf(buf, "coldsnap, ");
        strcat(string, buf);
      }

      if (get_skill(ch, SKILL_PYRO) >= 1 && has_focus(ch) && abilcool(ch, SKILL_PYRO, 1) == FALSE) {
        sprintf(buf, "sweat, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_PYRO) >= 1 && has_focus(ch) && abilcool(ch, SKILL_PYRO, 2) == FALSE) {
        sprintf(buf, "burnarmor, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_PYRO) >= 2 && has_focus(ch) && abilcool(ch, SKILL_PYRO, 3) == FALSE) {
        sprintf(buf, "burnweapon, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_PYRO) >= 1 && has_focus(ch) && abilcool(ch, SKILL_PYRO, 4) == FALSE) {
        sprintf(buf, "heatmetal, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_PYRO) >= 2 && has_focus(ch) && abilcool(ch, SKILL_PYRO, 5) == FALSE) {
        sprintf(buf, "startfire, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_NECRO) >= 1 && has_focus(ch) && abilcool(ch, SKILL_NECRO, 1) == FALSE) {
        sprintf(buf, "regenerate, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_NECRO) >= 1 && has_focus(ch) && abilcool(ch, SKILL_NECRO, 2) == FALSE) {
        sprintf(buf, "rigormortis, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_NECRO) >= 1 && has_focus(ch) && abilcool(ch, SKILL_NECRO, 3) == FALSE) {
        sprintf(buf, "lethargy, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_NECRO) >= 2 && has_focus(ch) && abilcool(ch, SKILL_NECRO, 4) == FALSE) {
        sprintf(buf, "halt, ");
        strcat(string, buf);
      }
      if (get_skill(ch, SKILL_NECRO) >= 2 && has_focus(ch) && abilcool(ch, SKILL_NECRO, 5) == FALSE) {
        sprintf(buf, "commandundead, ");
        strcat(string, buf);
      }
      strcat(string, "\n\r");
      send_to_char(string, ch);
      return;
    }

    argument = one_argument_nouncap(argument, arg2);
    int mult = 100;
    CHAR_DATA *victim = NULL;
    if (in_fight(ch) == TRUE && ch->ability_timer > 0 && ch->fight_fast == TRUE && !is_gm(ch) && get_skill(ch, SKILL_MAGICOVERLOAD) <= 0) {
      free_string(ch->abilmove);
      ch->abilmove = str_dup(argument);
      send_to_char("Command stacked.\n\r", ch);
      return;
    }
    if (in_fight(ch) == TRUE && ch->ability_timer > FIGHT_WAIT * fight_speed(ch) && ch->fight_fast == TRUE && !is_gm(ch) && get_skill(ch, SKILL_MAGICOVERLOAD) > 0) {
      free_string(ch->abilmove);
      ch->abilmove = str_dup(argument);
      send_to_char("Command stacked.\n\r", ch);
      return;
    }

    if (!in_fight(ch)) {
      send_to_char("You're not in a fight.\n\r", ch);
      return;
    }

    if (ch->fight_fast == FALSE && !is_gm(ch)) {
      if (ch->doneabil == TRUE) {
        send_to_char("You've already input an ability this turn.\n\r", ch);
        return;
      }
    }

    if (ch->ability_timer > 0 && !is_gm(ch)) {
      send_to_char("You can't use another ability yet.\n\r", ch);
      return;
    }
    if (in_fight(ch) && ch->fight_fast == FALSE && ch->fight_current != ch) {
      send_to_char("It's not your turn yet.\n\r", ch);
      return;
    }

    if (!str_cmp(arg1, "channelpositive")) {
      if (arcane_focus(ch) < 1) {
        send_to_char("You don't know how to do that.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }

      act("You gesture at $N with your right hand.", ch, NULL, victim, TO_CHAR);
      act("$n gestures at you with $s right hand.", ch, NULL, victim, TO_VICT);
      act("$n gestures at $N with $s right hand.", ch, NULL, victim, TO_NOTVICT);

      int negative = victim->negative_magic;
      int mult = buff_multiplier(ch, victim);
      mult *= 2;
      mult = UMAX(
      mult / 10, (mult * ((max_hp(victim) - victim->hit) * 100 / max_hp(victim))) / 100);
      victim->positive_magic += mult;
      victim->negative_magic = negative + mult / 3;
      useattack(ch);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) * 1 / 2;
      else
      ch->ability_timer += FIGHT_WAIT * 2 * 1 / 2;
    }
    else if (!str_cmp(arg1, "channelnegative")) {
      if (arcane_focus(ch) < 1) {
        send_to_char("You don't know how to do that.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }

      act("You gesture at $N with your left hand.", ch, NULL, victim, TO_CHAR);
      act("$n gestures at you with $s left hand.", ch, NULL, victim, TO_VICT);
      act("$n gestures at $N with $s left hand.", ch, NULL, victim, TO_NOTVICT);

      int positive = victim->positive_magic;
      int mult = debuff_multiplier(ch, victim);
      mult *= 2;
      mult = UMAX(
      mult / 10, (mult * ((max_hp(victim) - victim->hit) * 100 / max_hp(victim))) / 100);
      victim->negative_magic += mult;
      victim->positive_magic = positive + mult / 3;

      useattack(ch);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) * 1 / 2;
      else
      ch->ability_timer += FIGHT_WAIT * 2 * 1 / 2;
    }
    else if (!str_cmp(arg1, "pepperspray")) {
      if (get_skill(ch, SKILL_GADGETS) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (!has_nonconsume(ch, ITEM_PEPPER)) {
        send_to_char("You need to have some pepper spray first.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (combat_distance(ch, victim, TRUE) > 10) {
        send_to_char("They're too far away.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }

      if (abilcool(ch, SKILL_GADGETS, 1)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_GADGETS, 1);

      act("You spray $N in the face with pepper spray.", ch, NULL, victim, TO_CHAR);
      act("$n sprays you in the face with pepper spray.", ch, NULL, victim, TO_VICT);
      act("$n sprays $N in the face with pepper spray.", ch, NULL, victim, TO_NOTVICT);
      if (battleground(ch->in_room))
      op_report(
      logact("$n sprays $N in the face with pepper spray.", ch, victim), ch);

      useattack(ch);
      apply_caff(victim, CAFF_BLIND, 1);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_GADGETS) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_GADGETS) / 2;
    }
    else if (!str_cmp(arg1, "triage")) {
      if (get_skill(ch, SKILL_GADGETS) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (combat_distance(ch, victim, TRUE) > 2) {
        send_to_char("They're too far away.\n\r", ch);
        return;
      }
      if (has_caff(victim, CAFF_TRIAGE))
      {
        send_to_char("They have already recently been bandaged.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }

      if (!has_consume(ch, ITEM_BANDAGE)) {
        send_to_char("You need to have a bandage first.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_GADGETS, 2)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }

      if (!is_undead(victim)) {
        if (ch == victim)
        victim->hit = UMIN(max_hp(victim), victim->hit + max_hp(victim) / 10);
        else
        victim->hit = UMIN(max_hp(victim), victim->hit + max_hp(victim) / 5);
      }
      apply_caff(victim, CAFF_TRIAGE, 1);
      act("You quickly bandage some of $N's injuries.", ch, NULL, victim, TO_CHAR);
      act("$n quickly bandages some of your injuries.", ch, NULL, victim, TO_VICT);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_GADGETS) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_GADGETS) / 2;
      usemove(ch);
      useattack(ch);
    }
    else if (!str_cmp(arg1, "taser")) {
      if (get_skill(ch, SKILL_GADGETS) < 3) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (no_tech(ch)) {
        send_to_char("It doesn't work for some reason.\n\r", ch);
        return;
      }
      if (!has_nonconsume(ch, ITEM_TASER)) {
        send_to_char("You need to have a taser first.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (combat_distance(ch, victim, TRUE) > 2) {
        send_to_char("They're too far away.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }

      if (deep_water(ch))
      victim = ch;
      if (abilcool(ch, SKILL_GADGETS, 3)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_GADGETS, 3);

      act("You jab $N with a taser", ch, NULL, victim, TO_CHAR);
      act("$n jabs $N with a taser.", ch, NULL, victim, TO_VICT);
      act("$n jabs $N with a taser.", ch, NULL, victim, TO_NOTVICT);
      if (battleground(ch->in_room))
      op_report(logact("$n jabs $N with a taser.", ch, victim), ch);

      if (get_skill(victim, SKILL_ELECPROOF) < 1)
      apply_caff(victim, CAFF_SLOW, 1);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_GADGETS) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_GADGETS) / 2;
      useattack(ch);
      if (get_skill(victim, SKILL_ELECPROOF) < 1)
      noattack(victim);
    }
    else if (!str_cmp(arg1, "tasergun")) {
      if (get_skill(ch, SKILL_GADGETS) < 3) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (no_tech(ch)) {
        send_to_char("It doesn't work for some reason.\n\r", ch);
        return;
      }
      if (!has_nonconsume(ch, ITEM_TASER)) {
        send_to_char("You need to have a taser first.\n\r", ch);
        return;
      }

      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (combat_distance(ch, victim, TRUE) > 20) {
        send_to_char("They're too far away.\n\r", ch);
        return;
      }
      if (!has_consume(ch, ITEM_TASERDART)) {
        send_to_char("You need to have a taser dart first.\n\r", ch);
        return;
      }
      if (deep_water(ch))
      victim = ch;
      if (abilcool(ch, SKILL_GADGETS, 4)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_GADGETS, 4);

      act("You shoot $N with a taser.", ch, NULL, victim, TO_CHAR);
      act("$n shoots $N with a taser.", ch, NULL, victim, TO_VICT);
      act("$n shoots $N with a taser.", ch, NULL, victim, TO_NOTVICT);
      if (battleground(ch->in_room))
      op_report(logact("$n shoots $N with a taser.", ch, victim), ch);

      if (get_skill(victim, SKILL_ELECPROOF) < 1)
      apply_caff(victim, CAFF_SLOW, 1);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_GADGETS) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_GADGETS) / 2;
      useattack(ch);
      if (get_skill(victim, SKILL_ELECPROOF) < 1)
      noattack(victim);
    }
    else if (!str_cmp(arg1, "tranq")) {
      if (get_skill(ch, SKILL_GADGETS) < 3) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (!has_nonconsume(ch, ITEM_TRANQGUN)) {
        send_to_char("You need to have a tranq gun first.\n\r", ch);
        return;
      }
      if (!has_consume(ch, ITEM_TRANQDART)) {
        send_to_char("You need to have a tranq dart first.\n\r", ch);
        return;
      }

      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (combat_distance(ch, victim, TRUE) > 50) {
        send_to_char("They're too far away.\n\r", ch);
        return;
      }

      if (abilcool(ch, SKILL_GADGETS, 5)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_GADGETS, 5);

      act("You shoot $N with a tranq dart.", ch, NULL, victim, TO_CHAR);
      act("$n shoots you with a tranq dart.", ch, NULL, victim, TO_VICT);
      act("$n shoots $N with a tranq dart.", ch, NULL, victim, TO_NOTVICT);
      if (battleground(ch->in_room))
      op_report(logact("$n shoots $N with a tranq dart.", ch, victim), ch);

      apply_caff(victim, CAFF_SLOW, 1);
      apply_caff(victim, CAFF_WEAKEN, 1);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_GADGETS) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_GADGETS) / 2;
    }
    else if (!str_cmp(arg1, "grapple")) {
      if (get_skill(ch, SKILL_MARTIAL) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (combat_distance(ch, victim, TRUE) > 1) {
        send_to_char("They're too far away.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_MARTIAL, 1)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_MARTIAL, 1);

      act("You grapple with $N.", ch, NULL, victim, TO_CHAR);
      act("$n grapples with you.", ch, NULL, victim, TO_VICT);
      act("$n grapples with $N.", ch, NULL, victim, TO_NOTVICT);
      if (battleground(ch->in_room))
      op_report(logact("$n grapples with $N.", ch, victim), ch);

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_MARTIAL) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_MARTIAL) / 2;
      usemove(ch);
      nomove(victim);
    }
    else if (!str_cmp(arg1, "trip")) {
      if (get_skill(ch, SKILL_MARTIAL) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (combat_distance(ch, victim, TRUE) > 1) {
        send_to_char("They're too far away.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_MARTIAL, 2)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_MARTIAL, 2);

      act("You trip $N.", ch, NULL, victim, TO_CHAR);
      act("$n trips you.", ch, NULL, victim, TO_VICT);
      act("$n trips $N.", ch, NULL, victim, TO_NOTVICT);
      if (battleground(ch->in_room))
      op_report(logact("$n trips $N.", ch, victim), ch);

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_MARTIAL) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_MARTIAL) / 2;
      nomove(victim);
    }
    else if (!str_cmp(arg1, "disarm")) {
      if (get_skill(ch, SKILL_MARTIAL) < 3) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (combat_distance(ch, victim, TRUE) > 1) {
        send_to_char("They're too far away.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_MARTIAL, 3)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_MARTIAL, 3);

      act("You disarm $N.", ch, NULL, victim, TO_CHAR);
      act("$n disarms you.", ch, NULL, victim, TO_VICT);
      act("$n disarms $N.", ch, NULL, victim, TO_NOTVICT);
      if (battleground(ch->in_room))
      op_report(logact("$n disarms $N.", ch, victim), ch);

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_MARTIAL) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_MARTIAL) / 2;
      apply_caff(victim, CAFF_DISARMED, 1);
    }
    else if (!str_cmp(arg1, "bodyshield")) {
      if (get_skill(ch, SKILL_MARTIAL) < 3) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (combat_distance(ch, victim, TRUE) > 1) {
        send_to_char("They're too far away.\n\r", ch);
        return;
      }
      if (is_in_cover(victim)) {
        send_to_char("There's no room to do that behind the cover.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_MARTIAL, 4)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_MARTIAL, 4);

      act("You twist $N around to be a bodyshield.", ch, NULL, victim, TO_CHAR);
      act("$n twists you around to be a bodyshield.", ch, NULL, victim, TO_VICT);
      act("$n twists $N around to be a bodyshield.", ch, NULL, victim, TO_NOTVICT);
      if (battleground(ch->in_room))
      op_report(logact("$n twists $N around to be a bodyshield.", ch, victim), ch);

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_MARTIAL) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_MARTIAL) / 2;
      if (!IS_NPC(victim))
      victim->pcdata->protecting = ch;
      usemove(ch);
      nomove(victim);
    }
    else if (!str_cmp(arg1, "throw")) {
      if (get_skill(ch, SKILL_MARTIAL) < 3) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_MARTIAL, 5)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_MARTIAL, 5);

      act("You get ready to throw someone.", ch, NULL, victim, TO_CHAR);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_MARTIAL) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_MARTIAL) / 2;
      if (ch->fight_fast == TRUE)
      apply_caff(ch, CAFF_THROWING, 1);
      else
      apply_caff(ch, CAFF_THROWING, 2);

    }
    else if (!str_cmp(arg1, "suppressor")) {
      if (get_skill(ch, SKILL_SOLDIER) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (IS_FLAG(ch->fightflag, FIGHT_SUPPRESSOR)) {
        act("You remove your silencer.", ch, NULL, victim, TO_CHAR);
        REMOVE_FLAG(ch->fightflag, FIGHT_SUPPRESSOR);
      }
      else {
        act("You attach a silencer to your weapon.", ch, NULL, victim, TO_CHAR);
        SET_FLAG(ch->fightflag, FIGHT_SUPPRESSOR);
      }
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * fight_speed(ch) *
      ability_cooldown(ch, SKILL_SOLDIER) / 2;
      else
      ch->ability_timer += FIGHT_WAIT * ability_cooldown(ch, SKILL_SOLDIER) / 2;
      usemove(ch);
    }
    else if (!str_cmp(arg1, "bipod")) {
      if (get_skill(ch, SKILL_SOLDIER) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }

      if (IS_FLAG(ch->fightflag, FIGHT_BIPOD)) {
        act("You pack up your bipod.", ch, NULL, NULL, TO_CHAR);
        act("$n packs up $s bipod.", ch, NULL, NULL, TO_ROOM);
        REMOVE_FLAG(ch->fightflag, FIGHT_BIPOD);
        useattack(ch);

      }
      else {
        act("You deploy a bipod for your weapon.", ch, NULL, NULL, TO_CHAR);
        act("$n deploys a bipod for $s weapon.", ch, NULL, NULL, TO_ROOM);
        SET_FLAG(ch->fightflag, FIGHT_BIPOD);
        usemove(ch);
        useattack(ch);
      }
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * fight_speed(ch) *
      ability_cooldown(ch, SKILL_SOLDIER) / 2;
      else
      ch->ability_timer += FIGHT_WAIT * ability_cooldown(ch, SKILL_SOLDIER) / 2;
    }
    else if (!str_cmp(arg1, "laserdesignate")) {
      if (get_skill(ch, SKILL_SOLDIER) < 3) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (no_tech(ch)) {
        send_to_char("It doesn't work for some reason.\n\r", ch);
        return;
      }

      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (combat_distance(ch, victim, TRUE) > 150) {
        send_to_char("They're too far away.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }

      if (abilcool(ch, SKILL_SOLDIER, 3)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_SOLDIER, 3);

      act("You lay a laser target on $N.", ch, NULL, victim, TO_CHAR);
      act("A red dot appears on you.", ch, NULL, victim, TO_VICT);
      act("A red dot appears on $N.", ch, NULL, victim, TO_NOTVICT);
      if (battleground(ch->in_room))
      op_report(logact("A red dot appears on $N", ch, victim), ch);

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_SOLDIER) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_SOLDIER) / 2;
      useattack(ch);
      apply_caff(victim, CAFF_LASERED, 1);
    }
    else if (!str_cmp(arg1, "suppressingfire")) {
      if (get_skill(ch, SKILL_SOLDIER) < 3) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (combat_distance(ch, victim, TRUE) > 100) {
        send_to_char("They're too far away.\n\r", ch);
        return;
      }
      if (!IS_FLAG(victim->act, ACT_COVER) && !IS_FLAG(victim->act, ACT_TURRET)) {
        send_to_char("They should be targeted at cover.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_SOLDIER, 5)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_SOLDIER, 5);

      act("You lay down suppressing fire on $N.", ch, NULL, victim, TO_CHAR);
      act("$n starts to spray $N with suppressing fire.", ch, NULL, victim, TO_ROOM);
      if (battleground(ch->in_room))
      op_report(
      logact("$n starts to spray $N with suppressing fire.", ch, victim), ch);

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_SOLDIER) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_SOLDIER) / 2;
      useattack(ch);
      apply_caff(victim, CAFF_SUPPRESSED, 1);
    }
    else if (!str_cmp(arg1, "caltrops")) {
      if (get_skill(ch, SKILL_COMMANDO) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (!has_consume(ch, ITEM_CALTROPS)) {
        send_to_char("You don't have that item.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }

      if (abilcool(ch, SKILL_COMMANDO, 1)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_COMMANDO, 1);

      apply_caff(ch, CAFF_CALTROPING, 2);

      act("You prepare to lay down caltrops.", ch, NULL, victim, TO_CHAR);
      act("$n readies some caltrops.", ch, NULL, NULL, TO_ROOM);
      if (battleground(ch->in_room))
      op_report(logact("$n readies some caltrops.", ch, NULL), ch);

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_COMMANDO) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_COMMANDO) / 2;
      useattack(ch);
    }
    else if (!str_cmp(arg1, "landmine")) {
      if (get_skill(ch, SKILL_COMMANDO) < 3) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (no_tech(ch)) {
        send_to_char("It doesn't work for some reason.\n\r", ch);
        return;
      }

      if (!has_consume(ch, ITEM_LANDMINE)) {
        send_to_char("You don't have that item.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_COMMANDO, 3)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_COMMANDO, 3);

      apply_caff(ch, CAFF_LANDMINING, 2);

      act("You prepare to plant a landmine.", ch, NULL, victim, TO_CHAR);
      act("$n prepares a landmine.", ch, NULL, NULL, TO_ROOM);
      if (battleground(ch->in_room))
      op_report(logact("$n prepares a landmine.", ch, NULL), ch);

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_COMMANDO) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_COMMANDO) / 2;
      useattack(ch);
    }
    else if (!str_cmp(arg1, "bola")) {
      if (get_skill(ch, SKILL_COMMANDO) < 3) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (combat_distance(ch, victim, TRUE) > 30) {
        send_to_char("They're too far away.\n\r", ch);
        return;
      }
      if (!has_consume(ch, ITEM_BOLA)) {
        send_to_char("You need to have a bola first.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_COMMANDO, 4)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_COMMANDO, 4);

      act("You hurl a bola at $N's legs.", ch, NULL, victim, TO_CHAR);
      act("$n hurls a bola at your legs.", ch, NULL, victim, TO_VICT);
      act("$n hurls a bola at $N's legs.", ch, NULL, victim, TO_NOTVICT);
      if (battleground(ch->in_room))
      op_report(logact("$n hurls a bola at $N's legs.", ch, victim), ch);

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_COMMANDO) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_COMMANDO) / 2;
      nomove(victim);
    }
    else if (!str_cmp(arg1, "deadswitch")) {
      if (get_skill(ch, SKILL_COMMANDO) < 3) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (no_tech(ch)) {
        send_to_char("It doesn't work for some reason.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_COMMANDO, 5)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_COMMANDO, 5);

      if (IS_FLAG(ch->fightflag, FIGHT_DEADSWITCH)) {
        act("You turn off your deadswitch.", ch, NULL, victim, TO_CHAR);
        REMOVE_FLAG(ch->fightflag, FIGHT_BIPOD);
      }
      else {
        act("You turn on your deadswitch.", ch, NULL, victim, TO_CHAR);
        SET_FLAG(ch->fightflag, FIGHT_DEADSWITCH);
      }
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_COMMANDO) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_COMMANDO) / 2;
    }
    else if (!str_cmp(arg1, "gasmask")) {
      if (get_skill(ch, SKILL_RIOT) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (!has_nonconsume(ch, ITEM_GASMASK)) {
        send_to_char("You don't have a gas mask.\n\r", ch);
        return;
      }
      if (IS_FLAG(ch->fightflag, FIGHT_GASMASK)) {
        act("You take off your gas mask", ch, NULL, victim, TO_CHAR);
        act("$n takes off $s gas mask.", ch, NULL, victim, TO_ROOM);
        REMOVE_FLAG(ch->fightflag, FIGHT_GASMASK);
      }
      else {
        act("You put on your gas mask.", ch, NULL, victim, TO_CHAR);
        act("$n puts on $s gas mask.", ch, NULL, victim, TO_ROOM);
        SET_FLAG(ch->fightflag, FIGHT_GASMASK);
        usemove(ch);
      }
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * fight_speed(ch);
      else
      ch->ability_timer += FIGHT_WAIT;
    }
    else if (!str_cmp(arg1, "smokegrenade")) {
      if (get_skill(ch, SKILL_RIOT) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (!has_consume(ch, ITEM_SMOKEGRENADE)) {
        send_to_char("You don't have a smoke grenade.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_RIOT, 2)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_RIOT, 2);
      act("You throw a smoke grenade down at your feet.", ch, NULL, NULL, TO_CHAR);
      act("$n throws a smoke grenade down at $s feet.", ch, NULL, NULL, TO_ROOM);
      if (battleground(ch->in_room))
      op_report(logact("$n throws a smoke grenade down at $s feet.", ch, NULL), ch);

      if (!has_caff(ch, CAFF_GUST)) {
        summon_cobj(ch->in_room, COBJ_SMOKE, 1, ch->x, ch->y, ch);
      }
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_RIOT) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_RIOT) / 2;
    }
    else if (!str_cmp(arg1, "teargas")) {
      if (get_skill(ch, SKILL_RIOT) < 3) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (combat_distance(ch, victim, TRUE) > 80) {
        send_to_char("They're too far away.\n\r", ch);
        return;
      }
      if (combat_distance(ch, victim, TRUE) > 40 && (get_skill(ch, SKILL_RIOT) < 3 || (get_disc(ch, DIS_RIFLES, FALSE) < 20 && get_disc(ch, DIS_CARBINES, FALSE) < 20 && get_disc(ch, DIS_SHOTGUNS, FALSE) < 20) || (!has_lgun(ch) && !holding_lgun(ch)))) {
        send_to_char("They're too far away.\n\r", ch);
        return;
      }
      if (!has_consume(ch, ITEM_TEARGRENADE)) {
        send_to_char("You need to have a tear gas grenade first.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_RIOT, 3)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_RIOT, 3);

      if (combat_distance(ch, victim, TRUE) > 40) {
        act("You launch a tear gas grenade at $N.", ch, NULL, victim, TO_CHAR);
        act("$n launches a tear gas grenade at you.", ch, NULL, victim, TO_VICT);
        act("$n launches a tear gas grenade at $N.", ch, NULL, victim, TO_NOTVICT);
        if (battleground(ch->in_room))
        op_report(logact("$n launches a tear gas grenade at $N.", ch, victim), ch);

      }
      else {
        act("You throws a tear gas grenade at $N.", ch, NULL, victim, TO_CHAR);
        act("$n throws a tear gas grenade at you.", ch, NULL, victim, TO_VICT);
        act("$n throws a tear gas grenade at $N.", ch, NULL, victim, TO_NOTVICT);
        if (battleground(ch->in_room))
        op_report(logact("$n throws a tear gas grenade at $N.", ch, victim), ch);
      }
      if (!has_caff(ch, CAFF_GUST)) {
        CHAR_DATA *newvict;
        for (CharList::iterator it = victim->in_room->people->begin();
        it != victim->in_room->people->end(); ++it) {
          newvict = *it;

          if (newvict == NULL)
          continue;

          if (newvict->in_room == NULL)
          continue;

          if (IS_FLAG(newvict->act, ACT_COMBATOBJ))
          continue;

          if (get_dist(newvict->x, newvict->y, victim->x, victim->y) > 12)
          continue;

          if (!has_gasmask(newvict) && !is_undead(newvict)) {
            apply_caff(newvict, CAFF_TEAR, 1);
            act("You breathe in a lungful of teargas.", newvict, NULL, NULL, TO_CHAR);
          }
        }

        if (IS_SET(ch->in_room->room_flags, ROOM_INDOORS))
        summon_cobj(victim->in_room, COBJ_TEAR, 3, victim->x, victim->y, ch);
        else
        summon_cobj(victim->in_room, COBJ_TEAR, 1, victim->x, victim->y, ch);
      }
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_RIOT) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_RIOT) / 2;
    }
    else if (!str_cmp(arg1, "fraggrenade")) {
      if (get_skill(ch, SKILL_RIOT) < 3) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (combat_distance(ch, victim, TRUE) > 80) {
        send_to_char("They're too far away.\n\r", ch);
        return;
      }
      if (combat_distance(ch, victim, TRUE) > 40 && (get_skill(ch, SKILL_RIOT) < 3 || (get_disc(ch, DIS_RIFLES, FALSE) < 20 && get_disc(ch, DIS_CARBINES, FALSE) < 20 && get_disc(ch, DIS_SHOTGUNS, FALSE) < 20) || (!has_lgun(ch) && !holding_lgun(ch)))) {
        send_to_char("They're too far away.\n\r", ch);
        return;
      }
      if (!has_consume(ch, ITEM_FRAGGRENADE)) {
        send_to_char("You need to have a frag grenade first.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_RIOT, 5)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_RIOT, 5);

      if (combat_distance(ch, victim, TRUE) > 40) {
        act("You launch a grenade at $N.", ch, NULL, victim, TO_CHAR);
        act("$n launches a grenade at you.", ch, NULL, victim, TO_VICT);
        act("$n launches a grenade at $N.", ch, NULL, victim, TO_NOTVICT);
        if (battleground(ch->in_room))
        op_report(logact("$n launches a grenade at $N.", ch, victim), ch);

      }
      else {
        act("You throw a grenade at $N.", ch, NULL, victim, TO_CHAR);
        act("$n throws a grenade at you.", ch, NULL, victim, TO_VICT);
        act("$n throws a grenade at $N.", ch, NULL, victim, TO_NOTVICT);
        if (battleground(ch->in_room))
        op_report(logact("$n throws a grenade at $N.", ch, victim), ch);
      }

      summon_cobj(victim->in_room, COBJ_FRAG, 1, victim->x, victim->y, ch);

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_RIOT) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_RIOT) / 2;
    }
    else if (!str_cmp(arg1, "root")) {
      if (get_skill(ch, SKILL_NATURE) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (!is_natural(ch->in_room)) {
        send_to_char("You can only do that in natural areas.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_NATURE, 1)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_NATURE, 1);

      mult = debuff_multiplier(ch, victim);
      act("You grow a root around $N's ankles.", ch, NULL, victim, TO_CHAR);
      act("A root grows suddenly around your ankles.", ch, NULL, victim, TO_VICT);
      act("A root grows suddenly around $N's ankles.", ch, NULL, victim, TO_NOTVICT);
      if (battleground(ch->in_room))
      op_report(
      logact("A root grows suddenly around $N's ankles.", ch, victim), ch);

      apply_caff(victim, CAFF_ROOT, mult / 100);
      useattack(ch);

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_NATURE) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_NATURE) / 2;
    }
    else if (!str_cmp(arg1, "quicksand")) {
      if (get_skill(ch, SKILL_NATURE) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (!is_natural(ch->in_room)) {
        send_to_char("You can only do that in natural areas.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_NATURE, 2)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_NATURE, 2);

      mult = debuff_multiplier(ch, victim);
      act("You turn the topsoil around $N to quicksand.", ch, NULL, victim, TO_CHAR);
      act("The topsoil around you turns to quicksand.", ch, NULL, victim, TO_VICT);
      act("The topsoil around $N turns to quicksand.", ch, NULL, victim, TO_NOTVICT);

      if (battleground(ch->in_room))
      op_report(
      logact("The topsoil around $N turns to quicksand.", ch, victim), ch);

      summon_cobj(victim->in_room, COBJ_QUICKSAND, 2 * mult / 100, victim->x, victim->y, ch);
      useattack(ch);

      CHAR_DATA *newvict;
      for (CharList::iterator it = victim->in_room->people->begin();
      it != victim->in_room->people->end(); ++it) {
        newvict = *it;

        if (newvict == NULL)
        continue;

        if (newvict->in_room == NULL)
        continue;

        if (IS_FLAG(newvict->act, ACT_COMBATOBJ))
        continue;

        if (get_dist(newvict->x, newvict->y, victim->x, victim->y) > 10)
        continue;

        apply_caff(newvict, CAFF_SLOW, 1);
      }

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_NATURE) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_NATURE) / 2;
    }
    else if (!str_cmp(arg1, "rapidgrowth")) {
      if (get_skill(ch, SKILL_NATURE) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (!is_natural(ch->in_room)) {
        send_to_char("You can only do that in natural areas.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_NATURE, 3)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_NATURE, 3);
      act("You start to rapidly grow the underbrush around you.", ch, NULL, victim, TO_CHAR);
      act("The underbrush around $n starts to rapidly grow.", ch, NULL, victim, TO_ROOM);
      if (battleground(ch->in_room))
      op_report(logact("The underbrush around $n starts to rapidly grow.", ch, victim), ch);
      useattack(ch);
      mult = buff_multiplier(ch, victim);
      if (mult > 0) {
        MOB_INDEX_DATA *pMobIndex;
        CHAR_DATA *mob;

        pMobIndex = get_mob_index(110);
        mob = create_mobile(pMobIndex);
        char_to_room(mob, victim->in_room);
        mob->hit = mult / 20;
        mob->short_descr = str_dup("underbrush");
        free_string(mob->name);
        mob->name = str_dup("underbrush");
        free_string(mob->long_descr);
        mob->long_descr = str_dup("some underbrush");
        mob->in_fight = TRUE;
        mob->fight_speed = ch->fight_speed;

        if (IS_FLAG(ch->act, PLR_SHROUD))
        SET_FLAG(mob->act, PLR_SHROUD);
        if (IS_FLAG(ch->act, PLR_DEEPSHROUD))
        SET_FLAG(mob->act, PLR_DEEPSHROUD);

        mob->x = victim->x;
        mob->y = victim->y;
      }
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_NATURE) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_NATURE) / 2;
    }
    else if (!str_cmp(arg1, "tremor")) {
      if (get_skill(ch, SKILL_NATURE) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (!is_natural(ch->in_room)) {
        send_to_char("You can only do that in natural areas.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }

      if (abilcool(ch, SKILL_NATURE, 4)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_NATURE, 4);

      act("You cause a tremor.", ch, NULL, victim, TO_CHAR);
      act("The ground shakes under your feet.", ch, NULL, NULL, TO_ROOM);
      if (battleground(ch->in_room))
      op_report("The ground shakes.", NULL);

      useattack(ch);

      CHAR_DATA *newvict;
      for (CharList::iterator it = char_list.begin(); it != char_list.end();
      ++it) {
        newvict = *it;

        if (newvict == NULL || is_gm(newvict))
        continue;
        if (!same_fight(newvict, ch))
        continue;

        if (IS_FLAG(newvict->act, ACT_COMBATOBJ))
        continue;

        mult = debuff_multiplier(ch, newvict);

        apply_caff(newvict, CAFF_SLOW, 1 * mult / 100);
      }

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_NATURE) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_NATURE) / 2;
    }
    else if (!str_cmp(arg1, "commandbeast")) {
      if (get_skill(ch, SKILL_NATURE) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_NATURE, 5)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_NATURE, 5);

      mult = debuff_multiplier(ch, victim);
      if (is_animal(victim) || victim->shape != SHAPE_HUMAN || is_npcanimal(victim)) {
        apply_caff(victim, CAFF_STUNNED, mult / 100);
        act("You stun $N.", ch, NULL, victim, TO_CHAR);
        act("You are stunned.", ch, NULL, victim, TO_VICT);
        act("$N seems suddenly dazed.", ch, NULL, victim, TO_NOTVICT);
        if (battleground(ch->in_room))
        op_report(logact("$N seems suddenly dazed", ch, victim), ch);

      }
      else
      act("It seems ineffective.", ch, NULL, victim, TO_CHAR);

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_NATURE) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_NATURE) / 2;
    }
    else if (!str_cmp(arg1, "bewilder")) {
      if (get_skill(ch, SKILL_PSYCHIC) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      useabil(ch, SKILL_PSYCHIC, 1);
      act("You bewilder $N.", ch, NULL, victim, TO_CHAR);
      if (!mindwarded(victim)) {
        act("You start to feel off.", ch, NULL, victim, TO_VICT);
        apply_caff(victim, CAFF_BEWILDER, 1);
      }
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_PSYCHIC) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_PSYCHIC) / 2;
    }
    else if (!str_cmp(arg1, "confuse")) {
      if (get_skill(ch, SKILL_PSYCHIC) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_PSYCHIC, 2)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_PSYCHIC, 2);
      useattack(ch);
      act("You confuse $N.", ch, NULL, victim, TO_CHAR);
      if (!mindwarded(victim)) {
        act("You start to feel off.", ch, NULL, victim, TO_VICT);
        apply_caff(victim, CAFF_CONFUSE, 1);
      }

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_PSYCHIC) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_PSYCHIC) / 2;
    }
    else if (!str_cmp(arg1, "doubt")) {
      if (get_skill(ch, SKILL_PSYCHIC) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_PSYCHIC, 3)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_PSYCHIC, 3);
      act("You induce doubt in $N.", ch, NULL, victim, TO_CHAR);
      if (!mindwarded(victim)) {
        act("You start to feel off.", ch, NULL, victim, TO_VICT);
        act("$N starts to look a little more unsure of $Mself.", ch, NULL, victim, TO_NOTVICT);
        if (battleground(ch->in_room))
        op_report(logact("$N starts to look a little more unsure of $Mself.", ch, victim), ch);
        apply_caff(victim, CAFF_SEMIWEAKEN, 1);
      }
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_PSYCHIC) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_PSYCHIC) / 2;
    }
    else if (!str_cmp(arg1, "stasis")) {
      if (get_skill(ch, SKILL_PSYCHIC) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_PSYCHIC, 4)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_PSYCHIC, 4);

      act("You put $N in stasis.", ch, NULL, victim, TO_CHAR);
      if (!mindwarded(victim)) {
        nomove(victim);
        noattack(victim);
        apply_caff(victim, CAFF_STASIS, 1);
        act("$N suddenly freezes in place.", ch, NULL, victim, TO_NOTVICT);
        if (battleground(ch->in_room))
        op_report(logact("$N suddenly freezes in place.", ch, victim), ch);
      }
      useattack(ch);
      usemove(ch);

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_PSYCHIC) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_PSYCHIC) / 2;
    }
    else if (!str_cmp(arg1, "fear")) {
      if (get_skill(ch, SKILL_PSYCHIC) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_PSYCHIC, 5)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_PSYCHIC, 5);
      act("You induce fear in $N.", ch, NULL, victim, TO_CHAR);
      if (!mindwarded(victim)) {
        apply_caff(victim, CAFF_FEAR, 1);
        act("You start to feel nervous.", ch, NULL, victim, TO_VICT);
        act("$N starts to look nervous.", ch, NULL, victim, TO_NOTVICT);
        victim->afraid_of = ch;
      }
      useattack(ch);
      usemove(ch);

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_PSYCHIC) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_PSYCHIC) / 2;
    }
    else if (!str_cmp(arg1, "distract")) {
      if (get_skill(ch, SKILL_COMBAT_ILLUSIONS) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_COMBAT_ILLUSIONS, 1)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_COMBAT_ILLUSIONS, 1);
      act("You distract $N.", ch, NULL, victim, TO_CHAR);
      act("$n's shape blurs slightly.", ch, NULL, victim, TO_ROOM);
      mult = debuff_multiplier(ch, victim);
      if (!mindwarded(victim)) {
        apply_caff(victim, CAFF_WEAKEN, 1 * mult / 100);
        act("Something irritating flashes out of the corner of your eye.", ch, NULL, victim, TO_VICT);
        act("$N starts to look a little distracted.", ch, NULL, victim, TO_NOTVICT);
      }

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_COMBAT_ILLUSIONS) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_COMBAT_ILLUSIONS) / 2;
    }
    else if (!str_cmp(arg1, "double")) {
      if (get_skill(ch, SKILL_COMBAT_ILLUSIONS) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      CHAR_DATA *target;
      if ((target = get_char_fight(ch, argument)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (target == victim) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_COMBAT_ILLUSIONS, 2)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_COMBAT_ILLUSIONS, 2);

      printf_to_char(ch, "You double %s with %s.\n\r", PERS(victim, ch), PERS_2(target, ch));
      act("$n's shape blurs slightly.", ch, NULL, victim, TO_ROOM);
      useattack(ch);
      mult = debuff_multiplier(ch, victim);
      int offmult = debuff_multiplier(ch, target);

      if (ch->fight_fast == TRUE) {
        apply_caff(victim, CAFF_MIMIC, 1 * mult / 100);
        victim->mimic = target;
        apply_caff(target, CAFF_MIMIC, 1 * offmult / 100);
        target->mimic = victim;
      }
      else {
        if (victim == ch) {
          apply_caff(victim, CAFF_MIMIC, 1 + 1 * mult / 100);
          victim->mimic = target;
        }
        else {
          apply_caff(victim, CAFF_MIMIC, 1 * mult / 100);
          victim->mimic = target;
        }
        if (target == ch) {
          apply_caff(target, CAFF_MIMIC, 1 + 1 * mult / 100);
          target->mimic = victim;
        }
        else {
          apply_caff(target, CAFF_MIMIC, 1 * mult / 100);
          target->mimic = victim;
        }
      }

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_COMBAT_ILLUSIONS) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_COMBAT_ILLUSIONS) / 2;
    }
    else if (!str_cmp(arg1, "cloak")) {
      if (get_skill(ch, SKILL_COMBAT_ILLUSIONS) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      CHAR_DATA *target;
      if ((target = get_char_fight(ch, argument)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (target == victim) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_COMBAT_ILLUSIONS, 3)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_COMBAT_ILLUSIONS, 3);

      printf_to_char(ch, "You cloak %s from %s.\n\r", PERS(victim, ch), PERS_2(target, ch));
      act("$n's shape blurs.", victim, NULL, target, TO_CHAR);
      mult = debuff_multiplier(ch, target);
      if (!mindwarded(target)) {
        apply_caff(target, CAFF_CLOAKBLIND, 1 * mult / 100);
        target->cloaked = victim;
      }
      useattack(ch);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_COMBAT_ILLUSIONS) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_COMBAT_ILLUSIONS) / 2;
    }
    else if (!str_cmp(arg1, "aura")) {
      if (get_skill(ch, SKILL_COMBAT_ILLUSIONS) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_COMBAT_ILLUSIONS, 4)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_COMBAT_ILLUSIONS, 4);

      mult = debuff_multiplier(ch, victim);
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }

      act("You place an aura on $N.", ch, NULL, victim, TO_CHAR);
      act("$n's shape blurs slightly.", ch, NULL, victim, TO_ROOM);
      act("$N starts to glow slightly.", ch, NULL, victim, TO_NOTVICT);
      if (battleground(ch->in_room))
      op_report(logact("$N starts to glow slightly.", ch, victim), ch);

      apply_caff(victim, CAFF_AURA, 1 * mult / 100);
      useattack(ch);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_COMBAT_ILLUSIONS) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_COMBAT_ILLUSIONS) / 2;
    }
    else if (!str_cmp(arg1, "trick")) {
      if (get_skill(ch, SKILL_COMBAT_ILLUSIONS) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_COMBAT_ILLUSIONS, 5)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_COMBAT_ILLUSIONS, 5);

      act("You cast a trick glamour on $N.", ch, NULL, victim, TO_CHAR);
      act("$n's shape blurs slightly.", ch, NULL, NULL, TO_ROOM);
      mult = buff_multiplier(ch, victim);

      if (!mindwarded(victim)) {
        if (ch == victim && ch->fight_fast == FALSE)
        apply_caff(victim, CAFF_TRICKING, 1 + mult / 100);
        else
        apply_caff(victim, CAFF_TRICKING, mult / 100);
      }

      useattack(ch);

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_COMBAT_ILLUSIONS) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_COMBAT_ILLUSIONS) / 2;
    }
    else if (!str_cmp(arg1, "burstvessel")) {
      if (get_skill(ch, SKILL_HAEMOMANCY) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_HAEMOMANCY, 1)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_HAEMOMANCY, 1);
      mult = debuff_multiplier(ch, victim);
      act("You burst the vessels in their eyes.", ch, NULL, victim, TO_CHAR);
      act("You feel a brief pain in your eyes and then everything goes red.", ch, NULL, victim, TO_VICT);
      act("$N's eyes suddenly look bloodshot.", ch, NULL, victim, TO_NOTVICT);
      if (battleground(ch->in_room))
      op_report(logact("$N's eyes suddenly look bloodshot.", ch, victim), ch);

      apply_caff(victim, CAFF_BLIND, 1 * mult / 100);
      useattack(ch);
      AFFECT_DATA af;
      af.where = TO_AFFECTS;
      af.type = 0;
      af.level = 10;
      af.duration = 12 * 60;
      af.location = APPLY_NONE;
      af.modifier = 0;
      af.caster = NULL;
      af.weave = FALSE;
      af.bitvector = AFF_BURSTVESSEL;
      affect_to_char(victim, &af);

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_HAEMOMANCY) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_HAEMOMANCY) / 2;
    }
    else if (!str_cmp(arg1, "slowheart")) {
      if (get_skill(ch, SKILL_HAEMOMANCY) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_HAEMOMANCY, 2)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_HAEMOMANCY, 2);
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      mult = debuff_multiplier(ch, victim);
      if (!is_undead(victim)) {
        act("You feel your heart slow, and a weakness comes over you.", ch, NULL, victim, TO_VICT);
        apply_caff(victim, CAFF_HEARTSLOW, 1 * mult / 100);
        act("$N starts to move a bit slower.", ch, NULL, victim, TO_NOTVICT);
        if (battleground(ch->in_room))
        op_report(logact("$N starts to move a bit slower.", ch, victim), ch);
      }
      act("You slow $S heart.", ch, NULL, victim, TO_CHAR);
      useattack(ch);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_HAEMOMANCY) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_HAEMOMANCY) / 2;
    }
    else if (!str_cmp(arg1, "declot")) {
      if (get_skill(ch, SKILL_HAEMOMANCY) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_HAEMOMANCY, 3)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_HAEMOMANCY, 3);
      mult = debuff_multiplier(ch, victim);
      if (!is_undead(victim)) {
        act("You feel strange.", ch, NULL, victim, TO_VICT);
        act("$N's wounds seem to be bleeding a bit more freely all of a sudden.", ch, NULL, victim, TO_NOTVICT);
        if (battleground(ch->in_room))
        op_report(logact("$N's wounds seem to be bleeding a bit more freely all of a sudden.", ch, victim), ch);
        apply_caff(victim, CAFF_DECLOT, 1 * mult / 100);
      }
      act("You declot $S blood.", ch, NULL, victim, TO_CHAR);
      useattack(ch);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_HAEMOMANCY) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_HAEMOMANCY) / 2;
    }
    else if (!str_cmp(arg1, "heartattack")) {
      if (get_skill(ch, SKILL_HAEMOMANCY) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (under_understanding(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }
      if (victim->hit > 0) {
        send_to_char("They're not hurt enough.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_HAEMOMANCY, 4)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_HAEMOMANCY, 4);
      if (!is_undead(victim)) {
        act("You give them a heart attack.", ch, NULL, victim, TO_CHAR);
        act("You feel a sudden pain in your left arm.", ch, NULL, victim, TO_VICT);
        victim->wounds = 3;
        damage(victim, ch, 10);
      }
      else
      act("It doesn't seem to work.", ch, NULL, victim, TO_CHAR);
      useattack(ch);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_HAEMOMANCY) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_HAEMOMANCY) / 2;
    }
    else if (!str_cmp(arg1, "bleed")) {
      if (get_skill(ch, SKILL_HAEMOMANCY) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_HAEMOMANCY, 5)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_HAEMOMANCY, 5);

      int dam = max_hp(victim) - victim->hit;
      mult = debuff_multiplier(ch, victim);
      if (!is_undead(victim) && dam > 0) {
        act("Your wounds suddenly spurt blood.", ch, NULL, victim, TO_VICT);
        act("You make $s wounds spurt blood.", ch, NULL, victim, TO_CHAR);
        act("$N's wounds suddenly spurt blood.", ch, NULL, victim, TO_NOTVICT);
        if (battleground(ch->in_room))
        op_report(logact("$N's wounds suddenly spurt blood.", ch, victim), ch);

        combat_damage(victim, ch, mult * dam / 1000, DIS_DARK);
      }
      else
      act("It doesn't seem to work.", ch, NULL, victim, TO_CHAR);
      useattack(ch);

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_HAEMOMANCY) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_HAEMOMANCY) / 2;
    }
    else if (!str_cmp(arg1, "push")) {
      if (get_skill(ch, SKILL_TELEKINESIS) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_TELEKINESIS, 1)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_TELEKINESIS, 1);

      if (is_in_cover(victim) && invisioncone_character(victim, ch)) {
        act("You telekinetically shove $N into their cover.", ch, NULL, victim, TO_CHAR);
        act("You are pushed into your cover by an invisible force.", ch, NULL, victim, TO_VICT);
        apply_caff(victim, CAFF_WEAKEN, 1);
      }
      else {
        act("You telekinetically push $N back.", ch, NULL, victim, TO_CHAR);
        act("You are pushed back by an invisible force.", ch, NULL, victim, TO_VICT);
        act("$N is pushed away by an invisible force.", ch, NULL, victim, TO_NOTVICT);
        if (battleground(ch->in_room))
        op_report(logact("$N is pushed away from $n by an invisible force.", ch, victim), ch);

        int face = victim->facing;
        if (!is_cover(victim))
        move_away(victim, relative_x(victim, ch->in_room, ch->x), relative_y(victim, ch->in_room, ch->y), 15, 0, FALSE);
        victim->facing = face;
      }

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_TELEKINESIS) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_TELEKINESIS) / 2;
    }
    else if (!str_cmp(arg1, "pull")) {
      if (get_skill(ch, SKILL_TELEKINESIS) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_TELEKINESIS, 2)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_TELEKINESIS, 2);

      if (is_in_cover(victim) && invisioncone_character(victim, ch)) {
        act("You telekinetically pull $N into their cover.", ch, NULL, victim, TO_CHAR);
        act("You are pulled into your cover by an invisible force.", ch, NULL, victim, TO_VICT);
        apply_caff(victim, CAFF_WEAKEN, 1);
      }
      else {
        act("You telekinetically pull $N in.", ch, NULL, victim, TO_CHAR);
        act("You are pulled forward by an invisible force.", ch, NULL, victim, TO_VICT);
        act("$N is pulled forward by an invisible force.", ch, NULL, victim, TO_NOTVICT);
        if (battleground(ch->in_room))
        op_report(logact("$N is pulled towards $n by an invisible force.", ch, victim), ch);

        if (!is_cover(victim))
        move_towards(victim, relative_x(victim, ch->in_room, ch->x), relative_y(victim, ch->in_room, ch->y), 15, ch->in_room->z - victim->in_room->z, FALSE);
      }
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_TELEKINESIS) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_TELEKINESIS) / 2;
    }
    else if (!str_cmp(arg1, "tklift")) {
      if (get_skill(ch, SKILL_TELEKINESIS) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_TELEKINESIS, 3)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_TELEKINESIS, 3);

      act("You telekinetically lift $N.", ch, NULL, victim, TO_CHAR);
      act("You are picked up by an invisible force.", ch, NULL, victim, TO_VICT);
      act("$N is picked up by an invisible force.", ch, NULL, victim, TO_NOTVICT);
      if (battleground(ch->in_room))
      op_report(logact("$N is picked up by an invisible force..", ch, victim), ch);

      nomove(victim);

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_TELEKINESIS) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_TELEKINESIS) / 2;
    }
    else if (!str_cmp(arg1, "tkthrow")) {
      if (get_skill(ch, SKILL_TELEKINESIS) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_TELEKINESIS, 4)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_TELEKINESIS, 4);
      act("You fling a nearby object into $N.", ch, NULL, victim, TO_CHAR);
      act("A nearby object suddenly flings itself into you.", ch, NULL, victim, TO_VICT);
      act("A nearby object suddenly flings itself into $N.", ch, NULL, victim, TO_NOTVICT);
      if (battleground(ch->in_room))
      op_report(logact("A nearby object suddenly flings itself into $N.", ch, victim), ch);
      victim->debuff += 20;
      combat_damage(victim, ch, 10, DIS_TELEKINESIS);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_TELEKINESIS) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_TELEKINESIS) / 2;
    }
    else if (!str_cmp(arg1, "tkjump")) {
      if (get_skill(ch, SKILL_TELEKINESIS) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_TELEKINESIS, 5)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_TELEKINESIS, 5);
      send_to_char("You prepare to propel yourself with telekinetic force.\n\r", ch);
      if (ch->fight_fast == FALSE)
      apply_caff(ch, CAFF_TKJUMP, 2);
      else
      apply_caff(ch, CAFF_TKJUMP, 1);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_TELEKINESIS) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_TELEKINESIS) / 2;
    }
    else if (!str_cmp(arg1, "fieryweapon")) {
      if (get_skill(ch, SKILL_ANGELCOMBAT) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_ANGELCOMBAT, 1)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_ANGELCOMBAT, 1);
      act("Your weapons start to glimmer with flame.", ch, NULL, NULL, TO_CHAR);
      act("$n's weapons start to glimmer with flame.", ch, NULL, NULL, TO_ROOM);
      if (battleground(ch->in_room))
      op_report(
      logact("$n's weapons start to glimmer with flame.", ch, victim), ch);
      if (ch->fight_fast == FALSE)
      apply_caff(ch, CAFF_FIREWEAPON, 2);
      else
      apply_caff(ch, CAFF_FIREWEAPON, 1);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_ANGELCOMBAT) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_ANGELCOMBAT) / 2;
    }
    else if (!str_cmp(arg1, "incandescence")) {
      if (get_skill(ch, SKILL_ANGELCOMBAT) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_ANGELCOMBAT, 2)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_ANGELCOMBAT, 2);
      act("You start to glow with a bright white light.", ch, NULL, NULL, TO_CHAR);
      act("$n starts to glow with a bright white light.", ch, NULL, NULL, TO_ROOM);
      if (battleground(ch->in_room))
      op_report(
      logact("$n starts to glow with a bright white light.", ch, victim), ch);
      if (ch->fight_fast == FALSE)
      apply_caff(ch, CAFF_GLOWING, 2);
      else
      apply_caff(ch, CAFF_GLOWING, 1);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_ANGELCOMBAT) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_ANGELCOMBAT) / 2;
    }
    else if (!str_cmp(arg1, "heataura")) {
      if (get_skill(ch, SKILL_ANGELCOMBAT) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_ANGELCOMBAT, 3)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_ANGELCOMBAT, 3);

      act("You start to radiate heat.", ch, NULL, NULL, TO_CHAR);
      act("$n starts to radiate heat.", ch, NULL, NULL, TO_ROOM);

      if (battleground(ch->in_room))
      op_report(logact("$n starts to radiate heat.", ch, victim), ch);
      CHAR_DATA *newvict;
      for (CharList::iterator it = char_list.begin(); it != char_list.end();
      ++it) {
        newvict = *it;

        if (newvict == NULL || is_gm(newvict))
        continue;
        if (!same_fight(newvict, ch))
        continue;

        if (newvict == ch)
        continue;

        if (IS_FLAG(newvict->act, ACT_COMBATOBJ))
        continue;

        if (combat_distance(ch, newvict, FALSE) <= 20) {
          if (has_caff(newvict, CAFF_CHILL)) {
            act("You warm back up.", ch, NULL, newvict, TO_VICT);
            remove_caff(newvict, CAFF_CHILL);
          }
          else if (!is_undead(newvict) && get_skill(newvict, SKILL_FIREPROOF) < 1) {
            act("You suddenly become uncomfortably warm.", ch, NULL, newvict, TO_VICT);
            act("$N starts to sweat.", ch, NULL, newvict, TO_NOTVICT);
            apply_caff(newvict, CAFF_SWEAT, 1);
          }
          if (has_caff(newvict, CAFF_DISCIPLINE))
          remove_caff(newvict, CAFF_DISCIPLINE);
        }
      }

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_ANGELCOMBAT) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_ANGELCOMBAT) / 2;
    }
    else if (!str_cmp(arg1, "lightfeet")) {
      if (get_skill(ch, SKILL_ANGELCOMBAT) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_ANGELCOMBAT, 4)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_ANGELCOMBAT, 4);
      act("You feel lighter on your feet.", ch, NULL, NULL, TO_CHAR);
      if (ch->fight_fast == FALSE)
      apply_caff(ch, CAFF_SPRINTING, 2);
      else
      apply_caff(ch, CAFF_SPRINTING, 1);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_ANGELCOMBAT) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_ANGELCOMBAT) / 2;
    }
    else if (!str_cmp(arg1, "burden")) {
      if (get_skill(ch, SKILL_ANGELCOMBAT) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_ANGELCOMBAT, 5)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_ANGELCOMBAT, 5);

      act("You lay heavy weight upon $N's shoulders.", ch, NULL, victim, TO_CHAR);
      act("You feel a heavy weight pressing down upon you.", ch, NULL, victim, TO_VICT);
      act("$N starts to slouch.", ch, NULL, victim, TO_NOTVICT);

      if (battleground(ch->in_room))
      op_report(logact("$N starts to slouch.", ch, victim), ch);

      apply_caff(victim, CAFF_GRAVITY, 1);

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_ANGELCOMBAT) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_ANGELCOMBAT) / 2;
    }
    else if (!str_cmp(arg1, "takedown")) {
      if (get_skill(ch, SKILL_PRIMALCOMBAT) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (combat_distance(ch, victim, TRUE) > 2) {
        send_to_char("They're too far away\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_PRIMALCOMBAT, 1)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_PRIMALCOMBAT, 1);
      act("You leap on $N and force $M to the ground.", ch, NULL, victim, TO_CHAR);
      act("$n leaps on you and forces you to the ground.", ch, NULL, victim, TO_VICT);
      act("$n leaps on $N and forces $M to the ground.", ch, NULL, victim, TO_NOTVICT);
      if (battleground(ch->in_room))
      op_report(
      logact("$n leaps on $N and forces $M to the ground.", ch, victim), ch);
      apply_caff(victim, CAFF_ROOT, 1);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_ANGELCOMBAT) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_ANGELCOMBAT) / 2;
    }
    else if (!str_cmp(arg1, "rush")) {
      if (get_skill(ch, SKILL_PRIMALCOMBAT) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_PRIMALCOMBAT, 2)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_PRIMALCOMBAT, 2);
      act("You prepare to rush at your prey.", ch, NULL, NULL, TO_CHAR);
      if (ch->fight_fast == FALSE)
      apply_caff(ch, CAFF_RUSH, 2);
      else
      apply_caff(ch, CAFF_RUSH, 1);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_ANGELCOMBAT) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_ANGELCOMBAT) / 2;
    }
    else if (!str_cmp(arg1, "prowl")) {
      if (get_skill(ch, SKILL_PRIMALCOMBAT) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_PRIMALCOMBAT, 3)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_PRIMALCOMBAT, 3);
      act("You lower your body closer to the ground and start to prowl.", ch, NULL, NULL, TO_CHAR);
      act("$n lowers $s body clower to the ground and starts to prowl.", ch, NULL, NULL, TO_ROOM);
      if (battleground(ch->in_room))
      op_report(
      logact("$n lowers $s body clower to the ground and starts to prowl.", ch, victim), ch);
      if (ch->fight_fast == FALSE)
      apply_caff(ch, CAFF_PROWL, 2);
      else
      apply_caff(ch, CAFF_PROWL, 1);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_ANGELCOMBAT) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_ANGELCOMBAT) / 2;
    }
    else if (!str_cmp(arg1, "ferocity")) {
      if (get_skill(ch, SKILL_PRIMALCOMBAT) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_PRIMALCOMBAT, 4)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_PRIMALCOMBAT, 4);
      act("You prepare yourself for a particularly vicious attack.", ch, NULL, NULL, TO_CHAR);
      if (ch->fight_fast == FALSE)
      apply_caff(ch, CAFF_ADRENALINE, 2);
      else
      apply_caff(ch, CAFF_ADRENALINE, 1);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_ANGELCOMBAT) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_ANGELCOMBAT) / 2;
    }
    else if (!str_cmp(arg1, "pounce")) {
      if (get_skill(ch, SKILL_PRIMALCOMBAT) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (combat_distance(ch, victim, TRUE) > get_speed(ch)) {
        send_to_char("They're too far away\n\r", ch);
        return;
      }

      if (abilcool(ch, SKILL_PRIMALCOMBAT, 5)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_PRIMALCOMBAT, 5);

      act("You leap at $N.", ch, NULL, victim, TO_CHAR);
      act("$n leaps at you.", ch, NULL, victim, TO_VICT);
      act("$n leaps at $N.", ch, NULL, victim, TO_NOTVICT);
      if (battleground(ch->in_room))
      op_report(logact("$n leaps at $N.", ch, victim), ch);

      move_towards(ch, relative_x(ch, victim->in_room, victim->x), relative_y(ch, victim->in_room, victim->y), get_speed(ch), victim->in_room->z - ch->in_room->z, FALSE);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) * ability_cooldown(ch, SKILL_ANGELCOMBAT) / 2;
      else
      ch->ability_timer += FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_ANGELCOMBAT) / 2;
    }
    else if (!str_cmp(arg1, "messengeraspect")) {
      if (get_skill(ch, SKILL_DAYASPECT) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_DAYASPECT, 1)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_DAYASPECT, 1);
      act("You take on the aspect of the messenger.", ch, NULL, NULL, TO_CHAR);
      if (IS_FLAG(ch->act, PLR_SHROUD)) {
        if (ch->pcdata->divine_focus == CAFF_AMESSENGER) {
          act("Golden wings appear on $n's ankles.", ch, NULL, NULL, TO_ROOM);
          act("Golden wings appear on $n's ankles.", ch, NULL, NULL, TO_CHAR);
        }
        else {
          act("Wings appear on $n's ankles.", ch, NULL, NULL, TO_ROOM);
          act("Wings appear on $n's ankles.", ch, NULL, NULL, TO_CHAR);
        }
        if (battleground(ch->in_room))
        op_report(logact("Wings appear on $n's ankles", ch, victim), ch);
      }
      if (ch->fight_fast == FALSE)
      apply_caff(ch, CAFF_AMESSENGER, 3);
      else
      apply_caff(ch, CAFF_AMESSENGER, 2);

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_DAYASPECT) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_DAYASPECT) / 2;
    }
    else if (!str_cmp(arg1, "sunaspect")) {
      if (get_skill(ch, SKILL_DAYASPECT) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_DAYASPECT, 2)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_DAYASPECT, 2);
      act("You take on the aspect of the sun.", ch, NULL, NULL, TO_CHAR);
      if (IS_FLAG(ch->act, PLR_SHROUD)) {
        if (ch->pcdata->divine_focus == CAFF_ASUN) {
          act("$n is bathed in golden sunlight.", ch, NULL, NULL, TO_ROOM);
          act("$n is bathed in golden sunlight.", ch, NULL, NULL, TO_CHAR);
        }
        else {
          act("$n is bathed in sunlight.", ch, NULL, NULL, TO_ROOM);
          act("$n is bathed in sunlight.", ch, NULL, NULL, TO_CHAR);
        }
        if (battleground(ch->in_room))
        op_report(logact("$n is bathed in sunlight.", ch, victim), ch);
      }
      act("$n starts to glow with an intense yellow light.", ch, NULL, NULL, TO_ROOM);

      if (ch->fight_fast == FALSE)
      apply_caff(ch, CAFF_ASUN, 3);
      else
      apply_caff(ch, CAFF_ASUN, 2);

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_DAYASPECT) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_DAYASPECT) / 2;
    }
    else if (!str_cmp(arg1, "warrioraspect")) {
      if (get_skill(ch, SKILL_DAYASPECT) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_DAYASPECT, 3)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_DAYASPECT, 3);
      act("You take on the aspect of the warrior.", ch, NULL, NULL, TO_CHAR);
      if (IS_FLAG(ch->act, PLR_SHROUD)) {
        if (ch->pcdata->divine_focus == CAFF_AWARRIOR) {
          act("A set of gleaming sheathed weapons appear on $n.", ch, NULL, NULL, TO_ROOM);
          act("A set of gleaming sheathed weapons appear on $n.", ch, NULL, NULL, TO_CHAR);
        }
        else {
          act("A sheathed broadsword appears on $n's hip.", ch, NULL, NULL, TO_ROOM);
          act("A sheathed broadsword appears on $n's hip.", ch, NULL, NULL, TO_CHAR);
        }
        if (battleground(ch->in_room))
        op_report(
        logact("A sheathed broadsword appears on $n's hip.", ch, victim), ch);
      }
      if (ch->fight_fast == FALSE)
      apply_caff(ch, CAFF_AWARRIOR, 3);
      else
      apply_caff(ch, CAFF_AWARRIOR, 2);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_DAYASPECT) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_DAYASPECT) / 2;
    }
    else if (!str_cmp(arg1, "smithaspect")) {
      if (get_skill(ch, SKILL_DAYASPECT) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_DAYASPECT, 4)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_DAYASPECT, 4);
      act("You take on the aspect of the smith.", ch, NULL, NULL, TO_CHAR);
      if (IS_FLAG(ch->act, PLR_SHROUD)) {
        if (ch->pcdata->divine_focus == CAFF_ASMITH) {
          act("A set of gleaming, spiked plate armor appears on $n.", ch, NULL, NULL, TO_ROOM);
          act("A set of gleaming, spiked plate armor appears on $n.", ch, NULL, NULL, TO_CHAR);
        }
        else {
          act("A set of plate armor appears on $n.", ch, NULL, NULL, TO_ROOM);
          act("A set of plate armor appears on $n.", ch, NULL, NULL, TO_CHAR);
        }
        if (battleground(ch->in_room))
        op_report(logact("A set of plate armor appears on $n.", ch, victim), ch);
      }

      if (ch->fight_fast == FALSE)
      apply_caff(ch, CAFF_ASMITH, 3);
      else
      apply_caff(ch, CAFF_ASMITH, 2);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_DAYASPECT) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_DAYASPECT) / 2;
    }
    else if (!str_cmp(arg1, "healeraspect")) {
      if (get_skill(ch, SKILL_DAYASPECT) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_DAYASPECT, 5)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_DAYASPECT, 5);
      act("You take on the aspect of the healer.", ch, NULL, NULL, TO_CHAR);
      if (IS_FLAG(ch->act, PLR_SHROUD)) {
        if (ch->pcdata->divine_focus == CAFF_AHEALER) {
          act("Golden, swaying wheat begins to spring up at $n's feet.", ch, NULL, NULL, TO_ROOM);
          act("Golden, swaying wheat begins to spring up at $n's feet.", ch, NULL, NULL, TO_CHAR);
        }
        else {
          act("Wheat begins to spring up at $n's feet.", ch, NULL, NULL, TO_ROOM);
          act("Wheat begins to spring up at $n's feet.", ch, NULL, NULL, TO_CHAR);
        }
        if (battleground(ch->in_room))
        op_report(
        logact("Wheat begins to spring up at $n's feet.", ch, victim), ch);
      }

      if (ch->fight_fast == FALSE)
      apply_caff(ch, CAFF_AHEALER, 3);
      else
      apply_caff(ch, CAFF_AHEALER, 2);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_DAYASPECT) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_DAYASPECT) / 2;
    }
    else if (!str_cmp(arg1, "underworldaspect")) {
      if (get_skill(ch, SKILL_NIGHTASPECT) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_NIGHTASPECT, 1)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_NIGHTASPECT, 1);
      act("You take on the aspect of the underworld.", ch, NULL, NULL, TO_CHAR);
      if (IS_FLAG(ch->act, PLR_SHROUD)) {
        if (ch->pcdata->divine_focus == CAFF_AUNDERWORLD) {
          act("Vicious, barbed armor of bone appears on $n.", ch, NULL, NULL, TO_ROOM);
          act("Vicious, barbed armor of bone appears on $n.", ch, NULL, NULL, TO_CHAR);
        }
        else {
          act("Bone armor appears on $n.", ch, NULL, NULL, TO_ROOM);
          act("Bone armor appears on $n.", ch, NULL, NULL, TO_CHAR);
        }
        if (battleground(ch->in_room))
        op_report(logact("Bone armor appears on $n.", ch, victim), ch);
      }

      if (ch->fight_fast == FALSE)
      apply_caff(ch, CAFF_AUNDERWORLD, 3);
      else
      apply_caff(ch, CAFF_AUNDERWORLD, 2);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_NIGHTASPECT) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_NIGHTASPECT) / 2;
    }
    else if (!str_cmp(arg1, "moonaspect")) {
      if (get_skill(ch, SKILL_NIGHTASPECT) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_NIGHTASPECT, 2)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_NIGHTASPECT, 2);
      act("You take on the aspect of the moon.", ch, NULL, NULL, TO_CHAR);
      if (IS_FLAG(ch->act, PLR_SHROUD)) {
        if (ch->pcdata->divine_focus == CAFF_AMOON) {
          act("$n is bathed in ghostly, pale moonlight.", ch, NULL, NULL, TO_ROOM);
          act("$n is bathed in ghostly, pale moonlight.", ch, NULL, NULL, TO_CHAR);
        }
        else {
          act("$n is bathed in moonlight.", ch, NULL, NULL, TO_ROOM);
          act("$n is bathed in moonlight.", ch, NULL, NULL, TO_CHAR);
        }
        if (battleground(ch->in_room))
        op_report(logact("$n is bathed in moonlight.", ch, victim), ch);
      }
      act("$n's body becomes endarkened and covered in shadows.", ch, NULL, NULL, TO_ROOM);

      if (ch->fight_fast == FALSE)
      apply_caff(ch, CAFF_AMOON, 3);
      else
      apply_caff(ch, CAFF_AMOON, 2);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_NIGHTASPECT) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_NIGHTASPECT) / 2;
    }
    else if (!str_cmp(arg1, "thunderaspect")) {
      if (get_skill(ch, SKILL_NIGHTASPECT) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_NIGHTASPECT, 3)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_NIGHTASPECT, 3);
      act("You take on the aspect of thunder.", ch, NULL, NULL, TO_CHAR);
      if (IS_FLAG(ch->act, PLR_SHROUD)) {
        if (ch->pcdata->divine_focus == CAFF_ATHUNDER) {
          act("Brilliant, vicious streaks of lightning crackle across $n's skin.", ch, NULL, NULL, TO_ROOM);
          act("Brilliant, vicious streaks of lightning crackle across $n's skin.", ch, NULL, NULL, TO_CHAR);
        }
        else {
          act("Lightning crackles across $n's skin.", ch, NULL, NULL, TO_ROOM);
          act("Lightning crackles across $n's skin.", ch, NULL, NULL, TO_CHAR);
        }
        if (battleground(ch->in_room))
        op_report(logact("Lightning crackles across $n's skin.", ch, victim), ch);
      }

      if (ch->fight_fast == FALSE)
      apply_caff(ch, CAFF_ATHUNDER, 3);
      else
      apply_caff(ch, CAFF_ATHUNDER, 2);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_NIGHTASPECT) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_NIGHTASPECT) / 2;
    }
    else if (!str_cmp(arg1, "windaspect")) {
      if (get_skill(ch, SKILL_NIGHTASPECT) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_NIGHTASPECT, 4)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_NIGHTASPECT, 4);
      act("You take on the aspect of wind.", ch, NULL, NULL, TO_CHAR);
      if (IS_FLAG(ch->act, PLR_SHROUD)) {
        if (ch->pcdata->divine_focus == CAFF_AWIND) {
          act("A furious gale buffets $n.", ch, NULL, NULL, TO_ROOM);
          act("A furious gale buffets $n.", ch, NULL, NULL, TO_CHAR);
        }
        else {
          act("A wind buffets $n.", ch, NULL, NULL, TO_ROOM);
          act("A wind buffets $n.", ch, NULL, NULL, TO_CHAR);
        }
        if (battleground(ch->in_room))
        op_report(logact("A wind buffets $n.", ch, victim), ch);
      }

      if (ch->fight_fast == FALSE)
      apply_caff(ch, CAFF_AWIND, 3);
      else
      apply_caff(ch, CAFF_AWIND, 2);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_NIGHTASPECT) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_NIGHTASPECT) / 2;
    }
    else if (!str_cmp(arg1, "hunteraspect")) {
      if (get_skill(ch, SKILL_NIGHTASPECT) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_NIGHTASPECT, 5)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_NIGHTASPECT, 5);
      act("You take on the aspect of the hunter.", ch, NULL, NULL, TO_CHAR);
      if (IS_FLAG(ch->act, PLR_SHROUD)) {
        if (ch->pcdata->divine_focus == CAFF_AHUNTER) {
          act("A magnificant bow, quiver of arrows and several braces of throwing knives appear on $n.", ch, NULL, NULL, TO_ROOM);
          act("A magnificant bow, quiver of arrows and several braces of throwing knives appear on $n.", ch, NULL, NULL, TO_CHAR);
        }
        else {
          act("A bow and quiver of arrows appears on $n's back.", ch, NULL, NULL, TO_ROOM);
          act("A bow and quiver of arrows appears on $n's back.", ch, NULL, NULL, TO_CHAR);
        }
        if (battleground(ch->in_room))
        op_report(logact("A bow and quiver of arrows appears on $n's back.", ch, victim), ch);
      }
      if (ch->fight_fast == FALSE)
      apply_caff(ch, CAFF_AHUNTER, 3);
      else
      apply_caff(ch, CAFF_AHUNTER, 2);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_NIGHTASPECT) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_NIGHTASPECT) / 2;
    }
    else if (!str_cmp(arg1, "gust")) {
      if (get_skill(ch, SKILL_WEATHER) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_WEATHER, 1)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_WEATHER, 1);

      act("You send a gust of wind at $N.", ch, NULL, victim, TO_CHAR);
      act("You are buffeted by a sudden gust of wind.", ch, NULL, victim, TO_VICT);
      act("$N is buffeted by a sudden gust of wind.", ch, NULL, victim, TO_NOTVICT);
      if (battleground(ch->in_room))
      op_report(logact("$N is buffeted by a sudden gust of wind.", ch, victim), ch);

      mult = debuff_multiplier(ch, victim);
      apply_caff(victim, CAFF_GUST, 1 * mult / 100);
      useattack(ch);
      if (mult > 0)
      fall_character(victim);

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_WEATHER) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_WEATHER) / 2;
    }
    else if (!str_cmp(arg1, "thickenair")) {
      if (get_skill(ch, SKILL_WEATHER) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_WEATHER, 2)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_WEATHER, 2);
      mult = buff_multiplier(ch, victim);
      act("You thicken the air around $N.", ch, NULL, victim, TO_CHAR);
      act("The air around $n blurs slightly.", victim, NULL, NULL, TO_ROOM);
      if (battleground(ch->in_room))
      op_report(logact("The air around $n blurs slightly.", ch, victim), ch);
      summon_cobj(ch->in_room, COBJ_THICKAIR, 1 * mult / 100, ch->x, ch->y, ch);
      useattack(ch);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_WEATHER) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_WEATHER) / 2;
    }
    else if (!str_cmp(arg1, "wind")) {
      if (get_skill(ch, SKILL_WEATHER) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (IS_SET(ch->in_room->room_flags, ROOM_INDOORS)) {
        send_to_char("That only works outdoors.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_WEATHER, 3)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_WEATHER, 3);
      act("You summon the wind.", ch, NULL, victim, TO_CHAR);
      if (battleground(ch->in_room))
      op_report("The wind picks up.", ch);
      CHAR_DATA *newvict;
      for (CharList::iterator it = char_list.begin(); it != char_list.end();
      ++it) {
        newvict = *it;
        if (newvict == NULL || is_gm(newvict))
        continue;
        if (!same_fight(newvict, ch))
        continue;
        if (IS_FLAG(newvict->act, ACT_COMBATOBJ))
        continue;
        if (ch == newvict)
        continue;
        if (IS_NPC(newvict) && newvict->pIndexData->vnum == COBJ_TEAR) {
          char_from_room(newvict);
          char_to_room(newvict, get_room_index(1));
        }
        if (IS_NPC(newvict) && newvict->pIndexData->vnum == COBJ_SMOKE) {
          char_from_room(newvict);
          char_to_room(newvict, get_room_index(1));
        }
        mult = debuff_multiplier(ch, newvict);
        act("You are buffeted by a sudden gust of wind.", ch, NULL, newvict, TO_VICT);
        apply_caff(newvict, CAFF_GUST, 1 * mult / 100);
        if (mult > 0)
        fall_character(newvict);
      }
      useattack(ch);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_WEATHER) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_WEATHER) / 2;
    }
    else if (!str_cmp(arg1, "suffocate")) {
      if (get_skill(ch, SKILL_WEATHER) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_WEATHER, 4)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_WEATHER, 4);
      mult = debuff_multiplier(ch, victim);
      act("You pull the air from $N's lungs.", ch, NULL, victim, TO_CHAR);
      if (!is_undead(victim) && !has_gasmask(victim)) {
        act("You feel suddenly short of breath.", ch, NULL, victim, TO_VICT);
        act("$N suddenly seems to start having trouble breathing.", ch, NULL, victim, TO_NOTVICT);
        if (battleground(ch->in_room))
        op_report(logact("$N suddenly seems to start having trouble breathing.", ch, victim), ch);
        apply_caff(victim, CAFF_HEARTSLOW, 2 * mult / 100);
      }
      useattack(ch);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_WEATHER) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_WEATHER) / 2;
    }
    else if (!str_cmp(arg1, "lightningstrike")) {
      if (get_skill(ch, SKILL_WEATHER) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (IS_SET(ch->in_room->room_flags, ROOM_INDOORS)) {
        send_to_char("That only works outdoors.\n\r", ch);
        return;
      }
      if (!is_raining(ch->in_room) && !is_hailing(ch->in_room) && !is_snowing(ch->in_room)) {
        if (cloud_density(ch->in_room) < 80 || cloud_cover(ch->in_room) < 80) {
          send_to_char("There needs to be a storm first.\n\r", ch);
          return;
        }
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_WEATHER, 5)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_WEATHER, 5);

      CHAR_DATA *newvict;
      for (CharList::iterator it = victim->in_room->people->begin();
      it != victim->in_room->people->end(); ++it) {
        newvict = *it;

        if (newvict == NULL)
        continue;

        if (newvict->in_room == NULL)
        continue;

        if (IS_FLAG(newvict->act, ACT_COMBATOBJ))
        continue;

        if (get_dist(newvict->x, newvict->y, victim->x, victim->y) > 15)
        continue;

        if (number_percent() % 2 == 0)
        victim = newvict;
      }
      if (is_in_cover(victim) && number_percent() % 2 == 0)
      victim = get_cover(victim);
      mult = debuff_multiplier(ch, victim);
      act("You summon a lightning bolt to strike $N.", ch, NULL, victim, TO_CHAR);
      act("A lightning bolt flashes down from the sky to strike $N!", ch, NULL, victim, TO_NOTVICT);
      act("A lightning bolt flashes down fro the sky to strike you.", ch, NULL, victim, TO_VICT);
      if (battleground(ch->in_room))
      op_report(
      logact("A lightning bolt flashes down from the sky to strike $N!", ch, victim), ch);

      if (get_skill(victim, SKILL_ELECPROOF) < 1) {
        combat_damage(victim, ch, UMIN(mult * max_hp(victim) / 300, max_hp(victim) / 2), DIS_LIGHTNING);
        apply_caff(victim, CAFF_BLIND, 1 * mult / 100);
      }
      useattack(ch);

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_WEATHER) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_WEATHER) / 2;
    }
    else if (!str_cmp(arg1, "jam")) {
      if (get_skill(ch, SKILL_MAGNO) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_MAGNO, 1)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_MAGNO, 1);
      act("You jam $N's gun.", ch, NULL, victim, TO_CHAR);
      act("Your gun jams.", ch, NULL, victim, TO_VICT);
      act("$N's gun looks like it suddenly jams.", ch, NULL, victim, TO_NOTVICT);
      if (battleground(ch->in_room))
      op_report(logact("$N's gun looks like it suddenly jams.", ch, victim), ch);
      apply_caff(victim, CAFF_JAM, 1);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_MAGNO) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_MAGNO) / 2;
    }
    else if (!str_cmp(arg1, "curvebullets")) {
      if (get_skill(ch, SKILL_MAGNO) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_MAGNO, 2)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_MAGNO, 2);
      act("You start curving your bullets slightly to seek their targets.", ch, NULL, NULL, TO_CHAR);
      if (ch->fight_fast == TRUE)
      apply_caff(ch, CAFF_ATTRACT, 1);
      else
      apply_caff(ch, CAFF_ATTRACT, 2);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_MAGNO) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_MAGNO) / 2;
    }
    else if (!str_cmp(arg1, "repel")) {
      if (get_skill(ch, SKILL_MAGNO) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_MAGNO, 3)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_MAGNO, 3);

      act("You disarm $N remotely.", ch, NULL, victim, TO_CHAR);
      act("Your metal weapons are disarmed by an invisible force.", ch, NULL, victim, TO_VICT);
      act("All of $N's metal weapons are suddenly disarmed by an invisible force.", ch, NULL, victim, TO_NOTVICT);
      if (battleground(ch->in_room))
      op_report(logact("All of $N's metal weapons are suddenly disarmed by an invisible force.", ch, victim), ch);

      apply_caff(victim, CAFF_REPEL, 1);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_MAGNO) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_MAGNO) / 2;
    }
    else if (!str_cmp(arg1, "overload")) {
      if (get_skill(ch, SKILL_MAGNO) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_MAGNO, 4)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_MAGNO, 4);
      act("You overload $N's electronics.", ch, NULL, victim, TO_CHAR);
      act("You hear the sudden sound of sharp static.", ch, NULL, victim, TO_VICT);
      act("$N's electronics suddenly spark.", ch, NULL, victim, TO_NOTVICT);
      if (battleground(ch->in_room))
      op_report(logact("$N's electronics suddenly spark.", ch, victim), ch);
      apply_caff(victim, CAFF_OVERLOAD, 2);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_MAGNO) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_MAGNO) / 2;
    }
    else if (!str_cmp(arg1, "reflect")) {
      if (get_skill(ch, SKILL_MAGNO) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_MAGNO, 5)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_MAGNO, 5);

      act("You create a magnetic slingshot pointed at $N.", ch, NULL, victim, TO_CHAR);
      apply_caff(victim, CAFF_REFLECT, 1);
      victim->reflect = ch;

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_MAGNO) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_MAGNO) / 2;
    }
    else if (!str_cmp(arg1, "adrenaline")) {
      if (get_skill(ch, SKILL_BIOMANCY) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (is_undead(ch)) {
        send_to_char("Your body is dead.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_BIOMANCY, 1)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_BIOMANCY, 1);
      act("You jack up your adrenaline.", ch, NULL, victim, TO_CHAR);
      if (ch->fight_fast == TRUE)
      apply_caff(ch, CAFF_ADRENALINE, 1);
      else
      apply_caff(ch, CAFF_ADRENALINE, 2);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_BIOMANCY) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_BIOMANCY) / 2;
    }
    else if (!str_cmp(arg1, "heal")) {
      if (get_skill(ch, SKILL_BIOMANCY) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (is_undead(ch)) {
        send_to_char("Your body is dead.\n\r", ch);
        return;
      }
      if (ch->debuff >= 200) {
        send_to_char("You already have too much stagger.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_BIOMANCY, 2)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_BIOMANCY, 2);
      act("You augment your body's natural healing.", ch, NULL, victim, TO_CHAR);
      int healamount = max_hp(ch) - ch->hit;
      healamount /= 2;
      healamount = UMAX(healamount, 25);
      ch->debuff += healamount;
      healamount = UMIN(healamount, get_tier(ch) * 20);
      healamount = UMIN(healamount, max_hp(ch) / 5 * get_tier(ch));
      ch->hit += healamount;
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_BIOMANCY) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_BIOMANCY) / 2;
    }
    else if (!str_cmp(arg1, "resistpain")) {
      if (get_skill(ch, SKILL_BIOMANCY) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (is_undead(ch)) {
        send_to_char("Your body is dead.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_BIOMANCY, 3)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_BIOMANCY, 3);
      act("You switch off your body's pain receptors temporarily.", ch, NULL, victim, TO_CHAR);
      if (ch->fight_fast == TRUE)
      apply_caff(ch, CAFF_RESISTPAIN, 1);
      else
      apply_caff(ch, CAFF_RESISTPAIN, 2);
      ch->pcdata->rpainamount = ch->hit;
      ch->hit = UMIN(max_hp(ch), ch->hit + 100);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_BIOMANCY) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_BIOMANCY) / 2;
    }
    else if (!str_cmp(arg1, "recover")) {
      if (get_skill(ch, SKILL_BIOMANCY) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (is_undead(ch)) {
        send_to_char("Your body is dead.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_BIOMANCY, 4)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_BIOMANCY, 4);
      ch->debuff /= 2;
      act("You recover your balance.", ch, NULL, victim, TO_CHAR);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_BIOMANCY) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_BIOMANCY) / 2;
    }
    else if (!str_cmp(arg1, "oxygenate")) {
      if (get_skill(ch, SKILL_BIOMANCY) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (is_undead(ch)) {
        send_to_char("Your body is dead.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_BIOMANCY, 5)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_BIOMANCY, 5);

      act("You flood your blood with fresh oxygen.", ch, NULL, victim, TO_CHAR);
      if (ch->fight_fast == FALSE)
      apply_caff(ch, CAFF_SPRINTING, 2);
      else
      apply_caff(ch, CAFF_SPRINTING, 1);

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_BIOMANCY) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_BIOMANCY) / 2;
    }
    else if (!str_cmp(arg1, "chill")) {
      if (get_skill(ch, SKILL_CRYO) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_CRYO, 1)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_CRYO, 1);
      act("You rapidly cool $N.", ch, NULL, victim, TO_CHAR);
      if (has_caff(victim, CAFF_SWEAT)) {
        act("You cool back down.", ch, NULL, victim, TO_VICT);
        remove_caff(victim, CAFF_SWEAT);
      }
      else if (!is_undead(victim) && get_skill(victim, SKILL_ICEPROOF) < 1) {
        act("You suddenly become uncomfortably cold.", ch, NULL, victim, TO_VICT);
        mult = debuff_multiplier(ch, victim);
        apply_caff(victim, CAFF_CHILL, 1 * mult / 100);
      }
      act("A small amount of frost forms in the air around $N.", ch, NULL, victim, TO_NOTVICT);
      if (battleground(ch->in_room))
      op_report(logact("A small amount of frost forms in the air around $N.", ch, victim), ch);
      useattack(ch);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_CRYO) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_CRYO) / 2;
    }
    else if (!str_cmp(arg1, "reinforce")) {
      if (get_skill(ch, SKILL_CRYO) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (!wearing_armor(victim)) {
        send_to_char("They're not wearing armor.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_CRYO, 2)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_CRYO, 2);
      mult = buff_multiplier(ch, victim);
      act("You reinforce $N's armor with ice from the moisture in the air.", ch, NULL, victim, TO_CHAR);
      act("Ice crystals form on your armor.", ch, NULL, victim, TO_VICT);
      act("Ice crystals form on $N's armor.", ch, NULL, victim, TO_NOTVICT);
      if (battleground(ch->in_room))
      op_report(logact("Ice crystals form on $N's armor.", ch, victim), ch);
      if (has_caff(ch, CAFF_BURNARMOR))
      remove_caff(ch, CAFF_BURNARMOR);
      if (mult > 0) {
        if (ch->fight_fast == FALSE && ch == victim) {
          apply_caff(victim, CAFF_ICEARMOR, 1 + mult / 100);
          apply_caff(victim, CAFF_SLOW, 1 + mult / 100);
        }
        else {
          apply_caff(victim, CAFF_ICEARMOR, mult / 100);
          apply_caff(victim, CAFF_SLOW, mult / 100);
        }
      }
      useattack(ch);

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_CRYO) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_CRYO) / 2;
    }
    else if (!str_cmp(arg1, "stickweapons")) {
      if (get_skill(ch, SKILL_CRYO) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_CRYO, 3)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_CRYO, 3);
      mult = debuff_multiplier(ch, victim);
      act("You freeze $N's weapons in their sheaths.", ch, NULL, victim, TO_CHAR);
      act("Your weapons stick in their sheaths.", ch, NULL, victim, TO_VICT);
      act("Ice forms around $N's sheathed weapons.", ch, NULL, victim, TO_NOTVICT);
      if (battleground(ch->in_room))
      op_report(logact("Ice forms around $N's sheathed weapons.", ch, victim), ch);
      apply_caff(victim, CAFF_STICK, 2 * mult / 100);
      useattack(ch);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_CRYO) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_CRYO) / 2;
    }
    else if (!str_cmp(arg1, "colddiscipline")) {
      if (get_skill(ch, SKILL_CRYO) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_CRYO, 4)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_CRYO, 4);
      mult = buff_multiplier(ch, victim);
      act("You cool and still $N's body.", ch, NULL, victim, TO_CHAR);
      if (!is_undead(victim) && get_skill(victim, SKILL_ICEPROOF) < 1) {
        act("You feel your body cool and still slightly, improving your accuracy.", ch, NULL, victim, TO_VICT);
        if (ch->fight_fast == FALSE && ch == victim)
        apply_caff(victim, CAFF_DISCIPLINE, 1 + mult / 100);
        else
        apply_caff(victim, CAFF_DISCIPLINE, mult / 100);
      }
      useattack(ch);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_CRYO) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_CRYO) / 2;
    }
    else if (!str_cmp(arg1, "coldsnap")) {
      if (get_skill(ch, SKILL_CRYO) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (is_raining(ch->in_room) == FALSE || IS_SET(ch->in_room->room_flags, ROOM_INDOORS)) {
        send_to_char("That only works when it's raining.", ch);
        return;
      }
      if (!is_clothed(victim)) {
        send_to_char("They don't have any clothes to freeze.", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }

      if (abilcool(ch, SKILL_CRYO, 5)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_CRYO, 5);
      act("You freeze $N's clothes.", ch, NULL, victim, TO_CHAR);
      act("Your clothes freeze.", ch, NULL, victim, TO_VICT);
      act("$N's clothes freeze.", ch, NULL, victim, TO_NOTVICT);
      if (battleground(ch->in_room))
      op_report(logact("$N's clothes freeze", ch, victim), ch);
      mult = debuff_multiplier(ch, victim);

      if (get_skill(victim, SKILL_ICEPROOF) < 1) {
        apply_caff(victim, CAFF_STUNNED, mult / 100);
      }
      useattack(ch);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_CRYO) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_CRYO) / 2;
    }
    else if (!str_cmp(arg1, "sweat")) {
      if (get_skill(ch, SKILL_PYRO) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_PYRO, 1)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_PYRO, 1);
      act("You rapidly heat $N.", ch, NULL, victim, TO_CHAR);
      mult = debuff_multiplier(ch, victim);
      if (has_caff(victim, CAFF_CHILL)) {
        act("You warm back up.", ch, NULL, victim, TO_VICT);
        remove_caff(victim, CAFF_CHILL);
      }
      else if (!is_undead(victim) && get_skill(victim, SKILL_FIREPROOF) < 1) {
        act("You suddenly become uncomfortably warm.", ch, NULL, victim, TO_VICT);
        act("$N starts to sweat.", ch, NULL, victim, TO_NOTVICT);
        if (battleground(ch->in_room))
        op_report(logact("$N starts to sweat.", ch, victim), ch);
        apply_caff(victim, CAFF_SWEAT, 1 * mult / 100);
      }
      if (has_caff(victim, CAFF_DISCIPLINE))
      remove_caff(victim, CAFF_DISCIPLINE);
      useattack(ch);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_PYRO) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_PYRO) / 2;
    }
    else if (!str_cmp(arg1, "burnarmor")) {
      if (get_skill(ch, SKILL_PYRO) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (!wearing_armor(victim)) {
        send_to_char("You see no armor to burn.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_PYRO, 2)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_PYRO, 2);

      act("You burn $N's armor.", ch, NULL, victim, TO_CHAR);
      act("Your armor blackens and burns.", ch, NULL, victim, TO_VICT);
      act("$N's armor blackens and burns.", ch, NULL, victim, TO_NOTVICT);
      if (battleground(ch->in_room))
      op_report(logact("$N's armor blackens and burns.", ch, victim), ch);
      mult = debuff_multiplier(ch, victim);
      apply_caff(victim, CAFF_BURNARMOR, 1 * mult / 100);
      if (has_caff(victim, CAFF_ICEARMOR))
      remove_caff(victim, CAFF_ICEARMOR);
      useattack(ch);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_PYRO) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_PYRO) / 2;
    }
    else if (!str_cmp(arg1, "burnweapon")) {
      if (get_skill(ch, SKILL_PYRO) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_PYRO, 3)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_PYRO, 3);
      act("You burn $N's weapons.", ch, NULL, victim, TO_CHAR);
      act("Your wooden weapons break out in small fires.", ch, NULL, victim, TO_VICT);
      act("$N's wooden weapons break out in small fires.", ch, NULL, victim, TO_NOTVICT);
      if (battleground(ch->in_room))
      op_report(
      logact("$N's wooden weapons break out in small fires.", ch, victim), ch);

      mult = debuff_multiplier(ch, victim);
      if (get_skill(victim, SKILL_FIREPROOF) < 1)
      apply_caff(victim, CAFF_BURNWEAPON, 2 * mult / 100);

      useattack(ch);

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_PYRO) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_PYRO) / 2;
    }
    else if (!str_cmp(arg1, "heatmetal")) {
      if (get_skill(ch, SKILL_PYRO) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }

      if (abilcool(ch, SKILL_PYRO, 4)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_PYRO, 4);
      act("Your blades start to glow red with heat.", victim, NULL, NULL, TO_CHAR);
      act("$N's blades start to glow red with heat.", victim, NULL, NULL, TO_ROOM);
      if (battleground(ch->in_room))
      op_report(logact("$N's blades start to glow red with heat.", ch, victim), ch);
      mult = buff_multiplier(ch, victim);
      if (ch == victim && ch->fight_fast == FALSE)
      apply_caff(victim, CAFF_HEATMETAL, 1 + 1 * mult / 100);
      else
      apply_caff(victim, CAFF_HEATMETAL, 1 * mult / 100);
      useattack(ch);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_PYRO) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_PYRO) / 2;
    }
    else if (!str_cmp(arg1, "startfire")) {
      if (get_skill(ch, SKILL_PYRO) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (is_raining(ch->in_room)) {
        send_to_char("It's too wet.\n\r", ch);
        return;
      }
      if (!is_clothed(victim)) {
        if (!is_animal(victim) || get_animal_genus(ch, ANIMAL_ACTIVE) != GENUS_MAMMAL) {
          send_to_char("You see nothing to burn.\n\r", ch);
          return;
        }
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }

      if (abilcool(ch, SKILL_PYRO, 5)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_PYRO, 5);
      if (is_clothed(victim)) {
        act("You ignite $N's clothes.", ch, NULL, victim, TO_CHAR);
        act("A small fire suddenly ignites on your clothes.", ch, NULL, victim, TO_VICT);
        act("A small fire suddenly ignites on $N's clothes.", ch, NULL, victim, TO_NOTVICT);
        if (battleground(ch->in_room))
        op_report(logact("A small fire suddenly ignites on $N's clothes.", ch, victim), ch);
      }
      else if (has_fur(victim)) {
        act("You ignite $N's fur.", ch, NULL, victim, TO_CHAR);
        act("A small fire suddenly ignites on your fur.", ch, NULL, victim, TO_VICT);
        act("A small fire suddenly ignites on $N's fur.", ch, NULL, victim, TO_VICT);
        if (battleground(ch->in_room))
        op_report(
        logact("A small fire suddenly ignites on $N's fur.", ch, victim), ch);
      }
      mult = debuff_multiplier(ch, victim);
      int dam = 25 * mult / 100;
      if (is_in_cover(victim))
      dam /= 10;
      if (get_skill(victim, SKILL_FIREPROOF) < 1)
      combat_damage(victim, ch, dam, DIS_FIRE);
      useattack(ch);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_PYRO) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_PYRO) / 2;
    }
    else if (!str_cmp(arg1, "regenerate")) {
      if (get_skill(ch, SKILL_NECRO) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }

      if (abilcool(ch, SKILL_NECRO, 1)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_NECRO, 1);
      mult = buff_multiplier(ch, victim);
      act("You regenerate $N's flesh.", ch, NULL, victim, TO_CHAR);
      if (is_undead(victim)) {
        victim->hit =
        UMAX(victim->hit, UMIN(max_hp(victim), (victim->hit + ((mult * max_hp(victim) / 10)) / 100)));
        act("Your body regenerates some of it's injuries.", ch, NULL, victim, TO_VICT);
      }
      useattack(ch);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_NECRO) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_NECRO) / 2;
    }
    else if (!str_cmp(arg1, "rigormortis")) {
      if (get_skill(ch, SKILL_NECRO) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }

      if (abilcool(ch, SKILL_NECRO, 2)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_NECRO, 2);

      act("You still $N's legs.", ch, NULL, victim, TO_CHAR);
      mult = debuff_multiplier(ch, victim);
      if (is_undead(victim)) {
        apply_caff(victim, CAFF_ROOT, mult / 100);
        act("Your legs freeze up.", ch, NULL, victim, TO_VICT);
        act("$N's legs suddenly freeze up.", ch, NULL, victim, TO_NOTVICT);
        if (battleground(ch->in_room))
        op_report(logact("$N's legs suddenly freeze up.", ch, victim), ch);
      }
      useattack(ch);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_NECRO) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_NECRO) / 2;
    }
    else if (!str_cmp(arg1, "lethargy")) {
      if (get_skill(ch, SKILL_NECRO) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_NECRO, 3)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_NECRO, 3);
      mult = debuff_multiplier(ch, victim);
      act("You infuse $N with weakness.", ch, NULL, victim, TO_CHAR);
      if (is_undead(victim)) {
        act("You feel weak and tired.", ch, NULL, victim, TO_VICT);
        apply_caff(victim, CAFF_SLOW, 1 * mult / 100);
        apply_caff(victim, CAFF_WEAKEN, 1 * mult / 100);
        act("$N starts to move slower.", ch, NULL, victim, TO_NOTVICT);
        if (battleground(ch->in_room))
        op_report(logact("$N starts to move slower.", ch, victim), ch);
      }
      useattack(ch);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_NECRO) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_NECRO) / 2;
    }
    else if (!str_cmp(arg1, "halt")) {
      if (get_skill(ch, SKILL_NECRO) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_NECRO, 4)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_NECRO, 4);
      mult = debuff_multiplier(ch, victim);
      act("You command $N's body to halt.", ch, NULL, victim, TO_CHAR);
      if (is_undead(victim)) {
        act("Your body suddenly stops responding.", ch, NULL, victim, TO_VICT);
        apply_caff(victim, CAFF_STUNNED, mult / 100);
        act("$N suddenly freezes in place.", ch, NULL, victim, TO_NOTVICT);
        if (battleground(ch->in_room))
        op_report(logact("$N suddenly freezes in place.", ch, victim), ch);
      }
      useattack(ch);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_NECRO) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_NECRO) / 2;
    }
    else if (!str_cmp(arg1, "commandundead")) {
      if (get_skill(ch, SKILL_NECRO) < 2) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if ((victim = get_char_fight(ch, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      CHAR_DATA *target;
      if ((target = get_char_fight(ch, argument)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (target == victim) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (!has_focus(ch)) {
        send_to_char("You need a focus to work your magic.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_NECRO, 5)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_NECRO, 5);
      mult = debuff_multiplier(ch, victim);
      act("You command $N's body to attack your target.", ch, NULL, victim, TO_CHAR);
      if (is_undead(victim) && mult > 0) {
        apply_caff(victim, CAFF_COMMANDED, 1);
        victim->commanded = target;
        victim->command_force = 50 * mult / 100;
      }
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_NECRO) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_NECRO) / 2;
    }
    else
    send_to_char("No such ability or attack.\n\r", ch);

    free_string(ch->abilmove);
    ch->abilmove = str_dup("");
    if (victim != NULL) {
      if (in_fight(ch) && in_fight(victim) && combat_distance(ch, victim, FALSE) > 1) {
        ch->facing =
        roomdirection(0, 0, relative_x(ch, victim->in_room, victim->x), relative_y(ch, victim->in_room, victim->y));
      }
    }
  }

  bool stealthvassal(char *name) {
    char buf[MSL];
    CHAR_DATA *victim;

    struct stat sb;
    DESCRIPTOR_DATA d;
    bool online = FALSE;

    d.original = NULL;

    if ((victim = get_char_world_pc(name)) == NULL) {
      log_string("DESCRIPTOR: Stealth vassal");

      if (!load_char_obj(&d, name)) {
        return TRUE;
      }

      sprintf(buf, "%s%s", PLAYER_DIR, capitalize(name));
      stat(buf, &sb);
      victim = d.character;
    }
    else
    online = TRUE;

    if (victim->pcdata->pledge_stealth == 1) {
      if (!online)
      free_char(victim);
      return TRUE;
    }

    if (!online)
    free_char(victim);

    return FALSE;
  }

  int vassalvalue(char *name) {
    char buf[MSL];
    CHAR_DATA *victim;

    struct stat sb;
    DESCRIPTOR_DATA d;
    bool online = FALSE;

    d.original = NULL;

    if ((victim = get_char_world_pc(name)) == NULL) {
      log_string("DESCRIPTOR: Vassalvalue");

      if (!load_char_obj(&d, name)) {
        return 0;
      }

      sprintf(buf, "%s%s", PLAYER_DIR, capitalize(name));
      stat(buf, &sb);
      victim = d.character;
    }
    else
    online = TRUE;

    int value = 0;

    if (victim->pcdata->blood_date == 0 || victim->pcdata->blood_potency <= victim->pcdata->blood_level)
    value = 0;
    else
    value = blood_tvalue(victim);

    if (!online)
    free_char(victim);

    return value * 2;
  }

  int vampire_vassal(CHAR_DATA *ch, int amount) {

    int base = amount;
    int mult = 100;

    for (int i = 0; i < 5; i++) {
      if (safe_strlen(ch->pcdata->bonds[i]) > 2)
      mult += vassalvalue(ch->pcdata->bonds[i]);
    }
    base = base * mult / 100;

    return base;
  }

  _DOFUN(do_mimic) {

    if (get_skill(ch, SKILL_MIMIC) <= 0) {
      send_to_char("You don't have that skill.\n\r", ch);
      return;
    }
    int race = -1;
    if (!str_cmp(argument, "human"))
    race = RACE_NORMAL;
    if (!str_cmp(argument, "gifted"))
    race = RACE_GIFTED;
    if (!str_cmp(argument, "demigod"))
    race = RACE_NEWDEMIGOD;
    if (!str_cmp(argument, "demonborn"))
    race = RACE_NEWDEMONBORN;
    if (!str_cmp(argument, "faeborn"))
    race = RACE_NEWFAEBORN;
    if (!str_cmp(argument, "angelborn"))
    race = RACE_NEWANGELBORN;
    if (!str_cmp(argument, "vampire"))
    race = RACE_NEWVAMPIRE;
    if (!str_cmp(argument, "werewolf"))
    race = RACE_NEWWEREWOLF;
    if (!str_cmp(argument, "wight"))
    race = RACE_WIGHT;

    if (race == -1 && safe_strlen(argument) > 2) {
      send_to_char("That is not a valid archetype.\n\r", ch);
      return;
    }

    ch->pcdata->mimic = race;
    send_to_char("Done.\n\r", ch);
  }

  _DOFUN(do_resurrect) {

    if (get_skill(ch, SKILL_RESURRECTION) < 1) {
      send_to_char("You don't have that ability.\n\r", ch);
      return;
    }
    CHAR_DATA *victim;
    char arg1[MSL];
    DESCRIPTOR_DATA d;

    argument = one_argument_nouncap(argument, arg1);

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (!is_ghost(victim) && !IS_FLAG(victim->act, PLR_DEAD)) {
      send_to_char("There's no such spirit here for you to bring back.\n\r", ch);
      return;
    }
    if (victim->race == RACE_WIGHT) {
      send_to_char("The effect does not take hold.\n\r", ch);
      return;
    }

    if (IS_FLAG(ch->act, PLR_DEAD)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    log_string("DESCRIPTOR: Resurrect");

    d.original = NULL;
    if (load_char_obj(&d, argument)) {
      send_to_char("A character with that name already exists.\n\r", ch);
      return;
    }

    if (safe_strlen(argument) < 3) {
      send_to_char("Resurrect (ghost) (new identity name)\n\r", ch);
      return;
    }
    victim->pcdata->decay_timer = 30;
    victim->pcdata->max_decay_timer = 30;
    victim->pcdata->decay_stage = 0;
    REMOVE_FLAG(victim->act, PLR_DEAD);
    if (IS_FLAG(victim->act, PLR_GHOST))
    REMOVE_FLAG(victim->act, PLR_GHOST);
    victim->wounds = 0;
    victim->race = RACE_WIGHT;

    victim->id = get_pc_id();
    change_identity(victim, argument);
    victim->pcdata->hair_genetic = 0;
    victim->pcdata->eyes_genetic = 0;

    act("The corpse of $n abruptly twitches, starts, then sits up.", victim, NULL, NULL, TO_ROOM);
    act("You feel a rush of sensation as life returns to you.", victim, NULL, NULL, TO_CHAR);

    apply_blackeyes(ch);
  }

  bool is_suggestible(CHAR_DATA *ch) {
    if (event_cleanse == 1)
    return FALSE;

    if (mindwarded(ch))
    return FALSE;

    if(has_imbuement(ch, -10))
    return TRUE;


    if (ch->race == RACE_FREEANGEL && wearing_collar(ch))
    return FALSE;

    if (is_angelborn(ch))
    return TRUE;

    if (!is_super(ch) && event_dominance == 1)
    return TRUE;


    if (IS_AFFECTED(ch, AFF_DSENSITIVE))
    return TRUE;

    return FALSE;
  }

  bool is_fatesensitive(CHAR_DATA *ch) {
    if (event_cleanse == 1)
    return FALSE;
    if(has_imbuement(ch, -12))
    return TRUE;
    if(is_faeborn(ch))
    return TRUE;
    return FALSE;
  }
  bool seems_fatesensitive(CHAR_DATA *ch) {
    if (event_cleanse == 1)
    return FALSE;
    if(has_imbuement(ch, -12))
    return TRUE;
    if(seems_faeborn(ch))
    return TRUE;
    return FALSE;
  }


  _DOFUN(do_suffer) {
    char arg1[MSL];
    char buf[MSL];

    argument = one_argument_nouncap(argument, arg1);

    if (!str_cmp(arg1, "mild")) {
      CHAR_DATA *to;

      for (CharList::iterator it = ch->in_room->people->begin();
      it != ch->in_room->people->end(); ++it) {
        to = *it;
        if (to == NULL || to->in_room == NULL || to->in_room != ch->in_room || IS_NPC(to))
        continue;

        if (!is_sufferingsensitive(to))
        continue;

        if (to == ch)
        continue;

        send_to_char("You feel your mood improve slightly.\n\r", to);
      }
      if (safe_strlen(argument) < 2) {
        send_to_char("You feel mild suffering.\n\r", ch);
        spyshow(ch, "feels mild suffering.");
      }
      else {
        printf_to_char(ch, "You feel mild suffering when you %s.\n\r", argument);
        char logbuf[MSL];
        sprintf(logbuf, "You feel mild suffering when you %s.\n\r", argument);
        char_rplog(ch, logbuf);

        sprintf(buf, "feels mild suffering when they %s.", argument);
        spyshow(ch, buf);
      }
      return;
    }
    if (!str_cmp(arg1, "moderate")) {
      CHAR_DATA *to;

      for (CharList::iterator it = ch->in_room->people->begin();
      it != ch->in_room->people->end(); ++it) {
        to = *it;
        if (to == NULL || to->in_room == NULL || to->in_room != ch->in_room || IS_NPC(to))
        continue;

        if (!is_sufferingsensitive(to))
        continue;

        if (to == ch)
        continue;

        send_to_char("You feel your mood improve.\n\r", to);
      }
      if (safe_strlen(argument) < 2) {
        send_to_char("You feel moderate suffering.\n\r", ch);
        spyshow(ch, "feels moderate suffering.");
      }
      else {
        printf_to_char(ch, "You feel moderate suffering when you %s.\n\r", argument);
        char logbuf[MSL];
        sprintf(logbuf, "You feel moderate suffering when you %s.\n\r", argument);
        char_rplog(ch, logbuf);

        sprintf(buf, "feels moderate suffering when they %s.", argument);
        spyshow(ch, buf);
      }
      return;
    }
    if (!str_cmp(arg1, "strong")) {
      CHAR_DATA *to;

      for (CharList::iterator it = ch->in_room->people->begin();
      it != ch->in_room->people->end(); ++it) {
        to = *it;
        if (to == NULL || to->in_room == NULL || to->in_room != ch->in_room || IS_NPC(to))
        continue;

        if (!is_sufferingsensitive(to))
        continue;

        if (to == ch)
        continue;

        send_to_char("You feel your mood skyrocket.\n\r", to);
      }
      if (safe_strlen(argument) < 2) {
        send_to_char("You feel strong suffering.\n\r", ch);
        spyshow(ch, "feels strong suffering.");
      }
      else {
        char logbuf[MSL];
        sprintf(logbuf, "You feel strong suffering when you %s.\n\r", argument);
        char_rplog(ch, logbuf);
        printf_to_char(ch, "You feel strong suffering when you %s.\n\r", argument);
        sprintf(buf, "feels strong suffering when they %s.", argument);
        spyshow(ch, buf);
      }
      return;
    }
    else
    send_to_char("Syntax: Suffer (mild/moderate/strong) (reason)\n\r", ch);
  }

  _DOFUN(do_desire) {
    CHAR_DATA *victim;
    char arg1[MSL];
    char arg2[MSL];
    char buf[MSL];

    argument = one_argument_nouncap(argument, arg1);

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {

      if (safe_strlen(argument) < 2) {
        send_to_char("Syntax: Desire mild/moderate/strong (desire)\n\r", ch);
        return;
      }
      if (!str_cmp(arg1, "mild")) {
        CHAR_DATA *to;

        for (CharList::iterator it = ch->in_room->people->begin();
        it != ch->in_room->people->end(); ++it) {
          to = *it;
          if (to == NULL || to->in_room == NULL || to->in_room != ch->in_room || IS_NPC(to))
          continue;

          if (!is_suggestible(to))
          continue;

          if (to == ch)
          continue;

          if (to->race == RACE_FREEANGEL)
          sprintf(buf, "You want to help $N filfil $S desire to %s.\n\r", argument);
          else
          sprintf(
          buf, "You just slightly want to help $N fulfil $S desire to %s.\n\r", argument);
          act(buf, to, NULL, ch, TO_CHAR);
        }
        printf_to_char(ch, "You feel a mild desire to %s.\n\r", argument);
        char logbuf[MSL];
        sprintf(logbuf, "You feel a mild desire to %s.\n\r", argument);
        char_rplog(ch, logbuf);
        sprintf(buf, "feels a mild desire to %s.", argument);
        spyshow(ch, buf);
        return;
      }
      else if (!str_cmp(arg1, "moderate")) {
        CHAR_DATA *to;

        for (CharList::iterator it = ch->in_room->people->begin();
        it != ch->in_room->people->end(); ++it) {
          to = *it;
          if (to == NULL || to->in_room == NULL || to->in_room != ch->in_room || IS_NPC(to))
          continue;

          if (!is_suggestible(to))
          continue;

          if (to == ch)
          continue;

          if (to->race == RACE_FREEANGEL)
          sprintf(buf, "You really want to help $N filfil $S desire to %s.\n\r", argument);
          else
          sprintf(buf, "You mildly want to help $N fulfil $S desire to %s.\n\r", argument);
          act(buf, to, NULL, ch, TO_CHAR);
        }
        printf_to_char(ch, "You feel a moderate desire to %s.\n\r", argument);
        char logbuf[MSL];
        sprintf(logbuf, "You feel a moderate desire to %s.\n\r", argument);
        char_rplog(ch, logbuf);

        sprintf(buf, "feels a moderate desire to %s.", argument);
        spyshow(ch, buf);

        return;
      }
      else if (!str_cmp(arg1, "strong")) {
        CHAR_DATA *to;

        for (CharList::iterator it = ch->in_room->people->begin();
        it != ch->in_room->people->end(); ++it) {
          to = *it;
          if (to == NULL || to->in_room == NULL || to->in_room != ch->in_room || IS_NPC(to))
          continue;

          if (!is_suggestible(to))
          continue;

          if (to == ch)
          continue;

          if (to->race == RACE_FREEANGEL)
          sprintf(buf, "You have to help $N filfil $S desire to %s.\n\r", argument);
          else
          sprintf(buf, "You want to help $N fulfil $S desire to %s.\n\r", argument);
          act(buf, to, NULL, ch, TO_CHAR);
        }
        printf_to_char(ch, "You feel a strong desire to %s.\n\r", argument);
        char logbuf[MSL];
        sprintf(logbuf, "You feel a strong desire to %s.\n\r", argument);
        char_rplog(ch, logbuf);

        sprintf(buf, "feels a strong desire to %s.", argument);
        spyshow(ch, buf);
        return;
      }
      else
      send_to_char("Syntax: desire mild/moderate/strong (desire) Or desire (person) mild/moderate/strong (desire)\n\r", ch);
      return;
    }

    argument = one_argument_nouncap(argument, arg2);

    if (!str_cmp(arg2, "mild")) {
      printf_to_char(ch, "You feel a mild desire to %s.\n\r", argument);
      char logbuf[MSL];
      sprintf(logbuf, "You feel a mild desire to %s.\n\r", argument);
      char_rplog(ch, logbuf);
      if (is_suggestible(victim)) {
        sprintf(buf, "You just slightly want to help $N fulfil $S desire to %s.\n\r", argument);
        act(buf, victim, NULL, ch, TO_CHAR);
      }
      sprintf(buf, "(to %s)feels a mild desire to %s.", NAME(victim), argument);
      spyshow(ch, buf);

    }
    else if (!str_cmp(arg2, "moderate")) {
      printf_to_char(ch, "You feel a moderate desire to %s.\n\r", argument);
      char logbuf[MSL];
      sprintf(logbuf, "You feel a moderate desire to %s.\n\r", argument);
      char_rplog(ch, logbuf);

      if (is_suggestible(victim)) {
        sprintf(buf, "You mildly want to help $N fulfil $S desire to %s.\n\r", argument);
        act(buf, victim, NULL, ch, TO_CHAR);
      }
      sprintf(buf, "(to %s)feels a moderate desire to %s.", NAME(victim), argument);
      spyshow(ch, buf);

    }
    else if (!str_cmp(arg2, "strong")) {
      printf_to_char(ch, "You feel a strong desire to %s.\n\r", argument);
      char logbuf[MSL];
      sprintf(logbuf, "You feel a strong desire to %s.\n\r", argument);
      char_rplog(ch, logbuf);

      if (is_suggestible(victim)) {
        sprintf(buf, "You want to help $N fulfil $S desire to %s.\n\r", argument);
        act(buf, victim, NULL, ch, TO_CHAR);
      }
      sprintf(buf, "(to %s)feels a strong desire to %s.", NAME(victim), argument);
      spyshow(ch, buf);

    }
    else
    send_to_char("Syntax: desire mild/moderate/strong (desire) Or desire (person) mild/moderate/strong (desire)\n\r", ch);
  }

  bool is_suffer_sensitive(CHAR_DATA *ch)
  {
    if(is_demonborn(ch))
    return TRUE;

    if (IS_AFFECTED(ch, AFF_SUFFER) == TRUE)
    return TRUE;

    return FALSE;
  }

  bool seems_suffer_sensitive(CHAR_DATA *ch)
  {
    if(seems_demonborn(ch))
    return TRUE;

    if (IS_AFFECTED(ch, AFF_SUFFER) == TRUE)
    return TRUE;

    return FALSE;
  }

  _DOFUN(do_dread) {
    CHAR_DATA *victim;
    char arg1[MSL];
    char arg2[MSL];
    char buf[MSL];

    argument = one_argument_nouncap(argument, arg1);

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {

      if (safe_strlen(argument) < 2) {
        send_to_char("Syntax: Dread mild/moderate/strong (thing you are preoccupied with dread of)\n\r", ch);
        return;
      }
      if (!str_cmp(arg1, "mild")) {
        CHAR_DATA *to;

        for (CharList::iterator it = ch->in_room->people->begin();
        it != ch->in_room->people->end(); ++it) {
          to = *it;
          if (to == NULL || to->in_room == NULL || to->in_room != ch->in_room || IS_NPC(to))
          continue;

          if (!is_suffer_sensitive(to))
          continue;

          if (to == ch)
          continue;

          sprintf(
          buf, "You just slightly want to manifest $N's dread of %s.\n\r", argument);
          act(buf, to, NULL, ch, TO_CHAR);
        }
        printf_to_char(ch, "You feel mildly negatively preoccupied with the prospect of %s.\n\r", argument);
        char logbuf[MSL];
        sprintf(logbuf, "You feel mildly negatively preoccupied with the prospect of %s.\n\r", argument);
        char_rplog(ch, logbuf);
        sprintf(buf, "feels mild dread at the prospect of %s.", argument);
        spyshow(ch, buf);
        return;
      }
      else if (!str_cmp(arg1, "moderate")) {
        CHAR_DATA *to;

        for (CharList::iterator it = ch->in_room->people->begin();
        it != ch->in_room->people->end(); ++it) {
          to = *it;
          if (to == NULL || to->in_room == NULL || to->in_room != ch->in_room || IS_NPC(to))
          continue;

          if (!is_suffer_sensitive(to))
          continue;

          if (to == ch)
          continue;
          sprintf(buf, "You moderately want to manifest $N's dread of %s.\n\r", argument);
          act(buf, to, NULL, ch, TO_CHAR);
        }
        printf_to_char(ch, "You feel moderately negatively preoccupied with the prospect of %s.\n\r", argument);
        char logbuf[MSL];
        sprintf(logbuf, "You feel moderately negatively preoccupied with the prospect of %s.\n\r", argument);
        char_rplog(ch, logbuf);
        sprintf(buf, "feels moderate dread at the prospect of %s.", argument);
        spyshow(ch, buf);
        return;
      }
      else if (!str_cmp(arg1, "strong")) {
        CHAR_DATA *to;

        for (CharList::iterator it = ch->in_room->people->begin();
        it != ch->in_room->people->end(); ++it) {
          to = *it;
          if (to == NULL || to->in_room == NULL || to->in_room != ch->in_room || IS_NPC(to))
          continue;

          if (!is_suffer_sensitive(to))
          continue;

          if (to == ch)
          continue;
          sprintf(buf, "You want to manifest $N's dread of %s.\n\r", argument);
          act(buf, to, NULL, ch, TO_CHAR);
        }
        printf_to_char(ch, "You feel negatively preoccupied with the prospect of %s.\n\r", argument);
        char logbuf[MSL];
        sprintf(logbuf, "You feel negatively preoccupied with the prospect of %s.\n\r", argument);
        char_rplog(ch, logbuf);
        sprintf(buf, "feels dread at the prospect of %s.", argument);
        spyshow(ch, buf);
        return;
      }
      else
      send_to_char("Syntax: dread mild/moderate/strong (dread description) Or dread (person) mild/moderate/strong (dread description)\n\r", ch);
      return;
    }
    argument = one_argument_nouncap(argument, arg2);
    if (!str_cmp(arg2, "mild")) {
      printf_to_char(ch, "You feel mildly negatively preoccupied with the prospect of %s.\n\r", argument);
      char logbuf[MSL];
      sprintf(logbuf, "You feel mildly negatively preoccupied with the prospect of %s.\n\r", argument);
      char_rplog(ch, logbuf);
      if (is_suffer_sensitive(victim)) {
        sprintf(buf, "You just slightly want to manifest $N's dread of %s.\n\r", argument);
        act(buf, victim, NULL, ch, TO_CHAR);
      }
      sprintf(buf, "(to %s)feels a mild dreed of %s.", NAME(victim), argument);
      spyshow(ch, buf);

    }
    else if (!str_cmp(arg2, "moderate")) {
      printf_to_char(ch, "You feel moderately negatively preoccupied with the prospect of %s.\n\r", argument);
      char logbuf[MSL];
      sprintf(logbuf, "You feel moderately negatively preocupied with the prospect of %s.\n\r", argument);
      char_rplog(ch, logbuf);

      if (is_suffer_sensitive(victim)) {
        sprintf(buf, "You moderately want to manifest $N's dread of %s.\n\r", argument);
        act(buf, victim, NULL, ch, TO_CHAR);
      }
      sprintf(buf, "(to %s)feels a moderate dread of %s.", NAME(victim), argument);
      spyshow(ch, buf);

    }
    else if (!str_cmp(arg2, "strong")) {
      printf_to_char(ch, "You feel negatively preoccupied with the prospect of %s.\n\r", argument);
      char logbuf[MSL];
      sprintf(logbuf, "You feel negatively preoccupied with the prospect of %s.\n\r", argument);
      char_rplog(ch, logbuf);

      if (is_suffer_sensitive(victim)) {
        sprintf(buf, "You want to manifest $N's dread of %s.\n\r", argument);
        act(buf, victim, NULL, ch, TO_CHAR);
      }
      sprintf(buf, "(to %s)feels a strong dread of %s.", NAME(victim), argument);
      spyshow(ch, buf);

    }
    else
    send_to_char("Syntax: dread mild/moderate/strong (dread description) Or dread (person) mild/moderate/strong (dread description)\n\r", ch);
  }

  bool seems_suggestible(CHAR_DATA *ch) {

    if (event_cleanse == 1)
    return FALSE;

    if (get_skill(ch, SKILL_MIMIC) > 0) {
      if (get_app_race(ch) == RACE_NEWANGELBORN || get_app_race(ch) == RACE_VETANGELBORN || get_app_race(ch) == RACE_OLDANGELBORN || get_app_race(ch) == RACE_FREEANGEL)
      return TRUE;
      else
      return FALSE;
    }

    if (seems_angelborn(ch))
    return TRUE;

    if (!seems_super(ch) && event_dominance == 1)
    return TRUE;

    if (!is_suggestible(ch))
    return FALSE;

    if (get_skill(ch, SKILL_OBFUSCATE) > 0)
    return FALSE;

    return TRUE;
  }

  bool seems_faeborn(CHAR_DATA *ch) {
    if (event_cleanse == 1)
    return FALSE;

    if (get_skill(ch, SKILL_MIMIC) > 0) {
      if (get_app_race(ch) == RACE_NEWFAEBORN || get_app_race(ch) == RACE_VETFAEBORN || get_app_race(ch) == RACE_OLDFAEBORN || get_app_race(ch) == RACE_FAECHILD || get_app_race(ch) == RACE_SPIRIT_FAE)
      return TRUE;
      else
      return FALSE;
    }

    if (!is_faeborn(ch))
    return FALSE;

    if (get_skill(ch, SKILL_OBFUSCATE) > 0)
    return FALSE;

    return TRUE;
  }

  bool seems_angelborn(CHAR_DATA *ch) {
    if (event_cleanse == 1)
    return FALSE;

    if (get_skill(ch, SKILL_MIMIC) > 0) {
      if (get_app_race(ch) == RACE_NEWANGELBORN || get_app_race(ch) == RACE_VETANGELBORN || get_app_race(ch) == RACE_OLDANGELBORN || get_app_race(ch) == RACE_FREEANGEL)
      return TRUE;
      else
      return FALSE;
    }

    if (!is_angelborn(ch))
    return FALSE;

    if (get_skill(ch, SKILL_OBFUSCATE) > 0)
    return FALSE;

    return TRUE;
  }

  bool seems_demigod(CHAR_DATA *ch) {
    if (event_cleanse == 1)
    return FALSE;

    if (get_skill(ch, SKILL_MIMIC) > 0) {
      if (get_app_race(ch) == RACE_NEWDEMIGOD || get_app_race(ch) == RACE_VETDEMIGOD || get_app_race(ch) == RACE_OLDDEMIGOD || get_app_race(ch) == RACE_GODCHILD || get_app_race(ch) == RACE_SPIRIT_DIVINE)
      return TRUE;
      else
      return FALSE;
    }

    if (!is_demigod(ch))
    return FALSE;

    if (get_skill(ch, SKILL_OBFUSCATE) > 0)
    return FALSE;

    return TRUE;
  }

  bool seems_demonborn(CHAR_DATA *ch) {
    if (event_cleanse == 1)
    return FALSE;

    if (get_skill(ch, SKILL_MIMIC) > 0) {
      if (get_app_race(ch) == RACE_NEWDEMONBORN || get_app_race(ch) == RACE_VETDEMONBORN || get_app_race(ch) == RACE_OLDDEMONBORN || get_app_race(ch) == RACE_DEMIDEMON || get_app_race(ch) == RACE_SPIRIT_DEMON)
      return TRUE;
      else
      return FALSE;
    }

    if (!is_demonborn(ch) || (is_demonborn(ch) && pact_holder(ch)))
    return FALSE;

    if (get_skill(ch, SKILL_OBFUSCATE) > 0)
    return FALSE;

    return TRUE;
  }
  bool seems_vampire(CHAR_DATA *ch) {
    if (event_cleanse == 1)
    return FALSE;

    if (get_skill(ch, SKILL_MIMIC) > 0) {
      if (get_app_race(ch) == RACE_NEWVAMPIRE || get_app_race(ch) == RACE_VETVAMPIRE || get_app_race(ch) == RACE_OLDVAMPIRE || get_app_race(ch) == RACE_ANCIENTVAMPIRE)
      return TRUE;
      else
      return FALSE;
    }

    if (!is_vampire(ch))
    return FALSE;

    if (get_skill(ch, SKILL_OBFUSCATE) > 0)
    return FALSE;

    return TRUE;
  }
  bool seems_werewolf(CHAR_DATA *ch) {
    if (event_cleanse == 1)
    return FALSE;

    if (get_skill(ch, SKILL_MIMIC) > 0) {
      if (get_app_race(ch) == RACE_NEWWEREWOLF || get_app_race(ch) == RACE_VETWEREWOLF || get_app_race(ch) == RACE_OLDWEREWOLF || get_app_race(ch) == RACE_ANCIENTWEREWOLF)
      return TRUE;
      else
      return FALSE;
    }

    if (!is_werewolf(ch))
    return FALSE;

    if (get_skill(ch, SKILL_OBFUSCATE) > 0)
    return FALSE;

    return TRUE;
  }

  int pc_anima_value(CHAR_DATA *ch) {
    int val = base_lifeforce(ch) - 8000;
    val = UMIN(val, 1000);

    if (IS_AFFECTED(ch, AFF_DRAINED))
    return 0;
    if (IS_AFFECTED(ch, AFF_BITTEN))
    val /= 2;

    if (IS_AFFECTED(ch, AFF_ABDUCTED))
    val /= 5;

    if (ch->played / 3600 < 50)
    val /= 4;

    if (ch->faction == 0)
    val /= 2;

    if (ch->pcdata->selfbondage == 1)
    val /= 5;
    else if (!IS_FLAG(ch->act, PLR_BOUND))
    val /= 5;

    return val;
  }

  int abom_anima_value(CHAR_DATA *ch) {
    if (!is_abom(ch))
    return 0;

    int val = 1000;

    val += ch->spentexp / 400;
    val += ch->spentrpexp / 100;

    if (IS_AFFECTED(ch, AFF_ABDUCTED))
    val /= 2;

    if (ch->pcdata->selfbondage == 1)
    val /= 3;

    val /= 50;

    return val;
  }

  _DOFUN(do_shadowwalk)
  {

    if(!free_to_act(ch) || in_fight(ch) || is_helpless(ch) || is_pinned(ch) || room_hostile(ch->in_room) || locked_room(ch->in_room, ch) || clinic_patient(ch))
    {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if(ch->pcdata->shadow_walk_room < 1)
    {
      send_to_char("You'd have to use the shadowalk ritual first.\n\r", ch);
      return;
    }
    if(ch->pcdata->shadow_walk_cooldown > current_time)
    {
      send_to_char("You did that too recently\n\r", ch);
      return;
    }
    ROOM_INDEX_DATA *desti = get_room_index(ch->pcdata->shadow_walk_room);
    ROOM_INDEX_DATA *origin = ch->in_room;
    if(desti == NULL)
    {
      send_to_char("You'd have to use the shadowalk ritual first.\n\r", ch);
      return;
    }
    if(desti->area->world != origin->area->world && origin->area->vnum != DIST_MISTS)
    {
      send_to_char("You cannot cross worlds in that fashion.\n\r", ch);
      return;
    }
    act("$n steps into the shadows and disappears.", ch, NULL, NULL, TO_ROOM);
    char_from_room(ch);
    char_to_room(ch, desti);
    act("$n steps out of the shadows.", ch, NULL, NULL, TO_ROOM);
    act("You step out of the shadows.", ch, NULL, NULL, TO_CHAR);
    CHAR_DATA *to;
    for (DescList::iterator it = descriptor_list.begin();
    it != descriptor_list.end(); ++it) {
      DESCRIPTOR_DATA *d = *it;
      if (d != NULL && d->character != NULL && d->connected == CON_PLAYING) {
        to = d->character;

        if (to == NULL)
        continue;
        if (IS_NPC(to))
        continue;

        if(to->in_room == origin && (ch->dragging == to || ch->lifting == to))
        {
          char_from_room(to);
          char_to_room(to, desti);
        }
      }
    }
    ch->pcdata->shadow_walk_cooldown = current_time + (3600 * 24);
  }

  _DOFUN(do_fish) {
    if (!free_to_act(ch)) {
      send_to_char("You cannot do that.\n\r", ch);
      return;
    }
    if (!nearby_water(ch)) {
      send_to_char("There's no water near you.\n\r", ch);
      return;
    }
    ch->pcdata->process = PROCESS_FISH;
    ch->pcdata->process_timer = number_range(5, 30);
    act("You cast a line.", ch, NULL, NULL, TO_CHAR);
    act("$n casts a line.", ch, NULL, NULL, TO_ROOM);
  }

  _DOFUN(do_harvest) {
    CHAR_DATA *victim;
    if ((victim = get_char_room(ch, NULL, argument)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (is_ghost(ch)) {
      send_to_char("Slaying the living is no longer so simple./n/r", ch);
      return;
    }

    if (is_ghost(victim)) {
      send_to_char("Slaying a ghost is not so simple./n/r", ch);
      return;
    }

    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (!is_helpless(victim)) {
      send_to_char("You'd have to subdue them first.\n\r", ch);
      return;
    }
    if (!IS_FLAG(victim->act, PLR_BOUND)) {
      send_to_char("They have to be tied up first.\n\r", ch);
      return;
    }

    if (!harvesting_room(ch->in_room)) {
      send_to_char("You need to be in a harvesting facility to do that.\n\r", ch);
      return;
    }

    ch->pcdata->process = PROCESS_DRAINPC;
    ch->pcdata->process_timer = 2;
    ch->pcdata->process_target = victim;
    act("You start the process of draining $N.", ch, NULL, victim, TO_CHAR);
    act("$n starts the process of draining you.", ch, NULL, victim, TO_VICT);
    act("$n starts the process of draining $N.", ch, NULL, victim, TO_NOTVICT);
  }

  int chainsaw_bonus(CHAR_DATA *ch) {
    OBJ_DATA *obj;
    obj = get_eqr_char(ch, WEAR_HOLD);
    if (obj != NULL) {
      if (is_name("chainsaw", obj->name))
      return 40;
      else if (is_name("axe", obj->name))
      return 20;
    }
    obj = get_eq_char(ch, WEAR_HOLD_2);
    if (obj != NULL) {
      if (is_name("chainsaw", obj->name))
      return 40;
      else if (is_name("axe", obj->name))
      return 20;
    }
    return 0;
  }
  void conclude_process(CHAR_DATA *ch, int type) {
    OBJ_DATA *obj;
    char buf[MSL];

    ch->pcdata->last_develop_type = 0;
    ch->pcdata->last_develop_time = 0;

    if (type == PROCESS_TRAVEL_PREP) {
      ch->pcdata->travel_prepped = TRUE;
      do_function(ch, &do_travel, ch->pcdata->process_argumentone);
      return;
    }
    if (type == PROCESS_FISH) {
      ch->pcdata->process = 0;
      if (!nearby_water(ch)) {
        send_to_char("You are no longer near water.\n\r", ch);
        return;
      }
      switch (number_percent() % 24) {
      case 1:
        sprintf(buf, "Acadian redfish");
        break;
      case 2:
        sprintf(buf, "Alewife fish");
        break;
      case 3:
        sprintf(buf, "American dab");
        break;
      case 4:
        sprintf(buf, "American eel");
        break;
      case 5:
        sprintf(buf, "Atlantic blue marlin");
        break;
      case 6:
        sprintf(buf, "Atlantic bonito");
        break;
      case 7:
        sprintf(buf, "Atlantic cod");
        break;
      case 8:
        sprintf(buf, "Atlantic halibut");
        break;
      case 9:
        sprintf(buf, "Atlantic herring");
        break;
      case 10:
        sprintf(buf, "Atlantic mackerel");
        break;
      case 11:
        sprintf(buf, "Atlantic menhaden");
        break;
      case 12:
        sprintf(buf, "Black sea bass");
        break;
      case 13:
        sprintf(buf, "Blue shark");
        break;
      case 14:
        sprintf(buf, "Bluefin tuna");
        break;
      case 15:
        sprintf(buf, "Bluefish");
        break;
      case 16:
        sprintf(buf, "Cusk fish");
        break;
      case 17:
        sprintf(buf, "Haddock");
        break;
      case 18:
        sprintf(buf, "Monkfish");
        break;
      case 19:
        sprintf(buf, "Rainbow smelt");
        break;
      case 20:
        sprintf(buf, "Scup");
        break;
      case 21:
        sprintf(buf, "Striped bass");
        break;
      case 22:
        sprintf(buf, "Summer flounder");
        break;
      case 23:
        sprintf(buf, "Tautog");
        break;
      case 0:
      default:
        sprintf(buf, "Yellowfin tuna");
        break;
      }
      char tmp[MSL];
      obj = create_object(get_obj_index(45250), 0);
      free_string(obj->short_descr);
      obj->short_descr = str_dup(buf);
      free_string(obj->description);
      sprintf(tmp, "%s %s", a_or_an(buf), buf);
      obj->description = str_dup(tmp);
      free_string(obj->name);
      sprintf(tmp, "fish food %s", buf);
      obj->name = str_dup(tmp);
      obj_to_char(obj, ch);
      sprintf(tmp, "You catch %s.", obj->description);
      act(tmp, ch, NULL, NULL, TO_CHAR);
      sprintf(tmp, "$n catches %s.", obj->description);
      act(tmp, ch, NULL, NULL, TO_ROOM);
      return;
    }
    if (type == PROCESS_RITUAL) {
      CHAR_DATA *victim = NULL;
      bool online = FALSE;
      int power = 100;
      if (targeted_ritual_vnum(ch->pcdata->process_subtype)) {
        DESCRIPTOR_DATA d;
        struct stat sb;
        Buffer outbuf;
        d.original = NULL;
        if ((victim = get_char_world_pc(ch->pcdata->process_argumentone)) !=
            NULL) // Victim is online.
        online = TRUE;
        else {
          log_string("DESCRIPTOR: Finish Ritual");

          if (!load_char_obj(&d, ch->pcdata->process_argumentone)) {
            send_to_char("You can't find them.\n\r", ch);
            return;
          }

          sprintf(buf, "%s%s", PLAYER_DIR, capitalize(ch->pcdata->process_argumentone));
          stat(buf, &sb);
          victim = d.character;
        }
        if (IS_NPC(victim)) {
          send_to_char("You can't find them.\n\r", ch);
          if (!online)
          free_char(victim);
          return;
        }
        if (str_cmp(ch->name, "Ritualist") && in_world(ch) != in_world(victim) && !higher_power(victim)) {
          send_to_char("You can't find them.\n\r", ch);
          if (!online)
          free_char(victim);
          return;
        }
      }

      int st = ch->pcdata->process_subtype;
      int cost = ritual_cost(ch, ch->pcdata->process_subtype, victim);
      if (st != RITUAL_SHADOWCLOAK && st != RITUAL_CLEANSE && st != RITUAL_SANCTUARY && st != RITUAL_SCRY && st != RITUAL_PROTECT && st != RITUAL_RAISEWARD && st != RITUAL_UNBINDING && st != RITUAL_MINDWARD && st != RITUAL_SACRIFICE && st != RITUAL_SHROUDSHIELD && st != RITUAL_AGETHEFT && st != RITUAL_TRACE && st != RITUAL_ENCROACHMENT && (st < RITUAL_FREEZETIME || st > RITUAL_NATURALIZEWEATHER)) {
        villain_mod(ch, 20, "Ritual");
        if (victim != NULL && is_weakness(ch, victim))
        cost /= 5;
      }
      if (victim != NULL && !IS_NPC(victim) && st != RITUAL_SCRY && st != RITUAL_TRACE) {
        free_string(victim->pcdata->last_ritual);
        victim->pcdata->last_ritual = str_dup(ch->name);
      }
      if (ch->pcdata->process_subtype == RITUAL_TRACE) {
        power = ritual_debuff_power(ch, victim);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);
        printf_to_char(ch, "%s comes into view in your scrying implement.\n\r", victim->pcdata->last_ritual);
        if (str_cmp(victim->pcdata->last_ritual, victim->pcdata->ritual_maintainer) && safe_strlen(victim->pcdata->ritual_maintainer) > 1)
        printf_to_char(ch, "%s comes into view in your scrying implement.\n\r", victim->pcdata->ritual_maintainer);

        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_SUMMONING) {
        if (!higher_power(victim)) {
          send_to_char("Your spell fails.\n\r", ch);
          return;
        }
        if (!online) {
          send_to_char("Your spell fails.\n\r", ch);
          free_char(victim);
          victim = NULL;
          return;
        }
        if (victim->pcdata->summon_bound < 0) {
          send_to_char("Your spell fails.\n\r", ch);
          return;
        }
        if (victim->in_room == NULL || victim->in_room->vnum <= 300) {
          send_to_char("Your spell fails.\n\r", ch);
          return;
        }
        if (higher_power(victim))
        security_wipeout(victim->name);

        power = ritual_debuff_power(ch, victim);
        char_from_room(victim);
        char_to_room(victim, ch->in_room);
        free_string(victim->pcdata->place);
        victim->pcdata->place = str_dup("binding circle");
        victim->pcdata->summon_bound = power;
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);
      }
      if (ch->pcdata->process_subtype == RITUAL_IMPRINT) {
        power = ritual_debuff_power(ch, victim);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);
        auto_imprint_timed(victim, ch->pcdata->process_argumenttwo, IMPRINT_INFLUENCE, power * 3);
        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_IMPRINTBODY) {
        power = ritual_debuff_power(ch, victim);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);
        auto_imprint_timed(victim, ch->pcdata->process_argumenttwo, IMPRINT_BODYCOMPULSION, power * 3);
        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }

      if (ch->pcdata->process_subtype == RITUAL_SEXCHANGE) {
        if (ch == victim)
        cost /= 2;
        if (is_faeborn(victim))
        cost /= 2;
        power = ritual_debuff_power(ch, victim);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);
        if (victim->pcdata->sexchange_time <= 0) {
          if (victim->pcdata->penis > 0) {
            victim->pcdata->truepenis = victim->pcdata->penis;
            victim->pcdata->penis = 0;
          }
          else {
            victim->pcdata->truepenis = victim->pcdata->penis;
            victim->pcdata->penis = 70;
          }
          if (victim->pcdata->bust > 0) {
            victim->pcdata->truebreasts = victim->pcdata->bust;
            victim->pcdata->bust = 0;
          }
          else {
            victim->pcdata->truebreasts = victim->pcdata->bust;
            victim->pcdata->bust = number_range(3, 8);
          }
          if (!str_cmp(ch->pcdata->maintained_target, "casting")) {
            victim->pcdata->maintained_ritual = ch->pcdata->process_subtype;
            free_string(victim->pcdata->ritual_maintainer);
            victim->pcdata->ritual_maintainer = str_dup(ch->name);
            free_string(ch->pcdata->maintained_target);
            ch->pcdata->maintained_target = str_dup(victim->name);
            cost /= 2;
            victim->pcdata->sexchange_time = 2;
          }
          else
          victim->pcdata->sexchange_time = power * 3;
        }
        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
        else
        send_to_char("Your body tingles.\n\r", victim);
      }
      if (ch->pcdata->process_subtype == RITUAL_PREDATE) {
        power = ritual_debuff_power(ch, victim);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);
        victim->pcdata->ritual_prey_timer = power*3;
        free_string(victim->pcdata->ritual_prey_target);
        victim->pcdata->ritual_prey_target = str_dup(ch->name);
        if (!str_cmp(ch->pcdata->maintained_target, "casting")) {
          victim->pcdata->maintained_ritual = ch->pcdata->process_subtype;
          free_string(victim->pcdata->ritual_maintainer);
          victim->pcdata->ritual_maintainer = str_dup(ch->name);
          free_string(ch->pcdata->maintained_target);
          ch->pcdata->maintained_target = str_dup(victim->name);
          cost /= 2;
          victim->pcdata->ritual_prey_timer = power*2;
          free_string(victim->pcdata->ritual_prey_target);
          victim->pcdata->ritual_prey_target = str_dup(ch->name);
        }
        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_DREAMBELIEF) {
        power = ritual_debuff_power(ch, victim);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);
        if (!str_cmp(ch->pcdata->maintained_target, "casting")) {
          victim->pcdata->maintained_ritual = ch->pcdata->process_subtype;
          free_string(victim->pcdata->ritual_maintainer);
          victim->pcdata->ritual_maintainer = str_dup(ch->name);
          free_string(ch->pcdata->maintained_target);
          ch->pcdata->maintained_target = str_dup(victim->name);
          cost /= 2;
          victim->pcdata->dream_identity_timer = 2;
        }
        else
        victim->pcdata->dream_identity_timer = power * 3;
        free_string(victim->pcdata->identity_world);
        victim->pcdata->identity_world = str_dup(ch->pcdata->ritual_dreamworld);
        free_string(victim->pcdata->dream_identity);
        victim->pcdata->dream_identity = str_dup("");
        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_DREAMIDENTITY) {
        power = ritual_debuff_power(ch, victim);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);
        if (!str_cmp(ch->pcdata->maintained_target, "casting")) {
          victim->pcdata->maintained_ritual = ch->pcdata->process_subtype;
          free_string(victim->pcdata->ritual_maintainer);
          victim->pcdata->ritual_maintainer = str_dup(ch->name);
          free_string(ch->pcdata->maintained_target);
          ch->pcdata->maintained_target = str_dup(victim->name);
          cost /= 2;
          victim->pcdata->dream_identity_timer = 2;
        }
        else
        victim->pcdata->dream_identity_timer = power * 3;
        free_string(victim->pcdata->identity_world);
        victim->pcdata->identity_world = str_dup(ch->pcdata->ritual_dreamworld);
        free_string(victim->pcdata->dream_identity);
        victim->pcdata->dream_identity = str_dup(ch->pcdata->process_argumenttwo);
        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_SACRIFICE) {
        power = ritual_buff_power(ch);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);
        if (ch->pcdata->apparant_age < 5)
        give_lifeforce(ch, 1000 * power / 100, "sacrifice ritual");
        ch->pcdata->deaged -= 720 * power / 100;
        return;
      }
      if (ch->pcdata->process_subtype == RITUAL_AGETHEFT) {
        power = ritual_debuff_power(ch, victim);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (victim->played / 3600 < 100) {
          send_to_char("They're too new to this location, your spell fails to latch on.\n\r", ch);
          return;
        }
        int diff = get_age(ch) - get_age(victim);
        diff *= 4;
        if (ch->in_room == victim->in_room)
        diff *= 3;
        if (get_tier(victim) == 1)
        diff /= 2;
        if (diff > 0) {
          ch->pcdata->deaged += diff;
          victim->pcdata->deaged -= diff;
        }
        sprintf(buf, "AGETHEFT: %s steals %d from %s.", ch->name, diff, victim->name);
        log_string(buf);
        if (ch->in_room != victim->in_room && number_percent() % 3 == 0) {
          sprintf(
          buf, "You have a horrible dream about a figure looking like %s pinning you down and sucking the air from your body in a stream.\n\r", get_intro(ch));
          free_string(victim->pcdata->nightmare);
          victim->pcdata->nightmare = str_dup(buf);
        }
        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_SLEEPWALK) {
        power = ritual_debuff_power(ch, victim);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        bool walker = FALSE;
        if (is_dreaming(victim) && !is_gm(victim) && victim->in_room != NULL && !IS_FLAG(victim->comm, COMM_AFK) && victim->desc != NULL && !locked_room(victim->in_room, victim) && !IS_FLAG(victim->act, PLR_BOUND) && !IS_FLAG(victim->act, PLR_BOUNDFEET) && in_haven(victim->in_room)) {
          walker = TRUE;
        }
        else if (!is_gm(victim) && victim->in_room != NULL && !IS_FLAG(victim->comm, COMM_AFK) && !is_helpless(victim) && !in_fight(victim) && !IS_FLAG(victim->act, PLR_DEAD) && victim->desc != NULL && !locked_room(victim->in_room, victim) && in_haven(victim->in_room)) {
          if ((victim->pcdata->time_since_action > 30 * 100 / power && pc_pop(victim->in_room) < 2) || victim->pcdata->time_since_action > 90 * 100 / power) {
            walker = TRUE;
          }
        }
        if (walker == TRUE) {
          int mindist = 1000;
          int minpointer = 0;
          for (int i = 0; i < MAX_TAXIS; i++) {
            if (get_dist(get_roomx(victim->in_room), get_roomy(victim->in_room), get_roomx(get_room_index(taxi_table[i].vnum)), get_roomy(get_room_index(taxi_table[i].vnum))) < mindist)
            ;
            {
              minpointer = i;
              mindist =
              get_dist(get_roomx(victim->in_room), get_roomy(victim->in_room), get_roomx(get_room_index(taxi_table[i].vnum)), get_roomy(get_room_index(taxi_table[i].vnum)));
            }
          }

          int f = taxi_table[minpointer].vnum;
          int xmod = number_range(-2, 2);
          int ymod = number_range(-2, 2);
          ymod *= 1000;
          ROOM_INDEX_DATA *to_room;
          if ((to_room = get_room_index(f + xmod + ymod)) != NULL) {
            act("$n wanders off in a daze.", victim, NULL, NULL, TO_ROOM);
            dact("$n wanders off in a daze.", victim, NULL, NULL, DISTANCE_MEDIUM);
            char_from_room(victim);
            char_to_room(victim, to_room);
            act("$n wanders in in a daze.", victim, NULL, NULL, TO_ROOM);
            dact("$n wanders in in a daze.", victim, NULL, NULL, DISTANCE_MEDIUM);
          }
          else {
            to_room = get_room_index(f);
            act("$n wanders off in a daze.", victim, NULL, NULL, TO_ROOM);
            dact("$n wanders off in a daze.", victim, NULL, NULL, DISTANCE_MEDIUM);
            char_from_room(victim);
            char_to_room(victim, to_room);
            act("$n wanders in in a daze.", victim, NULL, NULL, TO_ROOM);
            dact("$n wanders in in a daze.", victim, NULL, NULL, DISTANCE_MEDIUM);
          }

          free_string(victim->pcdata->title);
          victim->pcdata->title = str_dup(" is wandering in a daze");
        }
        else {
          send_to_char("The spell fails.\n\r", ch);
          return;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_SILENCE) {
        power = ritual_debuff_power(ch, victim);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (in_prop(victim) != NULL && !is_base(in_prop(victim)) && in_prop(victim)->blackout == 0) {
          in_prop(victim)->blackout = 18 * power / 100;

          CHAR_DATA *to;

          for (DescList::iterator it = descriptor_list.begin();
          it != descriptor_list.end(); ++it) {
            DESCRIPTOR_DATA *d = *it;

            if (d != NULL && d->character != NULL && d->connected == CON_PLAYING) {
              to = d->character;
              if (to == NULL)
              continue;
              if (IS_NPC(to))
              continue;
              if (in_prop(to) == in_prop(victim))
              send_to_char("`DThe power goes out.`x\n\r", to);
            }
          }
        }

        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_DECAY) {
        power = ritual_buff_power(ch);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (in_prop(victim) != NULL) {
          in_prop(victim)->decay += power;
        }

        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_SHROUDSHIELD) {
        power = ritual_buff_power(ch);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (in_prop(victim) != NULL) {
          in_prop(victim)->shroudshield =
          UMIN(250, in_prop(victim)->shroudshield + power);
        }
        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_SHIELDBREAK) {
        power = ritual_buff_power(ch);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (in_prop(victim) != NULL) {
          in_prop(victim)->shroudshield =
          UMAX(0, in_prop(victim)->shroudshield - power);
        }

        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_NATURALIZETIME) {
        power = ritual_buff_power(ch);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (in_prop(victim) != NULL) {
          in_prop(victim)->timefrozen = 0;
          in_prop(victim)->timeshift = 0;
        }
        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_NATURALIZEWEATHER) {
        power = ritual_buff_power(ch);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (in_prop(victim) != NULL) {
          in_prop(victim)->weather = 0;
          in_prop(victim)->tempfrozen = 0;
          in_prop(victim)->tempshift = 0;
        }
        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_LOCALIZEDWEATHER) {
        power = ritual_buff_power(ch);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (in_prop(victim) != NULL) {
          if (!str_cmp(ch->pcdata->process_argumenttwo, "clear"))
          in_prop(victim)->weather = PROPWEATHER_CLEAR;
          else if (!str_cmp(ch->pcdata->process_argumenttwo, "cloudy"))
          in_prop(victim)->weather = PROPWEATHER_CLOUDY;
          else if (!str_cmp(ch->pcdata->process_argumenttwo, "rain"))
          in_prop(victim)->weather = PROPWEATHER_RAIN;
          else if (!str_cmp(ch->pcdata->process_argumenttwo, "snow"))
          in_prop(victim)->weather = PROPWEATHER_SNOW;
          else if (!str_cmp(ch->pcdata->process_argumenttwo, "hail"))
          in_prop(victim)->weather = PROPWEATHER_HAIL;
        }
        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_TEMPERATURESHIFT) {
        power = ritual_buff_power(ch);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (in_prop(victim) != NULL) {
          int hour = atoi(ch->pcdata->process_argumenttwo);
          if (hour < 100 && hour > -100)
          in_prop(victim)->tempshift = hour;
        }
        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_FREEZETEMPERATURE) {
        power = ritual_buff_power(ch);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (in_prop(victim) != NULL) {
          int hour = atoi(ch->pcdata->process_argumenttwo);
          if (hour > -50 && hour < 150)
          in_prop(victim)->tempfrozen = hour;
        }
        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_TIMESHIFT) {
        power = ritual_buff_power(ch);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (in_prop(victim) != NULL) {
          int hour = atoi(ch->pcdata->process_argumenttwo);
          if (hour < 24 && hour > -24)
          in_prop(victim)->timeshift = hour;
        }
        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_FREEZETIME) {
        power = ritual_buff_power(ch);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (in_prop(victim) != NULL) {
          int hour = atoi(ch->pcdata->process_argumenttwo);
          if (hour < 24 && hour > 0)
          in_prop(victim)->timefrozen = hour;
        }
        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }

      if (ch->pcdata->process_subtype == RITUAL_ENCROACHMENT) {
        power = ritual_buff_power(ch);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        PROP_TYPE *prop = in_prop(victim);
        if(prop == NULL)
        {
          send_to_char("They are not in a property.\n\r", ch);
          if (!online) {
            free_char(victim);
            victim = NULL;
          }

          return;
        }
        if(prop->last_encroach > current_time - (3600*24*5))
        {
          send_to_char("A property can only be targeted by this ritual once every five days.\n\r", ch);
          if (!online) {
            free_char(victim);
            victim = NULL;
          }

          return;
        }
        prop->last_encroach = current_time;
        encroach_property(prop);
        save_char_obj(victim, FALSE, FALSE);
        save_properties(FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }

      if (ch->pcdata->process_subtype == RITUAL_CLOAKING) {
        power = ritual_buff_power(ch);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (in_prop(victim) != NULL && !is_base(in_prop(victim)) && in_prop(victim)->blackout == 0) {
          in_prop(victim)->cloaked += power;
        }

        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_SHADOWCLOAK) {
        power = ritual_debuff_power(ch, victim);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);
        if (!IS_FLAG(victim->comm, COMM_SHADOWCLOAK))
        SET_FLAG(victim->comm, COMM_SHADOWCLOAK);

        save_char_obj(victim, FALSE, FALSE);
        if (!online)
        free_char(victim);
      }
      if (ch->pcdata->process_subtype == RITUAL_CLEANSE) {
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);
        OBJ_DATA *obj;
        OBJ_DATA *obj_next;

        for (obj = ch->carrying; obj != NULL; obj = obj_next) {
          obj_next = obj->next_content;
          if (IS_SET(obj->extra_flags, ITEM_WARDROBE))
          continue;
          if (IS_SET(obj->extra_flags, ITEM_CURSED))
          REMOVE_BIT(obj->extra_flags, ITEM_CURSED);
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_DREAM) {
        FANTASY_TYPE *fant = NULL;
        for (vector<FANTASY_TYPE *>::iterator it = FantasyVect.begin();
        it != FantasyVect.end(); ++it) {
          if ((*it)->valid == FALSE || (*it)->active == FALSE) {
            continue;
          }
          if (!str_cmp((*it)->name, ch->pcdata->ritual_dreamworld)) {
            fant = (*it);
          }
        }
        if (fant == NULL)
        return;
        if (guestmonster(victim) || higher_power(victim)) {
          return;
        }

        char buf[MSL];
        sprintf(buf, "suspended%s", victim->name);
        bool suspended = FALSE;
        for (int i = 0; i < 200; i++) {
          if (!str_cmp(buf, fant->participants[i]))
          suspended = TRUE;
        }
        if (suspended == TRUE) {
          for (int i = 0; i < 200; i++) {
            if (!str_cmp(victim->name, fant->participants[i])) {
              free_string(fant->participants[i]);
              fant->participants[i] = str_dup("");
            }
          }
        }
        else {
          for (int i = 0; i < 200; i++) {
            if (!str_cmp(victim->name, fant->participants[i])) {
              free_string(fant->participants[i]);
              fant->participants[i] = str_dup(buf);
            }
          }
        }
        if (IS_FLAG(victim->act, PLR_SHROUD) && victim->pcdata->spectre == 0)
        enter_dreamworld(victim, fant);
        else if (victim->pcdata->spectre == 0) {
          to_spectre(victim, FALSE);
          enter_dreamworld(victim, fant);
        }
        else
        enter_dreamworld(victim, fant);

        to_spectre(ch, FALSE);
        enter_dreamworld(ch, fant);
        int point = -1;
        for (int i = 0; i < 200; i++) {
          if (!str_cmp(victim->name, fant->participants[i]))
          point = i;
        }
        gain_dexp(victim, 10);
        victim->pcdata->dream_room = ch->pcdata->dream_room;
        ch->pcdata->tempdreamgodworld = fantasy_number(fant);
        ch->pcdata->tempdreamgodchar = point;
        villain_mod(ch, 10, "Dream invasion");
        if (!online)
        cost /= 2;
        power = ritual_debuff_power(ch, victim);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);
        send_to_char("You invade their dreams, use 'wake' to leave the dream early.\n\r", ch);
        send_to_char("You fall asleep.\n\r", victim);
        act("$n falls asleep.", ch, NULL, NULL, TO_ROOM);
        act("$n falls asleep.", victim, NULL, NULL, TO_ROOM);
        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_DREAMSNARE) {
        FANTASY_TYPE *fant = NULL;
        for (vector<FANTASY_TYPE *>::iterator it = FantasyVect.begin();
        it != FantasyVect.end(); ++it) {
          if ((*it)->valid == FALSE || (*it)->active == FALSE) {
            continue;
          }
          if (!str_cmp((*it)->name, ch->pcdata->ritual_dreamworld)) {
            fant = (*it);
          }
        }
        if (guestmonster(victim) || higher_power(victim)) {
          return;
        }
        if (fant == NULL)
        return;
        char buf[MSL];
        sprintf(buf, "suspended%s", victim->name);
        bool suspended = FALSE;
        for (int i = 0; i < 200; i++) {
          if (!str_cmp(buf, fant->participants[i]))
          suspended = TRUE;
        }
        if (suspended == TRUE) {
          for (int i = 0; i < 200; i++) {
            if (!str_cmp(victim->name, fant->participants[i])) {
              free_string(fant->participants[i]);
              fant->participants[i] = str_dup("");
            }
          }
        }
        else {
          for (int i = 0; i < 200; i++) {
            if (!str_cmp(victim->name, fant->participants[i])) {
              free_string(fant->participants[i]);
              fant->participants[i] = str_dup(buf);
            }
          }
        }
        if (IS_FLAG(victim->act, PLR_SHROUD) && victim->pcdata->spectre == 0)
        enter_dreamworld(victim, fant);
        else if (victim->pcdata->spectre == 0) {
          to_spectre(victim, FALSE);
          enter_dreamworld(victim, fant);
        }
        else
        enter_dreamworld(victim, fant);

        to_spectre(ch, FALSE);
        enter_dreamworld(ch, fant);
        int point = -1;
        for (int i = 0; i < 200; i++) {
          if (!str_cmp(victim->name, fant->participants[i]))
          point = i;
        }
        victim->pcdata->dream_room = ch->pcdata->dream_room;
        ch->pcdata->tempdreamgodworld = fantasy_number(fant);
        ch->pcdata->tempdreamgodchar = point;
        villain_mod(ch, 10, "Dream invasion");
        if (!online)
        cost /= 2;
        gain_dexp(victim, 10);
        power = ritual_debuff_power(ch, victim);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);
        send_to_char("You invade their dreams, use 'wake' to leave the dream early.\n\r", ch);
        send_to_char("You fall asleep.\n\r", victim);
        act("$n falls asleep.", ch, NULL, NULL, TO_ROOM);
        act("$n falls asleep.", victim, NULL, NULL, TO_ROOM);
        if (!IS_FLAG(victim->comm, COMM_DREAMSNARED))
        SET_FLAG(victim->comm, COMM_DREAMSNARED);
        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_SANCTUARY) {
        power = ritual_buff_power(ch);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        AFFECT_DATA af;
        af.where = TO_AFFECTS;
        af.type = 0;
        af.level = 10;
        af.duration = 12 * 60 * 24 * power / 100;
        af.location = APPLY_NONE;
        af.modifier = 0;
        af.caster = NULL;
        af.weave = FALSE;
        af.bitvector = AFF_UNDERSTANDING;
        affect_to_char(victim, &af);

        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_SCRY) {
        power = ritual_buff_power(ch);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (get_world(ch) != get_world(victim) || silenced(victim) || is_blind(victim) || (is_dark(victim->in_room) && !can_see_dark(victim)))
        printf_to_char(ch, "\nThrough %s's eyes you see darkness.\n\r", PERS(victim, ch));
        else {
          printf_to_char(ch, "\nThrough %s's eyes you see:\n\r", PERS(victim, ch));
          ROOM_INDEX_DATA *orig_room = ch->in_room;
          char_from_room(ch);
          char_to_room(ch, victim->in_room);
          do_function(ch, &do_look, "");
          char_from_room(ch);
          char_to_room(ch, orig_room);
        }

        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_MUTE) {
        power = ritual_debuff_power(ch, victim);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (get_skill(victim, SKILL_RITUALPROOF) <= 0) {
          AFFECT_DATA af;
          af.where = TO_AFFECTS;
          af.type = 0;
          af.level = 10;
          if (!str_cmp(ch->pcdata->maintained_target, "casting")) {
            victim->pcdata->maintained_ritual = ch->pcdata->process_subtype;
            free_string(victim->pcdata->ritual_maintainer);
            victim->pcdata->ritual_maintainer = str_dup(ch->name);
            free_string(ch->pcdata->maintained_target);
            ch->pcdata->maintained_target = str_dup(victim->name);
            cost /= 2;
            af.duration = 12 * 20;
          }
          else
          af.duration = 12 * 60 * 6 * power / 100;
          af.location = APPLY_NONE;
          af.modifier = 0;
          af.caster = NULL;
          af.weave = FALSE;
          af.bitvector = AFF_MUTE;
          affect_to_char(victim, &af);
        }

        send_to_char("You suddenly find yourself unable to speak.\n\r", victim);

        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_SHADOWALK) {
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);
        ch->pcdata->shadow_walk_room = ch->in_room->vnum;
        ch->pcdata->shadow_walk_cooldown = 0;
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_DREADWATCHER) {
        power = ritual_debuff_power(ch, victim);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (get_skill(victim, SKILL_RITUALPROOF) <= 0) {
          AFFECT_DATA af;
          af.where = TO_AFFECTS;
          af.type = 0;
          af.level = 10;
          if (!str_cmp(ch->pcdata->maintained_target, "casting")) {
            victim->pcdata->maintained_ritual = ch->pcdata->process_subtype;
            free_string(victim->pcdata->ritual_maintainer);
            victim->pcdata->ritual_maintainer = str_dup(ch->name);
            free_string(ch->pcdata->maintained_target);
            ch->pcdata->maintained_target = str_dup(victim->name);
            cost /= 2;
            af.duration = 12 * 20;
          }
          else
          af.duration = 12 * 60 * 6 * power / 100;
          af.location = APPLY_NONE;
          af.modifier = 0;
          af.caster = NULL;
          af.weave = FALSE;
          af.bitvector = AFF_SUFFER;
          affect_to_char(victim, &af);
        }

        send_to_char("You start finding the prospect of others pain more appealing.\n\r", victim);

        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_ILLNESS) {
        power = ritual_debuff_power(ch, victim);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (get_skill(victim, SKILL_RITUALPROOF) <= 0) {
          AFFECT_DATA af;
          af.where = TO_AFFECTS;
          af.type = 0;
          af.level = 10;
          if (!str_cmp(ch->pcdata->maintained_target, "casting")) {
            victim->pcdata->maintained_ritual = ch->pcdata->process_subtype;
            free_string(victim->pcdata->ritual_maintainer);
            victim->pcdata->ritual_maintainer = str_dup(ch->name);
            free_string(ch->pcdata->maintained_target);
            ch->pcdata->maintained_target = str_dup(victim->name);
            cost /= 2;
            af.duration = 12 * 20;
          }
          else
          af.duration = 12 * 60 * 6 * power / 100;
          af.location = APPLY_NONE;
          af.modifier = 0;
          af.caster = NULL;
          af.weave = FALSE;
          af.bitvector = AFF_ILLNESS;
          affect_to_char(victim, &af);
        }

        send_to_char("You start to feel unwell.\n\r", victim);

        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }

      if (ch->pcdata->process_subtype == RITUAL_ARTHRITIS) {
        power = ritual_debuff_power(ch, victim);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (get_skill(victim, SKILL_RITUALPROOF) <= 0) {
          AFFECT_DATA af;
          af.where = TO_AFFECTS;
          af.type = 0;
          af.level = 10;
          if (!str_cmp(ch->pcdata->maintained_target, "casting")) {
            victim->pcdata->maintained_ritual = ch->pcdata->process_subtype;
            free_string(victim->pcdata->ritual_maintainer);
            victim->pcdata->ritual_maintainer = str_dup(ch->name);
            free_string(ch->pcdata->maintained_target);
            ch->pcdata->maintained_target = str_dup(victim->name);
            cost /= 2;
            af.duration = 12 * 20;
          }
          else
          af.duration = 12 * 60 * 6 * power / 100;
          af.location = APPLY_NONE;
          af.modifier = 0;
          af.caster = NULL;
          af.weave = FALSE;
          af.bitvector = AFF_ARTHRITIS;
          affect_to_char(victim, &af);
        }

        send_to_char("Your joints start to ache.\n\r", victim);

        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_PURIFY) {
        power = ritual_buff_power(ch);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);
        free_string(victim->pcdata->last_sexed[0]);
        victim->pcdata->last_sexed[0] = str_dup("");
        free_string(victim->pcdata->last_sexed[1]);
        victim->pcdata->last_sexed[1] = str_dup("");
        free_string(victim->pcdata->last_sexed[2]);
        victim->pcdata->last_sexed[2] = str_dup("");

        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_TECHHEX) {
        power = ritual_debuff_power(ch, victim);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (get_skill(victim, SKILL_RITUALPROOF) <= 0) {
          AFFECT_DATA af;
          af.where = TO_AFFECTS;
          af.type = 0;
          af.level = 10;
          if (!str_cmp(ch->pcdata->maintained_target, "casting")) {
            victim->pcdata->maintained_ritual = ch->pcdata->process_subtype;
            free_string(victim->pcdata->ritual_maintainer);
            victim->pcdata->ritual_maintainer = str_dup(ch->name);
            free_string(ch->pcdata->maintained_target);
            ch->pcdata->maintained_target = str_dup(victim->name);
            cost /= 2;
            af.duration = 12 * 20;
          }
          else
          af.duration = 12 * 60 * 6 * power / 100;
          af.location = APPLY_NONE;
          af.modifier = 0;
          af.caster = NULL;
          af.weave = FALSE;
          af.bitvector = AFF_NOTECH;
          affect_to_char(victim, &af);
        }
        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_CORRUPT) {
        power = ritual_debuff_power(ch, victim);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (get_skill(victim, SKILL_RITUALPROOF) <= 0 && !mindwarded(victim)) {
          AFFECT_DATA af;
          af.where = TO_AFFECTS;
          af.type = 0;
          af.level = 10;
          if (!str_cmp(ch->pcdata->maintained_target, "casting")) {
            victim->pcdata->maintained_ritual = ch->pcdata->process_subtype;
            free_string(victim->pcdata->ritual_maintainer);
            victim->pcdata->ritual_maintainer = str_dup(ch->name);
            free_string(ch->pcdata->maintained_target);
            ch->pcdata->maintained_target = str_dup(victim->name);
            cost /= 2;
            af.duration = 12 * 20;
          }
          else
          af.duration = 12 * 60 * 6 * power / 100;
          af.location = APPLY_NONE;
          af.modifier = 0;
          af.caster = NULL;
          af.weave = FALSE;
          af.bitvector = AFF_TRIGGERED;
          affect_to_char(victim, &af);
        }
        do_function(victim, &do_imprint, "");
        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_LUNACY) {
        power = ritual_debuff_power(ch, victim);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (get_skill(victim, SKILL_RITUALPROOF) <= 0 && !mindwarded(victim)) {
          if (!str_cmp(ch->pcdata->maintained_target, "casting")) {
            victim->pcdata->maintained_ritual = ch->pcdata->process_subtype;
            free_string(victim->pcdata->ritual_maintainer);
            victim->pcdata->ritual_maintainer = str_dup(ch->name);
            free_string(ch->pcdata->maintained_target);
            ch->pcdata->maintained_target = str_dup(victim->name);
            cost /= 2;
            victim->pcdata->lunacy_curse = 2;
          }
          else
          victim->pcdata->lunacy_curse = 120 * power / 100;
        }
        do_function(victim, &do_imprint, "");
        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_DEAFEN) {
        power = ritual_debuff_power(ch, victim);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (get_skill(victim, SKILL_RITUALPROOF) <= 0) {
          AFFECT_DATA af;
          af.where = TO_AFFECTS;
          af.type = 0;
          af.level = 10;
          if (!str_cmp(ch->pcdata->maintained_target, "casting")) {
            victim->pcdata->maintained_ritual = ch->pcdata->process_subtype;
            free_string(victim->pcdata->ritual_maintainer);
            victim->pcdata->ritual_maintainer = str_dup(ch->name);
            free_string(ch->pcdata->maintained_target);
            ch->pcdata->maintained_target = str_dup(victim->name);
            cost /= 2;
            af.duration = 12 * 20;
          }
          else
          af.duration = 12 * 60 * 6 * power / 100;
          af.location = APPLY_NONE;
          af.modifier = 0;
          af.caster = NULL;
          af.weave = FALSE;
          af.bitvector = AFF_DEAF;
          affect_to_char(victim, &af);
        }

        send_to_char("All sounds dim as you stop being able to hear.\n\r", victim);
        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_LURE) {
        power = ritual_debuff_power(ch, victim);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (get_skill(victim, SKILL_RITUALPROOF) <= 0) {
          AFFECT_DATA af;
          af.where = TO_AFFECTS;
          af.type = 0;
          af.level = 10;
          af.duration = 12 * 60 * 6 * power / 100;
          af.location = APPLY_NONE;
          af.modifier = 0;
          af.caster = NULL;
          af.weave = FALSE;
          af.bitvector = AFF_LURED;
          affect_to_char(victim, &af);
          victim->pcdata->lured_room = ch->in_room->vnum;
        }

        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_MADNESS) {
        power = ritual_debuff_power(ch, victim);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (get_skill(victim, SKILL_RITUALPROOF) <= 0) {
          AFFECT_DATA af;
          af.where = TO_AFFECTS;
          af.type = 0;
          af.level = 10;
          if (!str_cmp(ch->pcdata->maintained_target, "casting")) {
            victim->pcdata->maintained_ritual = ch->pcdata->process_subtype;
            free_string(victim->pcdata->ritual_maintainer);
            victim->pcdata->ritual_maintainer = str_dup(ch->name);
            free_string(ch->pcdata->maintained_target);
            ch->pcdata->maintained_target = str_dup(victim->name);
            cost /= 2;
            af.duration = 12 * 20;
          }
          else {
            if (get_skill(victim, SKILL_SPLITMIND) > 0)
            af.duration = 12 * 60 * 3 * power / 50;
            else
            af.duration = 12 * 60 * 3 * power / 100;
          }
          af.location = APPLY_NONE;
          af.modifier = 0;
          af.caster = NULL;
          af.weave = FALSE;
          af.bitvector = AFF_MAD;
          affect_to_char(victim, &af);
        }
        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_PERSECUTION) {
        power = ritual_debuff_power(ch, victim);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (get_skill(victim, SKILL_RITUALPROOF) <= 0) {
          AFFECT_DATA af;
          af.where = TO_AFFECTS;
          af.type = 0;
          af.level = 10;
          if (!str_cmp(ch->pcdata->maintained_target, "casting")) {
            victim->pcdata->maintained_ritual = ch->pcdata->process_subtype;
            free_string(victim->pcdata->ritual_maintainer);
            victim->pcdata->ritual_maintainer = str_dup(ch->name);
            free_string(ch->pcdata->maintained_target);
            ch->pcdata->maintained_target = str_dup(victim->name);
            cost /= 2;
            af.duration = 12 * 20;
          }
          else
          af.duration = 12 * 60 * 3 * power / 100;
          af.location = APPLY_NONE;
          af.modifier = 0;
          af.caster = NULL;
          af.weave = FALSE;
          af.bitvector = AFF_PERSECUTED;
          affect_to_char(victim, &af);
        }

        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_ENFEEBLE) {
        power = ritual_debuff_power(ch, victim);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (get_skill(victim, SKILL_RITUALPROOF) <= 0) {
          AFFECT_DATA af;
          af.where = TO_AFFECTS;
          af.type = 0;
          af.level = 10;
          if (!str_cmp(ch->pcdata->maintained_target, "casting")) {
            victim->pcdata->maintained_ritual = ch->pcdata->process_subtype;
            free_string(victim->pcdata->ritual_maintainer);
            victim->pcdata->ritual_maintainer = str_dup(ch->name);
            free_string(ch->pcdata->maintained_target);
            ch->pcdata->maintained_target = str_dup(victim->name);
            cost /= 2;
            af.duration = 12 * 20;
          }
          else
          af.duration = 12 * 60 * 6 * power / 100;
          af.location = APPLY_NONE;
          af.modifier = 0;
          af.caster = NULL;
          af.weave = FALSE;
          af.bitvector = AFF_WEAKEN;
          affect_to_char(victim, &af);
        }

        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_HAUNT) {
        power = ritual_debuff_power(ch, victim);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        free_string(victim->pcdata->haunter);
        victim->pcdata->haunter = str_dup(ch->name);
        if (!str_cmp(ch->pcdata->maintained_target, "casting")) {
          victim->pcdata->maintained_ritual = ch->pcdata->process_subtype;
          free_string(victim->pcdata->ritual_maintainer);
          victim->pcdata->ritual_maintainer = str_dup(ch->name);
          free_string(ch->pcdata->maintained_target);
          ch->pcdata->maintained_target = str_dup(victim->name);
          cost /= 2;
          victim->pcdata->haunt_timer = 2;
        }
        else
        victim->pcdata->haunt_timer = 12 * 60 * 3 * power / 100;
        ch->pcdata->watching = 600;
        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
        else
        send_to_char("You feel watched.\n\r", victim);
      }
      if (ch->pcdata->process_subtype == RITUAL_PROTECT) {
        power = ritual_buff_power(ch);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (get_skill(victim, SKILL_RITUALPROOF) <= 0) {
          AFFECT_DATA af;
          af.where = TO_AFFECTS;
          af.type = 0;
          af.level = 10;
          af.duration = 12 * 60 * 6 * power / 100;
          af.location = APPLY_NONE;
          af.modifier = 0;
          af.caster = NULL;
          af.weave = FALSE;
          af.bitvector = AFF_PROTECT;
          affect_to_char(victim, &af);
        }

        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_RAISEWARD) {
        power = ritual_buff_power(ch);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (in_prop(victim) != NULL && !is_base(in_prop(victim)) && in_prop(victim)->blackout == 0) {
          in_prop(victim)->warded += power;
        }

        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_LOWERWARD) {
        power = ritual_buff_power(ch);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (in_prop(victim) != NULL) {
          in_prop(victim)->warded -= power;
          if (in_prop(victim)->warded < 75)
          send_to_char("The wards break.\n\r", ch);

          CHAR_DATA *to;
          for (DescList::iterator it = descriptor_list.begin();
          it != descriptor_list.end(); ++it) {
            DESCRIPTOR_DATA *d = *it;
            if (d != NULL && d->character != NULL && d->connected == CON_PLAYING) {
              to = d->character;
              if (to == NULL)
              continue;
              if (IS_NPC(to))
              continue;
              if (in_prop(to) == in_prop(victim))
              send_to_char("`DThe lights flicker.`x\n\r", to);
            }
          }
        }
        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_MIST) {
        power = ritual_buff_power(ch);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);
        time_info.mist_timer += 10 * power / 100;
      }
      if (ch->pcdata->process_subtype == RITUAL_BANISH) {
        power = ritual_buff_power(ch);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        CHAR_DATA *to;
        for (DescList::iterator it = descriptor_list.begin();
        it != descriptor_list.end(); ++it) {
          DESCRIPTOR_DATA *d = *it;

          if (d != NULL && d->character != NULL && d->connected == CON_PLAYING) {
            to = d->character;

            if (IS_NPC(to))
            continue;
            if (to == NULL)
            continue;
            if (to->in_room == NULL)
            continue;
            if (to->in_room != victim->in_room)
            continue;
            if(higher_power(to))
            {
              to->pcdata->wander_time = 180;
              to->possessing = NULL;
              send_domain_home(to);
              cost = cost/3;
            }
            else if (IS_FLAG(to->act, PLR_GHOSTWALKING)) {
              act("You feel the earth heave upward to swallow you.\n\r", ch, NULL, to, TO_VICT);
              char_from_room(to);
              char_to_room(to, get_room_index(to->pcdata->ghost_room));
              to->pcdata->ghost_wound = 60;
              REMOVE_FLAG(to->act, PLR_GHOSTWALKING);
            }
            else if (is_ghost(to)) {
              to->possessing = NULL;
              to->pcdata->timebanished = current_time + (3600 * 24 * 30);
              //                          REMOVE_FLAG( to->act, PLR_GHOST );
              char_from_room(to);
              char_to_room(to, graveyard_room());
              //                          to->pcdata->ghost_banishment=current_time;
              act("You feel the earth heave upward to swallow you.\n\r", ch, NULL, to, TO_VICT);
            }
          }
        }

        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_BINDING) {
        power = ritual_buff_power(ch);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        CHAR_DATA *to;
        for (DescList::iterator it = descriptor_list.begin();
        it != descriptor_list.end(); ++it) {
          DESCRIPTOR_DATA *d = *it;

          if (d != NULL && d->character != NULL && d->connected == CON_PLAYING) {
            to = d->character;

            if (IS_NPC(to))
            continue;
            if (to == NULL)
            continue;
            if (to->in_room == NULL)
            continue;
            if (to->in_room != victim->in_room)
            continue;

            if(higher_power(to))
            {
              to->pcdata->wander_time = 120;
              cost = cost /3;
              to->possessing = NULL;
              send_domain_home(to);
            }
            if (is_ghost(to) && !higher_power(to)) {
              if (!IS_FLAG(to->act, PLR_GHOSTBOUND)) {
                SET_FLAG(to->act, PLR_GHOSTBOUND);
              }
              to->possessing = NULL;
              act("You feel suddenly stuck in this area.\n\r", ch, NULL, to, TO_VICT);
            }
          }
        }
        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_UNBINDING) {
        power = ritual_buff_power(ch);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        CHAR_DATA *to;
        for (DescList::iterator it = descriptor_list.begin();
        it != descriptor_list.end(); ++it) {
          DESCRIPTOR_DATA *d = *it;

          if (d != NULL && d->character != NULL && d->connected == CON_PLAYING) {
            to = d->character;

            if (IS_NPC(to))
            continue;
            if (to == NULL)
            continue;
            if (to->in_room == NULL)
            continue;
            if (to->in_room != ch->in_room)
            continue;

            if (is_ghost(to)) {
              if (IS_FLAG(to->act, PLR_GHOSTBOUND)) {
                REMOVE_FLAG(to->act, PLR_GHOSTBOUND);
              }
              act("You feel released.\n\r", ch, NULL, to, TO_VICT);
            }
          }
        }
      }
      if (ch->pcdata->process_subtype == RITUAL_MINDWARD) {
        power = ritual_buff_power(ch);
        act("You conclude your ritual.", ch, NULL, NULL, TO_CHAR);
        act("$n finishes $s ritual.", ch, NULL, NULL, TO_ROOM);

        if (get_skill(victim, SKILL_RITUALPROOF) <= 0) {
          AFFECT_DATA af;
          af.where = TO_AFFECTS;
          af.type = 0;
          af.level = 10;
          af.duration = 12 * 60 * 6 * power / 100;
          af.location = APPLY_NONE;
          af.modifier = 0;
          af.caster = NULL;
          af.weave = FALSE;
          af.bitvector = AFF_MINDWARD;
          affect_to_char(victim, &af);
        }

        save_char_obj(victim, FALSE, FALSE);
        if (!online) {
          free_char(victim);
          victim = NULL;
        }
      }

      if (get_hour(ch->in_room) == 3) {
        if (prop_from_room(ch->in_room) == NULL || prop_from_room(ch->in_room)->timefrozen == 0)
        cost = cost * 2 / 3;
      }
      use_lifeforce(ch, cost, "Ritual.");
      if (base_lifeforce(ch) < 6000 && number_percent() % 3 == 0) {
        free_string(ch->pcdata->deathcause);
        ch->pcdata->deathcause = str_dup("a stroke.");
        act("$n slumps sideways to the ground.", ch, NULL, NULL, TO_ROOM);
        real_kill(ch, ch);
      }
      else if (base_lifeforce(ch) < 7500) {
        act("$n slumps sideways to the ground.", ch, NULL, NULL, TO_ROOM);
        act("You pass out.", ch, NULL, NULL, TO_CHAR);
        ch->pcdata->coma = current_time + (3600 * number_range(1, 5));
        ch->pcdata->sleeping = 10;
      }
      return;
    }

    if (type == PROCESS_DRAINPC) {
      if (ch->pcdata->process_target == NULL)
      return;
      if (!harvesting_room(ch->in_room))
      return;

      int val = pc_anima_value(ch->pcdata->process_target);
      if (val <= 0 || base_lifeforce(ch->pcdata->process_target) < 8200) {
        send_to_char("They're too weak to give anything worthwhile.\n\r", ch);
        return;
      }

      val /= 3;
      int amount = val * get_tier(ch->pcdata->process_target) *
      get_tier(ch->pcdata->process_target) / 5;
      // 1000 * tier. Tier 1 is val/10
      amount = amount * (5 + get_skill(ch, SKILL_ALCHEMY)) / 5;
      //	amount /= 2;

      obj = create_object(get_obj_index(36), 0);
      obj->level = amount;
      obj->value[0] = ch->pcdata->process_target->faction;
      obj_to_char(obj, ch);
      AFFECT_DATA af;
      af.where = TO_AFFECTS;
      af.type = 0;
      af.level = 10;
      if (ch->pcdata->process_target->faction == ch->faction)
      af.duration = 12 * 60 * 30;
      else
      af.duration = 12 * 60;
      af.location = APPLY_NONE;
      af.modifier = 0;
      af.caster = NULL;
      af.weave = FALSE;
      af.bitvector = AFF_DRAINED;
      affect_to_char(ch->pcdata->process_target, &af);
      take_lifeforce(ch->pcdata->process_target, val, "harvesting.");

      act("You successfully drain $N and store the gathered energy in a small metal cylinder.", ch, NULL, ch->pcdata->process_target, TO_CHAR);
      act("$n finishes draining you and stores what $e gathered in a small metal cylinder.", ch, NULL, ch->pcdata->process_target, TO_VICT);
      act("$n finishes draining $N and stores the gathered material in a small metal cylinder.", ch, NULL, ch->pcdata->process_target, TO_NOTVICT);
      wound_char_absolute(ch->pcdata->process_target, 1);
    }
    if (type == PROCESS_EXORCISE) {
      if (ch->pcdata->process_target == NULL)
      return;

      act("You complete your exorcism.", ch, NULL, NULL, TO_CHAR);
      act("$n completes $s exorcism.", ch, NULL, NULL, TO_ROOM);

      if (IS_FLAG(ch->pcdata->process_target->act, PLR_SINSPIRIT)) {
        if (ch->pcdata->process_target->pcdata->spirit_type ==
            SPIRIT_MALEFICARUM) {
          act("$N's body twists and convulses before $E suddenly vomits black smoke.", ch->pcdata->process_target, NULL, NULL, TO_ROOM);
        }
        else {
          act("$N's body twists and convulses before $E suddenly vomits white smoke.", ch->pcdata->process_target, NULL, NULL, TO_ROOM);
        }
        real_quit(ch->pcdata->process_target);
        ch->pcdata->process_target = NULL;
      }
      else {
        act("Nothing seems to happen.", ch, NULL, NULL, TO_CHAR);
      }
      return;
    }
    if (type == PROCESS_DRAINABOM) {
    }
    if (type == PROCESS_SEARCH) {
      if (ch->pcdata->process_subtype != ch->in_room->vnum) {
        send_to_char("This isn't the room you were searching originally.\n\r", ch);
        return;
      }
      send_to_char("You finish your search.\n\r", ch);
      EXTRA_DESCR_DATA *ed;
      for (ed = ch->in_room->extra_descr; ed; ed = ed->next) {
        if (is_name("!hidden", ed->keyword))
        break;
      }
      if (ed) {
        printf_to_char(ch, "%s\n\r", ed->description);
      }
      ed = NULL;
      for (ed = ch->in_room->extra_descr; ed; ed = ed->next) {
        if (is_name("!srhidden", ed->keyword))
        break;
      }
      if (ed) {
        printf_to_char(ch, "%s\n\r", ed->description);
      }
      for (CharList::iterator it = ch->in_room->people->begin();
      it != ch->in_room->people->end(); ++it) {
        if (!IS_NPC((*it)) && IS_FLAG((*it)->act, PLR_HIDE)) {
          REMOVE_FLAG((*it)->act, PLR_HIDE);
          act("You reveal $N.", ch, NULL, (*it), TO_CHAR);
          act("$n reveals you.", ch, NULL, (*it), TO_VICT);
          act("$n reveals $N.", ch, NULL, (*it), TO_NOTVICT);
        }
      }
      return;
    }

    if (type == PROCESS_REPAIR) {
      if (ch->pcdata->process_subtype != ch->in_room->vnum) {
        send_to_char("This isn't the room you were repairing originally.\n\r", ch);
        return;
      }
      ch->in_room->encroachment = 0;
      for (int dir = 0; dir < 10; dir++) {
        if (ch->in_room->exit[dir] != NULL) {
          ch->in_room->exit[dir]->doorbroken = 0;
          if (ch->in_room->exit[dir]->wall > 0)
          ch->in_room->exit[dir]->wallcondition = 0;

          if (ch->in_room->exit[dir]->u1.to_room != NULL && ch->in_room->exit[dir]->u1.to_room->exit[rev_dir[dir]] != NULL) {
            ch->in_room->exit[dir]->u1.to_room->exit[rev_dir[dir]]->doorbroken =
            0;
            if (ch->in_room->exit[dir]->u1.to_room->exit[rev_dir[dir]]->wall > 0)
            ch->in_room->exit[dir]
            ->u1.to_room->exit[rev_dir[dir]]
            ->wallcondition = 0;
          }
        }
      }
      SET_BIT(ch->in_room->area->area_flags, AREA_CHANGED);
      act("You finish your repairs.", ch, NULL, NULL, TO_CHAR);
      act("$n finishes $s repairs.", ch, NULL, NULL, TO_ROOM);
      for (CharList::iterator it = ch->in_room->people->begin();
      it != ch->in_room->people->end();) {
        CHAR_DATA *fch = *it;
        ++it;
        if (fch == NULL || IS_NPC(fch))
        continue;
        if (fch->pcdata->process == type) {
          fch->pcdata->process = 0;
          fch->pcdata->process_timer = 0;
          fch->pcdata->last_develop_type = 0;
          fch->pcdata->last_develop_time = 0;
        }
      }
      return;
    }
    if (type == PROCESS_DEEPDIG) {
      if (ch->pcdata->process_subtype != ch->in_room->vnum) {
        send_to_char("This isn't the room you were digging in originally.\n\r", ch);
        return;
      }
      ch->in_room->sector_type = SECT_WATER;
      SET_BIT(ch->in_room->area->area_flags, AREA_CHANGED);
      act("You finish digging your pit and fill it with deep water.", ch, NULL, NULL, TO_CHAR);
      act("$n finishes digging $s pit and fills it with deep water.", ch, NULL, NULL, TO_ROOM);
      for (CharList::iterator it = ch->in_room->people->begin();
      it != ch->in_room->people->end();) {
        CHAR_DATA *fch = *it;
        ++it;
        if (fch == NULL || IS_NPC(fch))
        continue;
        if (fch->pcdata->process == type) {
          fch->pcdata->process = 0;
          fch->pcdata->process_timer = 0;
          fch->pcdata->last_develop_type = 0;
          fch->pcdata->last_develop_time = 0;
        }
      }

      return;
    }
    if (type == PROCESS_SHALLOWDIG) {
      if (ch->pcdata->process_subtype != ch->in_room->vnum) {
        send_to_char("This isn't the room you were digging in originally.\n\r", ch);
        return;
      }
      ch->in_room->sector_type = SECT_SHALLOW;
      SET_BIT(ch->in_room->area->area_flags, AREA_CHANGED);
      act("You finish digging your pit and fill it with shallow water.", ch, NULL, NULL, TO_CHAR);
      act("$n finishes digging $s pit and fills it with shallow water.", ch, NULL, NULL, TO_ROOM);
      for (CharList::iterator it = ch->in_room->people->begin();
      it != ch->in_room->people->end();) {
        CHAR_DATA *fch = *it;
        ++it;
        if (fch == NULL || IS_NPC(fch))
        continue;
        if (fch->pcdata->process == type) {
          fch->pcdata->process = 0;
          fch->pcdata->process_timer = 0;
          fch->pcdata->last_develop_type = 0;
          fch->pcdata->last_develop_time = 0;
        }
      }

      return;
    }
    if (type == PROCESS_SHRINE) {
      if (ch->pcdata->process_subtype != ch->in_room->vnum) {
        send_to_char("This isn't the room you were building in originally.\n\r", ch);
        return;
      }
      DOMAIN_TYPE *dom = domain_by_name(ch->pcdata->process_argumentone);
      if (dom == NULL) {
        send_to_char("No such domain.\n\r", ch);
        return;
      }
      PROP_TYPE *prop = prop_from_room(ch->in_room);
      if (prop == NULL) {
        send_to_char("You aren't in a property.\n\r", ch);
        return;
      }
      if(!has_nonconsume(ch, ITEM_BLOOD))
      {
        send_to_char("You don't have any blood.\n\r", ch);
        return;
      }
      ch->pcdata->account->lastshrine = current_time + 3600 * 24 * 7;

      for (int i = 0; i < 250; i++) {
        if (dom->smallshrines[i] == 0) {
          OBJ_DATA *obj;
          OBJ_DATA *obj_next;

          for (obj = ch->carrying; obj != NULL; obj = obj_next) {
            obj_next = obj->next_content;

            if (IS_SET(obj->extra_flags, ITEM_WARDROBE))
            continue;

            if (obj->pIndexData->vnum == ITEM_BLOOD) {
              if(obj->level > i)
              {
                dom->smallshrines[i] = ch->in_room->vnum;
                act("You finish sanctifying the area.", ch, NULL, NULL, TO_CHAR);
                act("$n finishes sanctifying the area.", ch, NULL, NULL, TO_ROOM);
                extract_obj(obj);
                return;
              }
              else
              {
                act("Your attempt to santify the area fails.", ch, NULL, NULL, TO_CHAR);
                act("$n finishes attempting to sanctify the area.", ch, NULL, NULL, TO_ROOM);
                extract_obj(obj);
                return;
              }
            }
          }
        }
      }
      return;
    }
    if (type == PROCESS_NOSHRINE) {
      if (ch->pcdata->process_subtype != ch->in_room->vnum) {
        send_to_char("This isn't the room you were digging in originally.\n\r", ch);
        return;
      }
      for (vector<DOMAIN_TYPE *>::iterator it = DomainVect.begin();
      it != DomainVect.end(); ++it) {
        for (int i = 0; i < 250; i++) {
          if ((*it)->bigshrines[i] == ch->in_room->vnum) {
            (*it)->bigshrines[i] = 0;
            act("You finish cleansing the area.", ch, NULL, NULL, TO_CHAR);
            act("$n finishes cleansing the area.", ch, NULL, NULL, TO_ROOM);
            return;
          }
          if ((*it)->medshrines[i] == ch->in_room->vnum) {
            (*it)->medshrines[i] = 0;
            act("You finish cleansing the area.", ch, NULL, NULL, TO_CHAR);
            act("$n finishes cleansing the area.", ch, NULL, NULL, TO_ROOM);
            return;
          }
          if ((*it)->smallshrines[i] == ch->in_room->vnum) {
            (*it)->smallshrines[i] = 0;
            act("You finish cleansing the area.", ch, NULL, NULL, TO_CHAR);
            act("$n finishes cleansing the area.", ch, NULL, NULL, TO_ROOM);
            return;
          }
        }
      }
      return;
    }
    if (type == PROCESS_FILLIN) {
      if (ch->pcdata->process_subtype != ch->in_room->vnum) {
        send_to_char("This isn't the room you were digging in originally.\n\r", ch);
        return;
      }
      ch->in_room->sector_type = SECT_PARK;
      SET_BIT(ch->in_room->area->area_flags, AREA_CHANGED);
      act("You finish draining the water and filling in the pit.", ch, NULL, NULL, TO_CHAR);
      act("$n finishes draining the water and filling in the pit.", ch, NULL, NULL, TO_ROOM);
      for (CharList::iterator it = ch->in_room->people->begin();
      it != ch->in_room->people->end();) {
        CHAR_DATA *fch = *it;
        ++it;
        if (fch == NULL || IS_NPC(fch))
        continue;
        if (fch->pcdata->process == type) {
          fch->pcdata->process = 0;
          fch->pcdata->process_timer = 0;
          fch->pcdata->last_develop_type = 0;
          fch->pcdata->last_develop_time = 0;
        }
      }
      return;
    }
    if (type == PROCESS_CLEARING) {
      if (ch->pcdata->process_subtype != ch->in_room->vnum) {
        send_to_char("This isn't the room you were clearing originally.\n\r", ch);
        return;
      }
      ch->in_room->sector_type = SECT_PARK;
      ch->in_room->encroachment = 0;
      act("You finish making a clearing.", ch, NULL, NULL, TO_CHAR);
      act("$n finishes making a clearing.", ch, NULL, NULL, TO_ROOM);
      ch->pcdata->week_tracker[TRACK_TREES_CHOPPED]++;
      ch->pcdata->life_tracker[TRACK_TREES_CHOPPED]++;
      if (!IS_SET(ch->in_room->area->area_flags, AREA_CHANGED))
      SET_BIT(ch->in_room->area->area_flags, AREA_CHANGED);

      int pop = 0;
      for (CharList::iterator it = ch->in_room->people->begin();
      it != ch->in_room->people->end();) {
        CHAR_DATA *fch = *it;
        ++it;
        if (fch == NULL || IS_NPC(fch))
        continue;
        if (fch->pcdata->process == type) {
          pop++;
        }
      }
      for (CharList::iterator it = ch->in_room->people->begin();
      it != ch->in_room->people->end();) {
        CHAR_DATA *fch = *it;
        ++it;
        if (fch == NULL || IS_NPC(fch))
        continue;
        if (fch->pcdata->process == type) {
          fch->pcdata->process = 0;
          fch->pcdata->process_timer = 0;
          fch->pcdata->last_develop_type = 0;
          fch->pcdata->last_develop_time = 0;
          int fpenalty =
          100 -
          get_skill(fch, SKILL_STRENGTH) * get_skill(fch, SKILL_STRENGTH) -
          get_skill(fch, SKILL_DEXTERITY) * get_skill(fch, SKILL_DEXTERITY);
          fpenalty -= 3 * labor_points(fch) * labor_points(fch);
          fpenalty = fpenalty * (100 - chainsaw_bonus(fch)) / 100;
          fpenalty = UMAX(fpenalty, 10);
          fpenalty /= UMAX(1, pop);
          fch->pcdata->fatigue += fpenalty * 10;
        }
      }
      SET_BIT(ch->in_room->area->area_flags, AREA_CHANGED);
      return;
    }
    if (type == PROCESS_BUTCHER) {
      OBJ_DATA *obj = NULL;
      if ((obj = get_eq_char(ch, WEAR_HOLD)) == NULL || !is_name(ch->pcdata->process_argumentone, obj->name)) {
        obj = get_obj_carry(ch, ch->pcdata->process_argumentone, ch);
      }
      if (obj == NULL) {
        obj = get_obj_list(ch, ch->pcdata->process_argumentone, ch->in_room->contents);
      }
      if (obj == NULL) {
        send_to_char("You can't find it.\n\r", ch);
        return;
      }
      if (obj->item_type != ITEM_CORPSE_NPC) {
        send_to_char("That's not a corpse.\n\r", ch);
        return;
      }
      if (obj->value[3] == 0) {
        send_to_char("That isn't a harvestable corpse.\n\r", ch);
        return;
      }
      for (int i = 0; i < 33; i++) {
        if (obj->value[3] == monster_table[i].vnum) {
          OBJ_DATA *reward;
          reward = create_object(get_obj_index(38), 0);
          reward->level = 0;
          reward->size = 10;
          free_string(reward->name);
          reward->name = str_dup(monster_table[i].object);
          free_string(reward->short_descr);
          reward->short_descr = str_dup(monster_table[i].object);
          char tmp[MSL];
          sprintf(tmp, "%s %s", a_or_an(monster_table[i].object), monster_table[i].object);
          free_string(reward->description);
          reward->description = str_dup(tmp);
          reward->level = obj->value[4] * 3;
          char lstring[MSL];
          sprintf(lstring, "BUTCHER: %s butchers %s for material level %d.", ch->name, obj->description, reward->level);
          log_string(lstring);
          if (reward->level > 0 && get_skill(ch, SKILL_ALCHEMY) > 0) {
            reward->level =
            reward->level * (10 + get_skill(ch, SKILL_ALCHEMY)) / 10;
          }
          obj_to_char(reward, ch);
          act("You finish butchering the corpse and extract $a $p.", ch, reward, NULL, TO_CHAR);
          act("$n finishes butchering the corpse and extracts $a $p.", ch, reward, NULL, TO_ROOM);
          ch->pcdata->fatigue += (10 - get_skill(ch, SKILL_DEMONOLOGY));
          obj->value[4] = 0;
          obj->value[3] = 0;
          return;
        }
      }
      return;
    }
    if (type == PROCESS_ROAD) {
      if (ch->pcdata->process_subtype != ch->in_room->vnum) {
        send_to_char("This isn't the room you were clearing originally.\n\r", ch);
        return;
      }
      ch->in_room->sector_type = SECT_STREET;
      ch->in_room->encroachment = 0;
      if (!IS_SET(ch->in_room->room_flags, ROOM_DIRTROAD))
      TOGGLE_BIT(ch->in_room->room_flags, ROOM_DIRTROAD);
      free_string(ch->in_room->name);
      ch->in_room->name = str_dup(ch->pcdata->process_argumentone);
      free_string(ch->in_room->description);
      ch->in_room->description = str_dup(ch->pcdata->process_argumenttwo);
      act("You finish making a dirt road.", ch, NULL, NULL, TO_CHAR);
      act("$n finishes making a dirt road.", ch, NULL, NULL, TO_ROOM);
      ch->pcdata->week_tracker[TRACK_ROADS_BUILT]++;
      ch->pcdata->life_tracker[TRACK_ROADS_BUILT]++;
      if (!IS_SET(ch->in_room->area->area_flags, AREA_CHANGED))
      SET_BIT(ch->in_room->area->area_flags, AREA_CHANGED);
      ch->money -= 1000;
      int pop = 0;
      for (CharList::iterator it = ch->in_room->people->begin();
      it != ch->in_room->people->end();) {
        CHAR_DATA *fch = *it;
        ++it;
        if (fch == NULL || IS_NPC(fch))
        continue;
        if (fch->pcdata->process == type) {
          pop++;
        }
      }
      for (CharList::iterator it = ch->in_room->people->begin();
      it != ch->in_room->people->end();) {
        CHAR_DATA *fch = *it;
        ++it;
        if (fch == NULL || IS_NPC(fch))
        continue;
        if (fch->pcdata->process == type) {
          fch->pcdata->process = 0;
          fch->pcdata->process_timer = 0;
          fch->pcdata->last_develop_type = 0;
          fch->pcdata->last_develop_time = 0;
          int fpenalty =
          100 -
          get_skill(fch, SKILL_STRENGTH) * get_skill(fch, SKILL_STRENGTH) -
          get_skill(fch, SKILL_DEXTERITY) * get_skill(fch, SKILL_DEXTERITY);
          fpenalty -= 3 * labor_points(fch) * labor_points(fch);
          fpenalty = UMAX(fpenalty, 10);
          fpenalty /= UMAX(1, pop);
          fch->pcdata->fatigue += fpenalty * 2;
        }
      }
      return;
    }
    if (type == PROCESS_PAVING) {
      if (ch->pcdata->process_subtype != ch->in_room->vnum) {
        send_to_char("This isn't the room you were clearing originally.\n\r", ch);
        return;
      }
      ch->in_room->sector_type = SECT_STREET;
      ch->in_room->encroachment = 0;
      if (IS_SET(ch->in_room->room_flags, ROOM_DIRTROAD))
      TOGGLE_BIT(ch->in_room->room_flags, ROOM_DIRTROAD);
      act("You finish paving the road.", ch, NULL, NULL, TO_CHAR);
      act("$n finishes paving the road.", ch, NULL, NULL, TO_ROOM);
      free_string(ch->in_room->name);
      ch->in_room->name = str_dup(ch->pcdata->process_argumentone);
      free_string(ch->in_room->description);
      ch->in_room->description = str_dup(ch->pcdata->process_argumenttwo);

      if (!IS_SET(ch->in_room->area->area_flags, AREA_CHANGED))
      SET_BIT(ch->in_room->area->area_flags, AREA_CHANGED);
      ch->money -= 10000;
      int pop = 0;
      for (CharList::iterator it = ch->in_room->people->begin();
      it != ch->in_room->people->end();) {
        CHAR_DATA *fch = *it;
        ++it;
        if (fch == NULL || IS_NPC(fch))
        continue;
        if (fch->pcdata->process == type) {
          pop++;
        }
      }
      for (CharList::iterator it = ch->in_room->people->begin();
      it != ch->in_room->people->end();) {
        CHAR_DATA *fch = *it;
        ++it;
        if (fch == NULL || IS_NPC(fch))
        continue;
        if (fch->pcdata->process == type) {
          fch->pcdata->process = 0;
          fch->pcdata->process_timer = 0;
          fch->pcdata->last_develop_type = 0;
          fch->pcdata->last_develop_time = 0;
          int fpenalty =
          100 -
          get_skill(fch, SKILL_STRENGTH) * get_skill(fch, SKILL_STRENGTH) -
          get_skill(fch, SKILL_DEXTERITY) * get_skill(fch, SKILL_DEXTERITY);
          fpenalty -= 3 * labor_points(fch) * labor_points(fch);
          fpenalty = UMAX(fpenalty, 10);
          fpenalty /= UMAX(1, pop);
          fch->pcdata->fatigue += fpenalty * 4;
        }
      }
      return;
    }

    if (type == PROCESS_RELAY) {
      if (ch->pcdata->process_subtype != ch->in_room->vnum) {
        send_to_char("This isn't the room you were clearing originally.\n\r", ch);
        return;
      }
      ch->in_room->encroachment = 0;
      act("You finish relaying the road.", ch, NULL, NULL, TO_CHAR);
      act("$n finishes relaying the road.", ch, NULL, NULL, TO_ROOM);
      free_string(ch->in_room->name);
      ch->in_room->name = str_dup(ch->pcdata->process_argumentone);
      free_string(ch->in_room->description);
      ch->in_room->description = str_dup(ch->pcdata->process_argumenttwo);

      if (!IS_SET(ch->in_room->area->area_flags, AREA_CHANGED))
      SET_BIT(ch->in_room->area->area_flags, AREA_CHANGED);
      return;
    }
    if (type == PROCESS_EXTERMINATE) {
      if (ch->pcdata->process_target == NULL)
      return;
      if (!operating_room(ch->in_room))
      return;

      ch->pcdata->process_target->pcdata->egg_daddy = 0;
      wound_char_absolute(ch->pcdata->process_target, 2);
      act("You finish $N's surgery, killing everything implanted into $M.", ch, NULL, ch->pcdata->process_target, TO_CHAR);
      act("$n finishes your surgery.", ch, NULL, ch->pcdata->process_target, TO_VICT);
      act("$n finishes $N's surgery.", ch, NULL, ch->pcdata->process_target, TO_NOTVICT);
    }
    if (type == PROCESS_TREATING) {
      if (ch->pcdata->process_target == NULL)
      return;
      if (!operating_room(ch->in_room))
      return;

      CHAR_DATA *victim = ch->pcdata->process_target;
      int cost = 500;
      int faccost = 0;
      int cashcost = 0;
      if (ch->faction > 0 && has_trust(ch, TRUST_RESOURCES, ch->faction) && clan_lookup(ch->faction)->resource >= 5000 + faccost && can_spend_resources(clan_lookup(ch->faction))) {
        faccost = cost / 10;
      }
      else
      cashcost = cost * 100;

      if (cashcost > 0) {
        printf_to_char(ch, "For %d dollars in supplies you treat %s's wounds\n\r", PERS(victim, ch));
        ch->money -= cashcost;
      }
      else {
        printf_to_char(ch, "For $%d society resources you treat %s's wounds\n\r", faccost * 10, PERS(victim, ch));
        use_resources(faccost, ch->faction, ch, "treating wounds.");
      }
      victim->heal_timer =
      victim->heal_timer * (90 - (get_skill(ch, SKILL_MEDICINE) * 10)) / 100;

      act("You finish treating $N's wounds.", ch, NULL, victim, TO_CHAR);
      act("$n finishes treating your wounds.", ch, NULL, victim, TO_VICT);
      act("$n finishes treating $N's wounds.", ch, NULL, victim, TO_NOTVICT);
    }
    if (type == PROCESS_RESEARCH) {
      if (!library_room(ch->in_room))
      return;

      lookup_research(ch, ch->pcdata->process_argumentone);
      send_to_char("You finish your research.\n\r", ch);
    }
    if (type == PROCESS_LOOKINGUP) {
      if (ch->pcdata->process_target == NULL)
      return;

      if (!library_room(ch->in_room))
      return;

      if (clan_lookup(ch->faction) == NULL)
      return;
      CHAR_DATA *victim = ch->pcdata->process_target;

      int cost = 10;

      if (ch != victim) {
        act("You finish collecting reading matieral for $N.", ch, NULL, victim, TO_CHAR);
      }
      else
      act("You finish collecting reading material.", ch, NULL, victim, TO_CHAR);

      clan_lookup(ch->faction)->research -= cost;
      sprintf(buf, "%s uses %d research.", ch->name, cost);
      send_log(ch->faction, buf);
    }
  }

  void reset_char(CHAR_DATA *ch) {
    int i;
    ch->exp += ch->spentexp;
    ch->rpexp += ch->spentrpexp;
    ch->spentexp = 0;
    ch->spentrpexp = 0;
    ch->pcdata->dtrains = 60;
    ch->pcdata->strains = 25;
    for (i = 0; i <= DIS_USED; i++) {
      ch->disciplines[i] = 0;
    }
    for (i = 0; i <= SKILL_USED; i++) {
      ch->skills[i] = 0;
    }
    if (ch->pcdata->penis > 0)
    ch->pcdata->strains += 3;
  }

  _DOFUN(do_treat) {
    CHAR_DATA *victim;
    if ((victim = get_char_room(ch, NULL, argument)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }
    int cost = 500;

    if (ch == victim) {
      send_to_char("That might be a little dangerous.\n\r", ch);
      return;
    }
    if (is_ghost(ch)) {
      send_to_char("Slaying the living is no longer so simple./n/r", ch);
      return;
    }

    if (is_ghost(victim)) {
      send_to_char("Slaying a ghost is not so simple./n/r", ch);
      return;
    }

    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (!in_medical_facility(ch)) {
      send_to_char("You need to be in a medical facility to do that.\n\r", ch);
      return;
    }

    int faccost = 0;
    int cashcost = 0;
    if (institute_staff(ch) && (clinic_staff_rank(ch) >= 2 || college_staff_rank(ch) >= 2)) {
    }
    else if (has_trust(ch, TRUST_RESOURCES, ch->faction)
        && clan_lookup(ch->faction)->resource >= 5000 + faccost
        && can_spend_resources(clan_lookup(ch->faction))) {
      faccost = cost / 10;
    }
    else {
      cashcost = cost * 100;
    }

    if (ch->money < cashcost && cashcost > 0) {
      printf_to_char(ch, "You'd need at least %d dollars in supplies to treat their injuries.\n\r", cashcost / 100);
      return;
    }
    if (faccost > 0 && clan_lookup(ch->faction)->resource < 5000 + faccost) {
      printf_to_char(ch, "That costs $%d in society resources.\n\r",faccost * 10);
      return;
    }

    ch->pcdata->process = PROCESS_TREATING;
    ch->pcdata->process_timer = 30;
    ch->pcdata->process_target = victim;
    act("You start the process of treating $N's wounds.", ch, NULL, victim, TO_CHAR);
    act("$n starts the process of treating your wounds.", ch, NULL, victim, TO_VICT);
    act("$n starts the process of treating $N's wounds.", ch, NULL, victim, TO_NOTVICT);
  }

  const char *ammo_names[] = {
    "None", "Advanced", "Silver", "Gold",     "Wood",        "Incendiary", "Iron", "Bone",     "Quartz", "Obsidian", "Radioactive", "Armorpiercing"};

  _DOFUN(do_augment) {
    OBJ_DATA *obj;
    OBJ_DATA *obj_next;
    char arg1[MSL];
    argument = one_argument_nouncap(argument, arg1);

    if (!engineering_room(ch->in_room)) {
      send_to_char("You need to be in an engineering bay to do that.\n\r", ch);
      return;
    }

    OBJ_DATA *weapon = NULL;
    for (obj = ch->carrying; obj != NULL; obj = obj_next) {
      obj_next = obj->next_content;

      if (IS_SET(obj->extra_flags, ITEM_WARDROBE))
      continue;

      if (obj->item_type != ITEM_WEAPON && obj->item_type != ITEM_RANGED && !IS_SET(obj->extra_flags, ITEM_ARMORED))
      continue;

      if (is_name(arg1, obj->name)) {
        weapon = obj;
        break;
      }
    }
    if (weapon == NULL) {
      send_to_char("Augment what?\n\r", ch);
      return;
    }
    int type = -1;
    for (int i = 0; i < MAX_AMMO; i++) {
      if (!str_cmp(argument, ammo_names[i])) {
        type = i;
      }
    }
    if (type == -1) {
      printf_to_char(ch, "Valid types of augment are");
      for (int i = 0; i < MAX_AMMO; i++) {
        printf_to_char(ch, ", %s", ammo_names[i]);
      }
      send_to_char(".\n\r", ch);
      return;
    }
    int cost = 0;
    if (type == AMMO_AUGMENTED)
    cost = 15000;
    else if (type == AMMO_ARMOR)
    cost = 5000;
    else
    cost = 2500;

    if (type != AMMO_AUGMENTED && IS_SET(weapon->extra_flags, ITEM_ARMORED)) {
      send_to_char("Armor can only be made more advanced.\n\r", ch);
      return;
    }
    if (weapon->item_type == ITEM_WEAPON && weapon->size >= 25 && (type == AMMO_INCENDIARY || type == AMMO_ARMOR)) {
      send_to_char("Melee weapons can't be given that augment.\n\r", ch);
      return;
    }
    int discount = 0;
    if (type == AMMO_AUGMENTED)
    discount = get_skill(ch, SKILL_ENGINEERING);
    else
    discount =
    get_skill(ch, SKILL_ENGINEERING) + get_skill(ch, SKILL_ASSASSINFOCUS);

    discount *= 15;
    discount = UMIN(discount, 85);

    cost = cost * (100 - discount) / 100;
    int duration = 30;
    duration += get_skill(ch, SKILL_ENGINEERING) * 5;
    duration += get_skill(ch, SKILL_GENERALFOCUS) * 5;

    int faccost = 0;
    int cashcost = 0;
    if (has_trust(ch, TRUST_RESOURCES, ch->faction) && clan_lookup(ch->faction)->resource >= 8000 + faccost && can_spend_resources(clan_lookup(ch->faction)))
    faccost = cost / 10;
    else
    cashcost = cost * 100;

    if (ch->money < cashcost && cashcost > 0) {
      printf_to_char(ch, "You'd need at least %d dollars to do that.\n\r", cashcost / 100);
      return;
    }
    if (faccost > 0 && clan_lookup(ch->faction)->resource < 8000 + faccost) {
      printf_to_char(ch, "That costs $%d in society resources.\n\r", faccost * 10);
      return;
    }
    if (cashcost > 0) {
      printf_to_char(ch, "For %d dollars in supplies you augment %s.\n\r", cashcost, weapon->description);
      ch->money -= cashcost;
    }
    else if (faccost > 0) {
      printf_to_char(ch, "For $%d society resources you augment %s.\n\r", faccost * 10, weapon->description);
      use_resources(faccost, ch->faction, ch, "engineering");
    }

    weapon->buff = duration;
    if (weapon->item_type == ITEM_RANGED || weapon->item_type == ITEM_WEAPON)
    weapon->value[2] = type;
    if (IS_SET(weapon->extra_flags, ITEM_ARMORED) && get_skill(ch, SKILL_POWERARMOR) > 0)
    weapon->buff = weapon->buff * -3 / 2;
    return;
  }

  _DOFUN(do_toxin) {
    OBJ_DATA *obj;
    OBJ_DATA *obj_next;
    char arg1[MSL];
    argument = one_argument_nouncap(argument, arg1);

    if (get_skill(ch, SKILL_PARALYTIC) <= 0 && get_skill(ch, SKILL_POISONTOXIN) <= 0) {
      send_to_char("You don't know how to do that.\n\r", ch);
      return;
    }

    OBJ_DATA *weapon = NULL;
    for (obj = ch->carrying; obj != NULL; obj = obj_next) {
      obj_next = obj->next_content;

      if (IS_SET(obj->extra_flags, ITEM_WARDROBE))
      continue;

      if (obj->item_type != ITEM_WEAPON && obj->item_type != ITEM_RANGED && !IS_SET(obj->extra_flags, ITEM_ARMORED))
      continue;

      if (is_name(arg1, obj->name)) {
        weapon = obj;
        break;
      }
    }
    if (weapon == NULL) {
      send_to_char("Augment what?\n\r", ch);
      return;
    }
    if (weapon->buff > 0) {
      send_to_char("That weapon has already been augmented with something else.\n\r", ch);
      return;
    }
    if (!str_cmp(argument, "paralytic")) {
      if (get_skill(ch, SKILL_PARALYTIC) <= 0) {
        send_to_char("You don't know how to do that.\n\r", ch);
        return;
      }
      int cost = 100;
      int faccost = 0;
      int cashcost = 0;
      if (has_trust(ch, TRUST_RESOURCES, ch->faction) && clan_lookup(ch->faction)->resource >= 8000 + faccost && can_spend_resources(clan_lookup(ch->faction)))
      faccost = cost / 10;
      else
      cashcost = cost * 100;

      if (ch->money < cashcost && cashcost > 0) {
        printf_to_char(ch, "You'd need at least %d dollars to do that.\n\r", cashcost / 100);
        return;
      }
      if (faccost > 0 && clan_lookup(ch->faction)->resource < 8000 + faccost) {
        printf_to_char(ch, "That costs $%d in society resources.\n\r", faccost * 10);
        return;
      }
      if (cashcost > 0) {
        ch->money -= cashcost;
      }
      else if (faccost > 0) {
        use_resources(faccost, ch->faction, ch, "toxins");
      }
      if (in_fight(ch)) {
        if (is_super(ch))
        ch->debuff += 30;
        else
        ch->debuff += 5;
      }
      weapon->buff = 1;
      weapon->value[2] = AMMO_PARALYTIC;
      printf_to_char(ch, "You carefully apply a paralytic toxin to %s.\n\r", obj->description);
      return;
    }
    else if (!str_cmp(argument, "poison")) {
      if (get_skill(ch, SKILL_POISONTOXIN) <= 0) {
        send_to_char("You don't know how to do that.\n\r", ch);
        return;
      }
      int cost = 100;
      int faccost = 0;
      int cashcost = 0;
      if (has_trust(ch, TRUST_RESOURCES, ch->faction) && clan_lookup(ch->faction)->resource >= 8000 + faccost && can_spend_resources(clan_lookup(ch->faction)))
      faccost = cost / 10;
      else
      cashcost = cost * 100;

      if (ch->money < cashcost && cashcost > 0) {
        printf_to_char(ch, "You'd need at least %d dollars to do that.\n\r", cashcost / 100);
        return;
      }
      if (faccost > 0 && clan_lookup(ch->faction)->resource < 8000 + faccost) {
        printf_to_char(ch, "That costs $%d in society resources.\n\r", faccost * 10);
        return;
      }
      if (cashcost > 0) {
        ch->money -= cashcost;
      }
      else if (faccost > 0) {
        use_resources(faccost, ch->faction, ch, "toxins");
      }
      if (in_fight(ch)) {
        if (is_super(ch))
        ch->debuff += 30;
        else
        ch->debuff += 5;
      }

      weapon->buff = 1;
      weapon->value[2] = AMMO_POISON;
      printf_to_char(ch, "You carefully apply a poisonous toxin to %s.\n\r", obj->description);
      return;
    }
    else
    send_to_char("Syntax: Toxin (object) paralytic/poison\n\r", ch);
  }

  _DOFUN(do_trace) {
    char arg1[MSL];
    argument = one_argument_nouncap(argument, arg1);

    if (!has_computer(ch)) {
      send_to_char("You need a computer to do that.\n\r", ch);
      return;
    }

    if (!str_cmp(arg1, "scan")) {
      if (ch->pcdata->tracing == NULL) {
        send_to_char("You're not tracing anyone.\n\r", ch);
        return;
      }
      if (get_phone(ch->pcdata->tracing) == NULL) {
        send_to_char("You lose the signal.\n\r", ch);
        ch->pcdata->tracing = NULL;
        return;
      }
      if (!in_haven(ch->pcdata->tracing->in_room)) {
        send_to_char("You lose the signal.\n\r", ch);
        ch->pcdata->tracing = NULL;
        return;
      }

      printf_to_char(ch, "%s\n\r", ch->pcdata->tracing->in_room->name);
      return;
    }
    else if (!str_cmp(arg1, "cameras")) {
      if (ch->pcdata->tracing == NULL) {
        send_to_char("You're not tracing anyone.\n\r", ch);
        return;
      }
      if (get_phone(ch->pcdata->tracing) == NULL) {
        send_to_char("You lose the signal.\n\r", ch);
        ch->pcdata->tracing = NULL;
        return;
      }
      if (!in_haven(ch->pcdata->tracing->in_room)) {
        send_to_char("You lose the signal.\n\r", ch);
        ch->pcdata->tracing = NULL;
        return;
      }

      if (!public_room(ch->pcdata->tracing->in_room)) {
        send_to_char("You can't locate a usable camera.\n\r", ch);
        return;
      }
      ROOM_INDEX_DATA *orig_room = ch->in_room;
      char_from_room(ch);
      char_to_room(ch, ch->pcdata->tracing->in_room);
      do_function(ch, &do_look, "");
      char_from_room(ch);
      char_to_room(ch, orig_room);
      WAIT_STATE(ch, PULSE_PER_SECOND * 10);
    }
    else if (!str_cmp(arg1, "gps")) {
      if (ch->pcdata->tracing == NULL) {
        send_to_char("You're not tracing anyone.\n\r", ch);
        return;
      }
      if (get_phone(ch->pcdata->tracing) == NULL) {
        send_to_char("You lose the signal.\n\r", ch);
        ch->pcdata->tracing = NULL;
        return;
      }
      if (!in_haven(ch->pcdata->tracing->in_room)) {
        send_to_char("You lose the signal.\n\r", ch);
        ch->pcdata->tracing = NULL;
        return;
      }

      ROOM_INDEX_DATA *orig_room = ch->in_room;
      char_from_room(ch);
      char_to_room(ch, ch->pcdata->tracing->in_room);
      maketownmap(ch);
      char_from_room(ch);
      char_to_room(ch, orig_room);
      WAIT_STATE(ch, PULSE_PER_SECOND * 25);
    }
    else if (!str_cmp(arg1, "jam")) {
      if (ch->pcdata->tracing == NULL) {
        send_to_char("You're not tracing anyone.\n\r", ch);
        return;
      }
      if (get_skill(ch, SKILL_HACKING) < 3) {
        send_to_char("You don't know how to do that.\n\r", ch);
        return;
      }
      if (get_phone(ch->pcdata->tracing) == NULL) {
        send_to_char("You lose the signal.\n\r", ch);
        ch->pcdata->tracing = NULL;
        return;
      }
      if (!in_haven(ch->pcdata->tracing->in_room)) {
        send_to_char("You lose the signal.\n\r", ch);
        ch->pcdata->tracing = NULL;
        return;
      }

      AFFECT_DATA af;
      af.where = TO_AFFECTS;
      af.type = 0;
      af.level = 10;
      af.duration = 12 * 60;
      af.location = APPLY_NONE;
      af.modifier = 0;
      af.caster = NULL;
      af.weave = FALSE;
      af.bitvector = AFF_SILENCED;
      affect_to_char(ch->pcdata->tracing, &af);
      send_to_char("You start jamming their communications.\n\r", ch);
    }
    else if (is_number(arg1)) {

      int cost = 200;
      cost = cost * (100 - (get_skill(ch, SKILL_HACKING) * 15)) / 100;
      int faccost = 0;
      int cashcost = 0;
      if (has_trust(ch, TRUST_RESOURCES, ch->faction) && clan_lookup(ch->faction)->resource >= 8000 + faccost && can_spend_resources(clan_lookup(ch->faction)))
      faccost = cost / 10;
      else
      cashcost = cost * 100;

      if (ch->money < cashcost && cashcost > 0) {
        printf_to_char(ch, "You'd need at least %d dollars to do that.\n\r", cashcost / 100);
        return;
      }
      if (faccost > 0 && clan_lookup(ch->faction)->resource < 8000 + faccost) {
        printf_to_char(ch, "That costs $%d in society resources.\n\r", faccost * 10);
        return;
      }

      int number = atoi(arg1);
      OBJ_DATA *obj;
      for (ObjList::iterator it = object_list.begin(); it != object_list.end();
      ++it) {
        obj = *it;

        if (obj->item_type != ITEM_PHONE || obj->value[0] != number)
        continue;
        else if (IS_SET(obj->extra_flags, ITEM_OFF))
        continue;
        else if (IS_SET(obj->extra_flags, ITEM_WARDROBE))
        continue;

        if (obj->carried_by != NULL && in_haven(obj->carried_by->in_room)) {
          ch->pcdata->tracing = obj->carried_by;
          send_to_char("You lock onto a signal.\n\r", ch);
          if (cashcost > 0) {
            printf_to_char(ch, "For %d dollars you lock onto a signal.\n\r", cashcost / 100);
            ch->money -= cashcost;
          }
          else if (faccost > 0) {
            printf_to_char(
            ch, "For $%d society resources you lock onto a signal.\n\r", faccost * 10);
            use_resources(faccost, ch->faction, ch, "IT");
          }

          return;
        }
        if (obj->in_obj != NULL && obj->in_obj->carried_by != NULL) {
          ch->pcdata->tracing = obj->in_obj->carried_by;
          send_to_char("You lock onto a signal.\n\r", ch);
          if (cashcost > 0) {
            printf_to_char(ch, "For %d dollars you lock onto a signal.\n\r");
            ch->money -= cashcost;
          }
          else if (faccost > 0) {
            printf_to_char(
            ch, "For $%d society resources you lock onto a signal.\n\r", faccost * 10);
            use_resources(faccost, ch->faction, ch, "IT");
          }

          return;
        }
      }
      send_to_char("You can't find a signal.\n\r", ch);
    }
    else
    send_to_char("Syntax: Trace (number)/scan/cameras/jam\n\r", ch);
  }

  CHAR_DATA *get_tracer(CHAR_DATA *ch) {
    CHAR_DATA *victim;
    for (DescList::iterator it = descriptor_list.begin();
    it != descriptor_list.end(); ++it) {
      DESCRIPTOR_DATA *d = *it;
      if (d->connected != CON_PLAYING)
      continue;
      victim = CH(d);
      if (victim == NULL)
      continue;
      if (IS_NPC(victim))
      continue;
      if (ch == victim)
      continue;

      if (!has_computer(victim) || victim->recent_moved > -100)
      continue;

      if (victim->pcdata->tracing != NULL && victim->pcdata->tracing == ch)
      return victim;
    }
    return NULL;
  }

  _DOFUN(do_brainwash) {
    char arg1[MSL];
    char arg2[MSL];
    bool faction = TRUE;
    if (safe_strlen(argument) < 2) {
      send_to_char("Syntax: Brainwash implant/loyalty/pacifist/reidentity/cleanse/reversal (person) (arguments)\n\r", ch);
      return;
    }
    argument = one_argument_nouncap(argument, arg1);
    argument = one_argument_nouncap(argument, arg2);
    CHAR_DATA *victim;
    if ((victim = get_char_room(ch, NULL, arg2)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (is_ghost(ch)) {
      send_to_char("Slaying the living is no longer so simple./n/r", ch);
      return;
    }

    if (is_ghost(victim)) {
      send_to_char("Slaying a ghost is not so simple./n/r", ch);
      return;
    }
    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (!is_helpless(victim)) {
      send_to_char("You'd have to subdue them first.\n\r", ch);
      return;
    }
    if (!str_cmp(ch->in_room->subarea, "detention")) {
      faction = FALSE;
    }

    if (faction == TRUE) {
      if (!brainwash_room(ch->in_room)) {
        send_to_char("You need to be in a brainwashing facility to do that.\n\r", ch);
        return;
      }

      if (!has_trust(ch, TRUST_BRAINWASH, ch->faction)) {
        send_to_char("You aren't authorized to use this facility.\n\r", ch);
        return;
      }

      if (clan_lookup(ch->faction)->resource < 8000) {
        send_to_char("Your society lacks the resources to effectively operate this macherinery.\n\r", ch);
        return;
      }
    }
    if (!str_cmp(arg1, "implant")) {
      if (get_skill(ch, SKILL_MEDICINE) < 4) {
        send_to_char("You don't have the medical knowledge to be able to attempt an operation.\n\r", ch);
        return;
      }
      if (under_understanding(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }
      if (under_limited(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }

      if (victim->pcdata->implant_frequency == 0)
      victim->pcdata->implant_frequency = victim->id;

      OBJ_DATA *obj = create_object(get_obj_index(37), 0);
      obj->value[0] = victim->pcdata->implant_frequency;
      obj_to_char(obj, ch);
      wound_char_absolute(victim, 2);
      victim->pcdata->sleeping = 100;
      act("You successfully implant a control device into $N.", ch, NULL, victim, TO_CHAR);
      act("$n successfully implants something into $N.", ch, NULL, victim, TO_NOTVICT);
      if (faction == TRUE) {
        use_resources(500, ch->faction, ch, "a control implant");
        send_log(ch->faction, "Someone spent resources on brainwashing.");
      }
      return;
    }
    else if (!str_cmp(arg1, "neutralizer")) {
      if (get_skill(ch, SKILL_MEDICINE) < 4) {
        send_to_char("You don't have the medical knowledge to be able to attempt an operation.\n\r", ch);
        return;
      }

      if (under_understanding(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }
      if (under_limited(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }

      victim->pcdata->neutralized = 1;
      wound_char_absolute(victim, 2);
      victim->pcdata->sleeping = 50;
      act("You successfully implant a neutralizer into $N.", ch, NULL, victim, TO_CHAR);
      act("$n successfully implants something into $N.", ch, NULL, victim, TO_NOTVICT);
      if (faction == TRUE) {
        use_resources(100, ch->faction, ch, "a neutralizer implant");
        send_log(ch->faction, "Someone spent resources on brainwashing.");
      }
      return;
    }
    else if (!str_cmp(arg1, "extraction")) {
      if (under_understanding(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }
      if (victim->wounds > 0) {
        send_to_char("They're too badly hurt for that surgery.\n\r", ch);
        return;
      }
      if (victim->pcdata->neutralized != 1) {
        send_to_char("There's no sign of a neutralizing implant in them.\n\r", ch);
        return;
      }
      int chance = 10 + get_skill(ch, SKILL_MEDICINE) * 2 +
      get_skill(ch, SKILL_ENGINEERING) * 2;
      if (chance > number_range(1, 232432) % 100) {
        victim->pcdata->neutralized = 0;
        send_to_char("You successfully find and extract the neutralizing implant.\n\r", ch);
      }
      else {
        send_to_char("You fail to extract the implant.\n\r", ch);
      }
      wound_char_absolute(victim, 2);
      victim->pcdata->sleeping = 50;
      act("$n performs surgery on $N.", ch, NULL, victim, TO_NOTVICT);
      if (faction == TRUE) {
        use_resources(100, ch->faction, ch, "an implant extraction");
        send_log(ch->faction, "Someone spent resources on brainwashing.");
      }
      return;
    }
    else if (!str_cmp(arg1, "loyalty")) {
      if (under_understanding(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }
      if (under_limited(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }

      if (victim->pcdata->mindmessed > current_time) {
        send_to_char("Their mind has been messed with too recently.\n\r", ch);
        return;
      }
      if (safe_strlen(argument) < 2) {
        send_to_char("Syntax: Brainwash loyalty (target) (factionname/personname)\n\r", ch);
        return;
      }
      if (faction == FALSE) {
        send_to_char("Detention is not equipped for loyalty brainwashing.\n\r", ch);
        return;
      }

      free_string(victim->pcdata->brainwash_loyalty);
      victim->pcdata->brainwash_loyalty = str_dup(argument);
      victim->pcdata->mindmessed = current_time + (3600 * 24 * 25);
      if (ch != victim)
      victim->pcdata->vbloodcool = current_time + (3600 * 24 * 7);
      printf_to_char(ch, "You make them loyal to %s.\n\r", argument);
      printf_to_char(victim, "You are now loyal to %s.\n\r", argument);
      return;

    }
    else if (!str_cmp(arg1, "pacifist")) {
      if (under_understanding(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }
      if (under_limited(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }

      if (victim->pcdata->mindmessed > current_time) {
        send_to_char("Their mind has been messed with too recently.\n\r", ch);
        return;
      }
      victim->pcdata->mindmessed = current_time + (3600 * 24 * 25);
      if (ch != victim)
      victim->pcdata->vbloodcool = current_time + (3600 * 24 * 7);
      if (!IS_FLAG(victim->comm, COMM_FORCEDPACIFIST))
      SET_FLAG(victim->comm, COMM_FORCEDPACIFIST);
      send_to_char("You make them a pacifist.\n\r", ch);
      send_to_char("You are now a pacifist.\n\r", victim);
      return;
    }
    else if (!str_cmp(arg1, "reidentity")) {
      if (under_understanding(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }
      if (under_limited(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }

      if (victim->pcdata->mindmessed > current_time) {
        send_to_char("Their mind has been messed with too recently.\n\r", ch);
        return;
      }
      if (safe_strlen(argument) < 2) {
        send_to_char("Syntax: Brainwash reidentity (target) (new identity)\n\r", ch);
        return;
      }
      victim->pcdata->mindmessed = current_time + (3600 * 24 * 25);
      if (ch != victim)
      victim->pcdata->vbloodcool = current_time + (3600 * 24 * 7);
      free_string(victim->pcdata->brainwash_reidentity);
      victim->pcdata->brainwash_reidentity = str_dup(argument);
      printf_to_char(ch, "You reprogram them to believe they are %s.\n\r", argument);
      printf_to_char(victim, "You now believe you are %s.\n\r", argument);
      return;

    }
    else if (!str_cmp(arg1, "cleanse")) {
      if (under_understanding(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }

      if (victim->pcdata->mindmessed > current_time) {
        send_to_char("Their mind has been messed with too recently.\n\r", ch);
        return;
      }
      victim->pcdata->mindmessed = current_time + (3600 * 24 * 25);
      if (ch != victim)
      victim->pcdata->vbloodcool = current_time + (3600 * 24 * 7);
      if (!IS_FLAG(victim->comm, COMM_CLEANSED))
      SET_FLAG(victim->comm, COMM_CLEANSED);
      send_to_char("You cleanse them of all bad and dark memories.\n\r", ch);
      send_to_char("You forget all your bad memories, and all those that were dark or evil, you forget ever wanting to do anything bad to others.\n\r", victim);
      return;
    }
    else if (!str_cmp(arg1, "reversal")) {
      if (under_understanding(victim, ch)) {
        send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
        return;
      }

      if (victim->pcdata->mindmessed > current_time) {
        send_to_char("Their mind has been messed with too recently.\n\r", ch);
        return;
      }
      if (IS_FLAG(victim->comm, COMM_CLEANSED))
      REMOVE_FLAG(victim->comm, COMM_CLEANSED);
      if (IS_FLAG(victim->comm, COMM_FORCEDPACIFIST))
      REMOVE_FLAG(victim->comm, COMM_FORCEDPACIFIST);
      free_string(victim->pcdata->brainwash_reidentity);
      victim->pcdata->brainwash_reidentity = str_dup("");
      free_string(victim->pcdata->brainwash_loyalty);
      victim->pcdata->brainwash_loyalty = str_dup("");
      for (int i = 0; i < 25; i++) {
        if (safe_strlen(victim->pcdata->memories[i]) > 2) {
          printf_to_char(victim, "You forget %s.\n\r", victim->pcdata->memories[i]);
          free_string(victim->pcdata->memories[i]);
          victim->pcdata->memories[i] = str_dup("");
        }
        if (safe_strlen(victim->pcdata->repressions[i]) > 2) {
          printf_to_char(victim, "You remember %s.\n\r", victim->pcdata->repressions[i]);
          free_string(victim->pcdata->repressions[i]);
          victim->pcdata->repressions[i] = str_dup("");
        }
      }
      send_to_char("You are yourself again.\n\r", victim);
      send_to_char("You remove any brainwashing from them.\n\r", ch);
      return;
    }
    else
    send_to_char("Syntax: Brainwash implant/loyalty/pacifist/reidentity/cleanse/reversal (person) (arguments)\n\r", ch);
  }

  OBJ_DATA *get_controller(CHAR_DATA *ch) {
    OBJ_DATA *phone;
    if ((phone = get_held(ch, ITEM_TRASH)) != NULL && phone->pIndexData->vnum == 37)
    return phone;

    for (phone = ch->carrying; phone != NULL; phone = phone->next_content) {
      if (phone->wear_loc != WEAR_NONE || IS_SET(phone->extra_flags, ITEM_WARDROBE))
      continue;

      if (phone->pIndexData->vnum != 37)
      continue;

      return phone;
    }
    return NULL;
  }

  bool faction_slave(CHAR_DATA *ch, CHAR_DATA *victim) {
    if (clan_lookup(ch->fcore) != NULL) {
      if (ch->fcore == victim->fcore || ch->fcore == victim->fcore) {
        if (clan_lookup(ch->fcore)->axes[AXES_SUPERNATURAL] == AXES_FARLEFT && seems_super(ch) && !seems_super(victim))
        return TRUE;
        if (clan_lookup(ch->fcore)->axes[AXES_SUPERNATURAL] == AXES_FARRIGHT && !seems_super(ch) && seems_super(victim))
        return TRUE;
        if (clan_lookup(ch->fcore)->axes[AXES_CORRUPT] <= AXES_FARLEFT && get_tier(ch) > 2 && get_tier(victim) <= 2)
        return TRUE;
        if (clan_lookup(ch->fcore)->axes[AXES_CORRUPT] <= AXES_NEARLEFT && get_tier(ch) > 1 && get_tier(victim) <= 1)
        return TRUE;
      }
    }

    if (clan_lookup(ch->fcult) != NULL) {
      if (ch->fcult == victim->fcult || ch->fcult == victim->fcult) {
        if (clan_lookup(ch->fcult)->axes[AXES_SUPERNATURAL] == AXES_FARLEFT && seems_super(ch) && !seems_super(victim))
        return TRUE;
        if (clan_lookup(ch->fcult)->axes[AXES_SUPERNATURAL] == AXES_FARRIGHT && !seems_super(ch) && seems_super(victim))
        return TRUE;
        if (clan_lookup(ch->fcult)->axes[AXES_CORRUPT] <= AXES_FARLEFT && get_tier(ch) > 2 && get_tier(victim) <= 2)
        return TRUE;
        if (clan_lookup(ch->fcult)->axes[AXES_CORRUPT] <= AXES_NEARLEFT && get_tier(ch) > 1 && get_tier(victim) <= 1)
        return TRUE;
      }
    }

    if (clan_lookup(ch->fsect) != NULL) {
      if (ch->fsect == victim->fsect || ch->fsect == victim->fsect) {
        if (clan_lookup(ch->fsect)->axes[AXES_SUPERNATURAL] == AXES_FARLEFT && seems_super(ch) && !seems_super(victim))
        return TRUE;
        if (clan_lookup(ch->fsect)->axes[AXES_SUPERNATURAL] == AXES_FARRIGHT && !seems_super(ch) && seems_super(victim))
        return TRUE;
        if (clan_lookup(ch->fsect)->axes[AXES_CORRUPT] <= AXES_FARLEFT && get_tier(ch) > 2 && get_tier(victim) <= 2)
        return TRUE;
        if (clan_lookup(ch->fsect)->axes[AXES_CORRUPT] <= AXES_NEARLEFT && get_tier(ch) > 1 && get_tier(victim) <= 1)
        return TRUE;
      }
    }

    return FALSE;
  }

  _DOFUN(do_control) {
    char arg1[MSL];
    argument = one_argument_nouncap(argument, arg1);
    CHAR_DATA *victim;

    if (is_helpless(ch)) {
      send_to_char("You can't do that right now.\n\r", ch);
      return;
    }

    if (!str_cmp(arg1, "surrender")) {
      victim = get_char_world(ch, argument);
      if (victim == NULL) {
        send_to_char("Who do you want to surrender?\n\r", ch);
        return;
      }
      if (IS_NPC(victim)) {
        send_to_char("That doesn't work.\n\r", ch);
        return;
      }
      if (!str_cmp(victim->pcdata->brainwash_loyalty, ch->name)) {
        send_to_char("You order them to surrender.", ch);
        send_to_char("You are ordered to surrender.", victim);
        if (!IS_FLAG(victim->act, PLR_BOUND))
        SET_FLAG(victim->act, PLR_BOUND);
        act("$n ties themselves up.", victim, NULL, NULL, TO_ROOM);
      }
      else if (clan_lookup(ch->faction) != NULL && !str_cmp(victim->pcdata->brainwash_loyalty, clan_lookup(ch->faction)->name) && has_trust(ch, TRUST_PROMOTIONS, ch->faction)) {
        send_to_char("You order them to surrender.", ch);
        send_to_char("You are ordered to surrender.", victim);
        if (!IS_FLAG(victim->act, PLR_BOUND))
        SET_FLAG(victim->act, PLR_BOUND);
        act("$n ties themselves up.", victim, NULL, NULL, TO_ROOM);
      }
      else
      send_to_char("Who do you want to surrender?\n\r", ch);
      return;
    }
    else if (!str_cmp(arg1, "incapacitate")) {
      for (DescList::iterator ik = descriptor_list.begin();
      ik != descriptor_list.end(); ++ik) {
        DESCRIPTOR_DATA *d = *ik;

        if (d->connected != CON_PLAYING)
        continue;
        CHAR_DATA *rch = CH(d);
        if (rch == NULL)
        continue;
        if (IS_NPC(rch))
        continue;

        if (safe_strlen(argument) > 1 && str_cmp(rch->name, argument))
        continue;

        if (get_controller(ch) != NULL && rch->pcdata->implant_frequency == get_controller(ch)->value[0]) {
          send_to_char("You press the button to send an incapacitating pulse.\n\r", ch);
          act("$n presses a button on a small device.", ch, NULL, NULL, TO_ROOM);
          send_to_char("You feel a sudden painful surge of electricity run through your body, then the world fades to darkness.\n\r", rch);
          act("$n suddenly convulses and then collapses.", rch, NULL, NULL, TO_ROOM);
          rch->pcdata->sleeping = 200;
        }
        if (faction_slave(ch, rch) && safe_strlen(argument) > 1) {
          send_to_char("You press the button to send an incapacitating pulse.\n\r", ch);
          act("$n presses a button on a small device.", ch, NULL, NULL, TO_ROOM);
          send_to_char("You feel a sudden painful surge of electricity run through your body, then the world fades to darkness.\n\r", rch);
          act("$n suddenly convulses and then collapses.", rch, NULL, NULL, TO_ROOM);
          rch->pcdata->sleeping = 200;
        }
      }
      return;
    }
    else if (!str_cmp(arg1, "trace")) {
      for (DescList::iterator ik = descriptor_list.begin();
      ik != descriptor_list.end(); ++ik) {
        DESCRIPTOR_DATA *d = *ik;

        if (d->connected != CON_PLAYING)
        continue;
        CHAR_DATA *rch = CH(d);
        if (rch == NULL)
        continue;
        if (IS_NPC(rch))
        continue;

        if (safe_strlen(argument) > 1 && str_cmp(rch->name, argument))
        continue;
        if (get_controller(ch) != NULL && rch->pcdata->implant_frequency == get_controller(ch)->value[0]) {
          ROOM_INDEX_DATA *orig_room = ch->in_room;
          char_from_room(ch);
          char_to_room(ch, rch->in_room);
          maketownmap(ch);
          char_from_room(ch);
          char_to_room(ch, orig_room);
          WAIT_STATE(ch, PULSE_PER_SECOND * 15);
        }
        if (faction_slave(ch, rch) && safe_strlen(argument) > 1 && !str_cmp(rch->name, argument)) {
          ROOM_INDEX_DATA *orig_room = ch->in_room;
          char_from_room(ch);
          char_to_room(ch, rch->in_room);
          maketownmap(ch);
          char_from_room(ch);
          char_to_room(ch, orig_room);
          WAIT_STATE(ch, PULSE_PER_SECOND * 15);
        }
      }
    }

    /*
    else if(!str_cmp(arg1, "detonate"))
    {
    if(get_controller(ch) == NULL)
    {
    send_to_char("You don't have a transmitter with which to do that.\n\r", ch);
    return;
    }

    send_to_char("You press the button to send a detonation signal.\n\r", ch);
    act("$n presses a button on a small device.", ch, NULL, NULL, TO_ROOM);

    for (DescList::iterator ik = descriptor_list.begin();
    ik != descriptor_list.end(); ++ik)
    {
    DESCRIPTOR_DATA *d = *ik;

    if(d->connected != CON_PLAYING)
    continue;
    CHAR_DATA *rch = CH(d);
    if(rch == NULL)
    continue;
    if(IS_NPC(rch))
    continue;

    if(rch->pcdata->implant_frequency == get_controller(ch)->value[0])
    {
    free_string(rch->pcdata->deathcause);
    rch->pcdata->deathcause = str_dup("decapitation");
    send_to_char("You feel a sudden pressure in your head.\n\r", rch);
    act("There's a strange electronic whining noise and then $n's head abruptly
    explodes.", rch, NULL, NULL, TO_ROOM); if(under_understanding(rch, ch))
    under_taint(ch, rch, 12*60*20);
    real_kill(rch, rch);
    char buf[MSL];
    }
    }

    return;
    }
    */
    else
    send_to_char("Syntax: control incapacitate, control surrender (person), control trace (person)\n\r", ch);
  }

  void process_message(CHAR_DATA *ch, int type) {
    switch (type) {
    case PROCESS_TRAVEL_PREP:
      if (ch->pcdata->process_subtype == TRAVEL_HORSE) {
        printf_to_char(ch, "You continue preparing your horse for travel.(%d minutes remaining)\n\r", ch->pcdata->process_timer);
        act("$n continues preparing $s horse for travel.", ch, NULL, NULL, TO_ROOM);
      }
      else {
        printf_to_char(ch, "You continue twisting a path through reality.(%d minutes remaining)\n\r", ch->pcdata->process_timer);
        act("Reality continues to warp slightly around $n.", ch, NULL, NULL, TO_ROOM);
      }
      break;
    case PROCESS_DRAINPC:
    case PROCESS_DRAINABOM:
      printf_to_char(ch, "You continue to drain them.(%d minutes remaining)\n\r", ch->pcdata->process_timer);
      act("$n continues the harvesting process.", ch, NULL, NULL, TO_ROOM);
      break;
    case PROCESS_EXORCISE:
      printf_to_char(ch, "You continue the exorcism.(%d minutes remaining)\n\r", ch->pcdata->process_timer);
      act("$n continues $s exorcism.", ch, NULL, NULL, TO_ROOM);
      break;
    case PROCESS_SEARCH:
      printf_to_char(ch, "You continue searching the area.(%d minutes remaining)\n\r", ch->pcdata->process_timer);
      act("$n continues searching the area.", ch, NULL, NULL, TO_ROOM);
      break;
    case PROCESS_DRAWBLOOD:
      printf_to_char(
      ch, "You continue to draw their blood.(%d minutes remaining)\n\r", ch->pcdata->process_timer);
      act("$n continues to draw blood.", ch, NULL, NULL, TO_ROOM);
      break;
    case PROCESS_EXTERMINATE:
      printf_to_char(ch, "You continue your surgery.(%d minutes remaining)\n\r", ch->pcdata->process_timer);
      act("$n continues $s surgery.", ch, NULL, NULL, TO_ROOM);
      break;
    case PROCESS_TREATING:
      printf_to_char(
      ch, "You continue to treat their wounds.(%d minutes remaining)\n\r", ch->pcdata->process_timer);
      act("$n continues to treat their patient.", ch, NULL, NULL, TO_ROOM);
      break;
    case PROCESS_EXPERIMENT:
      printf_to_char(
      ch, "You continue to experiment on them.(%d minutes remaining)\n\r", ch->pcdata->process_timer);
      act("$n continues their experiments.", ch, NULL, NULL, TO_ROOM);
      break;
    case PROCESS_FISH:
      printf_to_char(ch, "You keep waiting for a bite.\n\r");
      act("$n continues fishing.", ch, NULL, NULL, TO_ROOM);
      break;
    case PROCESS_RESEARCH:
    case PROCESS_LOOKINGUP:
      printf_to_char(ch, "You continue to research.(%d minutes remaining)\n\r", ch->pcdata->process_timer);
      act("$n continues $s research.", ch, NULL, NULL, TO_ROOM);
      break;
    case PROCESS_RITUAL:
      printf_to_char(
      ch, "You continue to cast your ritual.(%d minutes remaining)\n\r", ch->pcdata->process_timer);
      act("$n continues casting a ritual.", ch, NULL, NULL, TO_ROOM);
      break;
    case PROCESS_REPAIR:
      ch->pcdata->last_develop_type = type;
      ch->pcdata->last_develop_time = ch->pcdata->process_timer;
      printf_to_char(
      ch, "You continue repairing the structure.(%d minutes remaining)\n\r", ch->pcdata->process_timer);
      act("$n continues repairing the structure.", ch, NULL, NULL, TO_ROOM);
      break;
    case PROCESS_SHALLOWDIG:
    case PROCESS_DEEPDIG:
      ch->pcdata->last_develop_type = type;
      ch->pcdata->last_develop_time = ch->pcdata->process_timer;
      printf_to_char(
      ch, "You continue digging a pit for water.(%d minutes remaining)\n\r", ch->pcdata->process_timer);
      act("$n continues digging a pit.", ch, NULL, NULL, TO_ROOM);
      break;
    case PROCESS_FILLIN:
      ch->pcdata->last_develop_type = type;
      ch->pcdata->last_develop_time = ch->pcdata->process_timer;
      printf_to_char(ch, "You continue draining the water and filling in the pit.(%d minutes remaining)\n\r", ch->pcdata->process_timer);
      act("$n continues draining the water and filling in the pit.", ch, NULL, NULL, TO_ROOM);
      break;
    case PROCESS_SHRINE:
      ch->pcdata->last_develop_type = type;
      ch->pcdata->last_develop_time = ch->pcdata->process_timer;
      printf_to_char(ch, "You continue building a shrine.(%d minutes remaining)\n\r", ch->pcdata->process_timer);
      act("$n continues building a shrine.", ch, NULL, NULL, TO_ROOM);
      break;
    case PROCESS_NOSHRINE:
      ch->pcdata->last_develop_type = type;
      ch->pcdata->last_develop_time = ch->pcdata->process_timer;
      printf_to_char(
      ch, "You continue tearing down a shrine.(%d minutes remaining)\n\r", ch->pcdata->process_timer);
      act("$n continues tearing down a shrine.", ch, NULL, NULL, TO_ROOM);
      break;
    case PROCESS_CLEARING:
      ch->pcdata->last_develop_type = type;
      ch->pcdata->last_develop_time = ch->pcdata->process_timer;
      printf_to_char(ch, "You continue making a clearing.(%d minutes remaining)\n\r", ch->pcdata->process_timer);
      act("$n continues making a clearing.", ch, NULL, NULL, TO_ROOM);
      break;
    case PROCESS_ROAD:
      ch->pcdata->last_develop_type = type;
      ch->pcdata->last_develop_time = ch->pcdata->process_timer;
      printf_to_char(ch, "You continue making a dirt road.(%d minutes remaining)\n\r", ch->pcdata->process_timer);
      act("$n continues making a dirt road.", ch, NULL, NULL, TO_ROOM);
      break;
    case PROCESS_BUTCHER:
      printf_to_char(
      ch, "You continue to butcher the corpse.(%d minutes remaining)\n\r", ch->pcdata->process_timer);
      act("$n continues to butcher the corpse.", ch, NULL, NULL, TO_ROOM);
      break;
    case PROCESS_PAVING:
      ch->pcdata->last_develop_type = type;
      ch->pcdata->last_develop_time = ch->pcdata->process_timer;
      printf_to_char(ch, "You continue paving the road.(%d minutes remaining)\n\r", ch->pcdata->process_timer);
      act("$n continues paving the road.", ch, NULL, NULL, TO_ROOM);
      break;
    case PROCESS_RELAY:
      ch->pcdata->last_develop_type = type;
      ch->pcdata->last_develop_time = ch->pcdata->process_timer;
      printf_to_char(ch, "You continue relaying the road.(%d minutes remaining)\n\r", ch->pcdata->process_timer);
      act("$n continues relaying the road.", ch, NULL, NULL, TO_ROOM);
      break;
    }
  }

  _DOFUN(do_healthtimer) {
    if (is_gm(ch) && pc_pop(ch->in_room) > 0) {
      if (!IS_FLAG(ch->comm, COMM_RUNNING)) {
        send_to_char("You aren't running this room.\n\r", ch);
        return;
      }
      CHAR_DATA *victim;
      for (CharList::iterator it = ch->in_room->people->begin();
      it != ch->in_room->people->end(); ++it) {
        victim = *it;

        if (victim == NULL)
        continue;

        if (victim->in_room == NULL)
        continue;

        if (IS_NPC(victim))
        continue;

        if (victim->wounds == 3) {
          victim->death_timer = 720;
          printf_to_char(ch, "You reset %s's bleed out timer.\n\r", NAME(victim));
        }
      }
      return;
    }
    if (in_fight(ch)) {
      do_function(ch, &do_ability, "heal");
      return;
    }
    if (ch->pcdata->healthtimer != 0) {
      send_to_char("You disable the health timer.\n\r", ch);
      ch->pcdata->healthtimer = 0;
    }
    else {
      send_to_char("You enable regular health break reminders.\n\r", ch);
      ch->pcdata->healthtimer = 1;
    }
  }

  _DOFUN(do_banktransfer) {
    char arg1[MSL];
    struct stat sb;
    char buf[MSL];
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    CHAR_DATA *victim;
    d.original = NULL;

    if (IS_FLAG(ch->act, PLR_DEAD)) {
      send_to_char("Communing with the dead requires a more personal approach.\n\r", ch);
      return;
    }
    if (is_gm(ch) || higher_power(ch)) {
      send_to_char("Storyrunners cannot use this command.\n\r", ch);
      return;
    }

    argument = one_argument_nouncap(argument, arg1);

    if (!cell_signal(ch))
    return;
    if (is_helpless(ch))
    return;
    if (is_town_blackout())
    return;
    if (IS_AFFECTED(ch, AFF_DISCREDIT)) {
      return;
    }
    if (IS_FLAG(ch->act, PLR_GUEST))
    return;
    if (IS_FLAG(ch->act, PLR_NOSAVE))
    return;

    if (is_gm(ch) || higher_power(ch))
    return;

    int amount = atoi(argument);
    if (amount > ch->pcdata->total_money / 100) {
      send_to_char("You don't have that much.\n\r", ch);
      return;
    }
    if (amount < 10) {
      send_to_char("Minimum transfer is 10 dollars.\n\r", ch);
      return;
    }
    if (ch->played / 3600 < 10)
    return;

    if ((victim = get_char_world(ch, arg1)) != NULL) // Victim is online.
    online = TRUE;
    else {
      if ((victim = get_char_world_pc(arg1)) != NULL) // Victim is online.
      online = TRUE;
      else {
        log_string("DESCRIPTOR: Bank transfer");

        if (!load_char_obj(&d, arg1)) {
          printf_to_char(ch, "\n\r%s is not a character!\n\r", capitalize(arg1));
          return;
        }

        sprintf(buf, "%s%s", PLAYER_DIR, capitalize(arg1));
        stat(buf, &sb);
        victim = d.character;
      }
    }
    if (IS_NPC(victim)) {
      if (!online)
      free_char(victim);

      send_to_char("\n\rYou can't target mobiles!\n\r", ch);
      return;
    }
    if (IS_FLAG(victim->act, PLR_DEAD)) {
      if (!online)
      free_char(victim);
      return;
    }
    if (is_gm(victim))
    return;

    if(ch == victim)
    {
      send_to_char("Money laundering is a crime.\n\r", ch);
      return;
    }
    if (!same_player(ch, victim))
    victim->pcdata->total_money += amount * 100;
    victim->pcdata->total_money -= 250;
    ch->pcdata->total_money -= amount * 100;

    sprintf(buf, "CASH: %s transfers %d to %s.\n\r", ch->name, amount, victim->name);
    log_string(buf);

    sprintf(
    buf, "You receive a bank transfer for $%d.00, minus the $2.50 transfer fee. ", amount);
    printf_to_char(ch, "You transfer $%d.00 from your bank account.\n\r", amount);
    char vname[MSL];
    sprintf(vname, "%s", victim->name);

    save_char_obj(victim, FALSE, FALSE);

    if (!online)
    free_char(victim);

    message_to_char(vname, buf);
  }

  _DOFUN(do_undo) {
    free_string(ch->pcdata->diss_target);
    ch->pcdata->diss_target = str_dup("");
    free_string(ch->pcdata->diss_message);
    ch->pcdata->diss_message = str_dup("");
    send_to_char("Feedback has been cleared and will not be sent.\n\r", ch);
  }
  _DOFUN(do_send) {
    struct stat sb;
    char buf[MSL];
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    CHAR_DATA *victim;

    if (safe_strlen(ch->pcdata->diss_target) < 1) {
      send_to_char("You have no feedback to send.\n\r", ch);
      return;
    }
    if (ch->pcdata->diss_sendable == 0) {
      send_to_char("That isn't sendable yet.\n\r", ch);
      return;
    }

    if (IS_FLAG(ch->pcdata->account->flags, ACCOUNT_NOFEEDBACK)) {
      send_to_char("Done.\n\r", ch);
      free_string(ch->pcdata->diss_message);
      ch->pcdata->diss_message = str_dup("");
      free_string(ch->pcdata->diss_target);
      ch->pcdata->diss_target = str_dup("");
      return;
    }

    d.original = NULL;

    if ((victim = get_char_world_pc(ch->pcdata->diss_target)) !=
        NULL) // Victim is online.
    online = TRUE;
    else {
      log_string("DESCRIPTOR:Send Diss");

      if (!load_char_obj(&d, ch->pcdata->diss_target)) {
        printf_to_char(ch, "\n\r%s is not a character!\n\r", capitalize(ch->pcdata->diss_target));
        return;
      }

      sprintf(buf, "%s%s", PLAYER_DIR, capitalize(ch->pcdata->diss_target));
      stat(buf, &sb);
      victim = d.character;
    }
    if (IS_NPC(victim)) {
      if (!online)
      free_char(victim);
      send_to_char("\n\rYou can't target mobiles!\n\r", ch);
      return;
    }

    sprintf(buf, "%s\nSomeone had this feedback on your roleplay: %s", victim->pcdata->messages, ch->pcdata->diss_message);

    if(!spammer(ch) && !IS_FLAG(ch->pcdata->account->flags, ACCOUNT_SHH))
    {
      free_string(victim->pcdata->messages);
      victim->pcdata->messages = str_dup(buf);
    }

    save_char_obj(victim, FALSE, FALSE);
    if (!online)
    free_char(victim);

    send_to_char("Done.\n\r", ch);
    free_string(ch->pcdata->diss_message);
    ch->pcdata->diss_message = str_dup("");
    free_string(ch->pcdata->diss_target);
    ch->pcdata->diss_target = str_dup("");
  }

  void memory_implant(CHAR_DATA *ch, int type, char *message) {
    if (type == 1) {
      for (int i = 0; i < 25; i++) {
        if (!str_cmp(message, ch->pcdata->memories[i]) || safe_strlen(ch->pcdata->memories[i]) < 2) {
          free_string(ch->pcdata->memories[i]);
          ch->pcdata->memories[i] = str_dup(message);
          printf_to_char(ch, "You have a vivid recollection of %s.\n\r", message);
          return;
        }
      }
    }
    else if (type == 2) {
      for (int i = 0; i < 25; i++) {
        if (!str_cmp(message, ch->pcdata->repressions[i]) || safe_strlen(ch->pcdata->repressions[i]) < 2) {
          free_string(ch->pcdata->repressions[i]);
          ch->pcdata->repressions[i] = str_dup(message);
          printf_to_char(ch, "You can't remember %s.\n\r", message);
          return;
        }
      }
    }
  }

  _DOFUN(do_stab) {
    CHAR_DATA *victim;
    char arg1[MSL];
    EXTRA_DESCR_DATA *ed;

    argument = one_argument_nouncap(argument, arg1);

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }
    OBJ_DATA *obj;
    if ((obj = get_obj_carry(ch, argument, ch)) == NULL) {
      send_to_char("You don't have that item.\n\r", ch);
      return;
    }
    if (is_ghost(ch)) {
      send_to_char("That might be difficult.\n\r", ch);
      return;
    }
    if (is_pinned(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (IS_NPC(victim)) {
      send_to_char("Not on NPCS.\n\r", ch);
      return;
    }
    if (is_safe(ch, victim)) {
      send_to_char("For some reason you can't bring yourself to do that.\n\r", ch);
      return;
    }
    if (in_public(ch, victim)) {
      send_to_char("It's a bit public for that.\n\r", ch);
      return;
    }
    if (!is_helpless(victim)) {
      send_to_char("They need to be restrained first.\n\r", ch);
      return;
    }
    if (obj->pIndexData->vnum == ITEM_NEEDLEPOTION) {
      act("$n injects $N with $p.", ch, obj, victim, TO_NOTVICT);
      act("You inject $N with $p.", ch, obj, victim, TO_CHAR);
      act("$n injects you with $p.", ch, obj, victim, TO_VICT);
      for (ed = obj->extra_descr; ed; ed = ed->next) {
        if (is_name("+imprint", ed->keyword)) {
          memory_implant(victim, obj->value[0], ed->description);
        }
      }
      extract_obj(obj);
      return;
    }
    else if (obj->pIndexData->vnum == 400001026) {
      if (!holding_sweapon(ch))
      equip_sweapon(ch);

      bool fail = FALSE;

      if (is_super(victim)) {
        fail = TRUE;
      }

      if (newbie_level(victim) <= 2)
      fail = TRUE;

      if (victim->pcdata->blood_potency < number_percent())
      fail = TRUE;

      if (victim->faction != 0 && number_percent() % 2 == 0)
      fail = TRUE;

      if (victim->desc == NULL) {
        char buf[MSL];
        sprintf(buf, "You half awaken to %s stabbing you with a small knife during the night.", ch->pcdata->intro_desc);
        message_to_char(victim->name, buf);
      }

      if (fail == TRUE) {
        act("You plunge your sacrificial dagger into $N's muscle, but feel nothing.", ch, NULL, victim, TO_CHAR);
        act("$n plunges $s sacrificial dagger into your muscle.", ch, NULL, victim, TO_VICT);
        act("$n plunges $s sacrificial dagger into $N's muscle.", ch, NULL, victim, TO_NOTVICT);
        victim->pcdata->blood_potency -= 3;
        if (victim->wounds == 0) {
          wound_char_absolute(victim, 1);
          victim->heal_timer /= 2;
        }
        else
        victim->heal_timer += 10000;
      }
      else {
        act("You plunge your sacrificial dagger into $N's muscle, and feel a sudden surge of power.", ch, NULL, victim, TO_CHAR);
        act("$n plunges $s sacrificial dagger into your muscle.", ch, NULL, victim, TO_VICT);
        act("$n plunges $s sacrificial dagger into $N's muscle.", ch, NULL, victim, TO_NOTVICT);
        victim->pcdata->blood_potency -= 7;
        if (victim->wounds == 0) {
          wound_char_absolute(victim, 1);
          victim->heal_timer /= 2;
        }
        else
        victim->heal_timer += 10000;

        if (!IS_FLAG(ch->comm, COMM_EMPOWERED))
        SET_FLAG(ch->comm, COMM_EMPOWERED);
      }
    }
    else
    send_to_char("You need a ritual dagger or syringe to do that with.\n\r", ch);
  }

  _DOFUN(do_cloud) {
    char arg1[MSL];

    argument = one_argument_nouncap(argument, arg1);

    if (!str_cmp(arg1, "summon")) {
      if (get_skill(ch, SKILL_CLOUDSUMMON) < 1) {
        send_to_char("You can't do that.\n\r", ch);
        return;
      }
      if (ch->pcdata->abommistcool > 0) {
        send_to_char("That ability is still on cooldown.\n\r", ch);
        return;
      }
      ch->pcdata->abommistcool = (60);

      if (in_haven(ch->in_room)) {
        time_info.local_cover_total =
        UMIN(100, time_info.local_cover_total * 3 / 2);
        time_info.local_density_total =
        UMIN(100, time_info.local_density_total + 10);

        send_to_char("You reach out and pull more clouds towards you.\n\r", ch);
      }
      else {
        ch->in_room->cloud_cover = UMIN(100, ch->in_room->cloud_cover * 3 / 2);
        ch->in_room->cloud_density = UMIN(100, ch->in_room->cloud_density + 10);
        send_to_char("You reach out and pull more clouds towards you.\n\r", ch);
      }

      return;
    }
    else if (!str_cmp(arg1, "dismiss")) {
      if (get_skill(ch, SKILL_CLOUDSUMMON) < 2) {
        send_to_char("You can't do that.\n\r", ch);
        return;
      }
      if (ch->pcdata->abommistcool > 0) {
        send_to_char("That ability is still on cooldown.\n\r", ch);
        return;
      }
      ch->pcdata->abommistcool = (60);

      if (in_haven(ch->in_room)) {
        time_info.local_cover_total =
        UMAX(0, time_info.local_cover_total * 2 / 3);
        time_info.local_density_total =
        UMAX(0, time_info.local_density_total - 10);

        send_to_char("You reach out and push more clouds away from you.\n\r", ch);
      }
      else {
        ch->in_room->cloud_cover = UMAX(0, ch->in_room->cloud_cover * 2 / 3);
        ch->in_room->cloud_density = UMAX(0, ch->in_room->cloud_density - 10);
        send_to_char("You reach out and push more clouds away from you.\n\r", ch);
      }

      return;
    }
    else
    send_to_char("Syntax: Cloud summon/dismiss\n\r", ch);
  }

  _DOFUN(do_naturalize) {
    CHAR_DATA *victim;
    if (in_fight(ch)) {
      if (get_skill(ch, SKILL_SOLDIER) < 3) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (!has_nonconsume(ch, ITEM_NATURALIZER)) {
        send_to_char("You need to have a naturalizer first.\n\r", ch);
        return;
      }
      char comtext[MSL];
      sprintf(comtext, "naturalize %s", argument);
      if (in_fight(ch) == TRUE && ch->ability_timer > 0 && ch->fight_fast == TRUE && !is_gm(ch) && get_skill(ch, SKILL_MAGICOVERLOAD) <= 0) {
        free_string(ch->abilmove);
        ch->abilmove = str_dup(comtext);
        send_to_char("Command stacked.\n\r", ch);
        return;
      }
      if (in_fight(ch) == TRUE && ch->ability_timer > FIGHT_WAIT * fight_speed(ch) && ch->fight_fast == TRUE && !is_gm(ch) && get_skill(ch, SKILL_MAGICOVERLOAD) > 0) {
        free_string(ch->abilmove);
        ch->abilmove = str_dup(comtext);
        send_to_char("Command stacked.\n\r", ch);
        return;
      }

      if (ch->fight_fast == FALSE && !is_gm(ch)) {
        if (ch->moving == TRUE) {
          send_to_char("You've already input a move this turn.\n\r", ch);
          return;
        }
        if (ch->attackdam > 0 && ch->actiontimer > 0) {
          send_to_char("You've already input a move this turn.\n\r", ch);
          return;
        }
      }

      if (ch->ability_timer > 0 && !is_gm(ch)) {
        send_to_char("You can't use another ability yet.\n\r", ch);
        return;
      }
      if (in_fight(ch) && ch->fight_fast == FALSE && ch->fight_current != ch) {
        send_to_char("It's not your turn yet.\n\r", ch);
        return;
      }

      if ((victim = get_char_fight(ch, argument)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (combat_distance(ch, victim, TRUE) > 50) {
        send_to_char("They're too far away.\n\r", ch);
        return;
      }
      if (no_tech(ch)) {
        send_to_char("It doesn't seem to be working.\n\r", ch);
        return;
      }
      if(ch->fight_fast == FALSE && (IS_FLAG(ch->fightflag, FIGHT_NOATTACK) || ch->attackdam > 0))
      {
        send_to_char("You cannot do that in the same round as you've attacked.\n\r", ch);
        return;
      }

      if (abilcool(ch, SKILL_SOLDIER, 5)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_SOLDIER, 5);

      act("You shoot $N with the naturalizer.", ch, NULL, victim, TO_CHAR);
      act("$n raises a black handgun and points it at you before pulling the trigger. There's a faint humming sound.", ch, NULL, victim, TO_VICT);
      act("$n raises a black handgun and points it at $N before pulling the trigger. There's a faint humming sound.", ch, NULL, victim, TO_NOTVICT);
      if (victim->shape != SHAPE_HUMAN)
      human_transformation(victim);

      apply_caff(victim, CAFF_NOSHIFTING, 2);
      useattack(ch);
      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) *
      ability_cooldown(ch, SKILL_SOLDIER) / 2;
      else
      ch->ability_timer +=
      FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_SOLDIER) / 2;
    }
    else {
      if (!has_nonconsume(ch, ITEM_NATURALIZER)) {
        send_to_char("You need to have a naturalizer first.\n\r", ch);
        return;
      }

      if ((victim = get_char_room(ch, NULL, argument)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (is_helpless(ch) || is_ghost(ch))
      return;

      act("You shoot at $N with the naturalizer.", ch, NULL, NULL, TO_CHAR);
      act("$n raises a black handgun replica and points it at you before pulling the trigger, there's a faint electric whining noise that follows.", ch, NULL, NULL, TO_VICT);
      act("$n raises a black handgun replica and points it at $N before pulling the trigger, there's a faint electric whining noise that follows.", ch, NULL, NULL, TO_NOTVICT);

      if (victim->shape != SHAPE_HUMAN && !is_neutralized(victim)) {
        if (is_helpless(victim)) {
          human_transformation(victim);
          AFFECT_DATA af;
          af.where = TO_AFFECTS;
          af.type = 0;
          af.level = 10;
          af.duration = 12 * 30;
          af.location = APPLY_NONE;
          af.modifier = 0;
          af.caster = NULL;
          af.weave = FALSE;
          af.bitvector = AFF_STUCKSHIFTER;
          affect_to_char(ch, &af);
        }
        else {
          int chance = get_skill(ch, SKILL_DEXTERITY) * 2;
          chance -= get_skill(victim, SKILL_FASTREFLEXES);
          chance -= get_skill(victim, SKILL_DEXTERITY);
          chance *= 5;
          chance = UMAX(chance, 15);
          if (chance > number_range(1, 232422) % 100) {
            human_transformation(victim);
            AFFECT_DATA af;
            af.where = TO_AFFECTS;
            af.type = 0;
            af.level = 10;
            af.duration = 12 * 30;
            af.location = APPLY_NONE;
            af.modifier = 0;
            af.caster = NULL;
            af.weave = FALSE;
            af.bitvector = AFF_STUCKSHIFTER;
            affect_to_char(ch, &af);
          }
          else {
            send_to_char("You miss.\n\r", ch);
          }
        }
      }
    }
  }

  _DOFUN(do_neutralize) {
    CHAR_DATA *victim;
    if (in_fight(ch)) {
      if (get_skill(ch, SKILL_RIOT) < 3) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }

      char comtext[MSL];
      sprintf(comtext, "neutralize %s", argument);
      if (in_fight(ch) == TRUE && ch->ability_timer > 0 && ch->fight_fast == TRUE && !is_gm(ch) && get_skill(ch, SKILL_MAGICOVERLOAD) <= 0) {
        free_string(ch->abilmove);
        ch->abilmove = str_dup(comtext);
        send_to_char("Command stacked.\n\r", ch);
        return;
      }
      if (in_fight(ch) == TRUE && ch->ability_timer > FIGHT_WAIT * fight_speed(ch) && ch->fight_fast == TRUE && !is_gm(ch) && get_skill(ch, SKILL_MAGICOVERLOAD) > 0) {
        free_string(ch->abilmove);
        ch->abilmove = str_dup(comtext);
        send_to_char("Command stacked.\n\r", ch);
        return;
      }

      if (ch->fight_fast == FALSE && !is_gm(ch)) {
        if (ch->moving == TRUE) {
          send_to_char("You've already input a move this turn.\n\r", ch);
          return;
        }
        if (ch->attackdam > 0 && ch->actiontimer > 0) {
          send_to_char("You've already input a move this turn.\n\r", ch);
          return;
        }
      }

      if (ch->ability_timer > 0 && !is_gm(ch)) {
        send_to_char("You can't use another ability yet.\n\r", ch);
        return;
      }
      if (in_fight(ch) && ch->fight_fast == FALSE && ch->fight_current != ch) {
        send_to_char("It's not your turn yet.\n\r", ch);
        return;
      }

      if ((victim = get_char_fight(ch, argument)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (combat_distance(ch, victim, TRUE) > 80) {
        send_to_char("They're too far away.\n\r", ch);
        return;
      }
      if (combat_distance(ch, victim, TRUE) > 40 && (get_skill(ch, SKILL_RIOT) < 3 || (get_disc(ch, DIS_RIFLES, FALSE) < 20 && get_disc(ch, DIS_CARBINES, FALSE) < 20 && get_disc(ch, DIS_SHOTGUNS, FALSE) < 20) || (!has_lgun(ch) && !holding_lgun(ch)))) {
        send_to_char("They're too far away.\n\r", ch);
        return;
      }
      if (!has_consume(ch, ITEM_NEUTRALGRENADE)) {
        send_to_char("You need to have a neutralization grenade first.\n\r", ch);
        return;
      }
      if (abilcool(ch, SKILL_RIOT, 5)) {
        send_to_char("You can't use that again yet.\n\r", ch);
        return;
      }
      else
      useabil(ch, SKILL_RIOT, 5);

      if (combat_distance(ch, victim, TRUE) > 40) {
        act("You launch a silver grenade at $N.", ch, NULL, victim, TO_CHAR);
        act("$n launches a silver grenade at you.", ch, NULL, victim, TO_VICT);
        act("$n launches a silver grenade at $N.", ch, NULL, victim, TO_NOTVICT);
      }
      else {
        act("You throw a silver grenade at $N.", ch, NULL, victim, TO_CHAR);
        act("$n throws a silver grenade at you.", ch, NULL, victim, TO_VICT);
        act("$n throws a silver grenade at $N.", ch, NULL, victim, TO_NOTVICT);
      }

      CHAR_DATA *newvict;
      for (CharList::iterator it = char_list.begin(); it != char_list.end();
      ++it) {
        newvict = *it;

        if (newvict == NULL || is_gm(newvict))
        continue;
        if (!same_fight(newvict, ch))
        continue;

        if (IS_FLAG(newvict->act, ACT_COMBATOBJ))
        continue;

        if (combat_distance(newvict, victim, FALSE) > 15)
        continue;

        if (!no_tech(ch)) {
          send_to_char("A strange pulse-like sensation runs through you.\n\r", newvict);
          apply_caff(newvict, CAFF_NEUTRALIZED, 2);
        }
      }

      if (ch->fight_fast == TRUE)
      ch->ability_timer += FIGHT_WAIT * 2 * fight_speed(ch) * ability_cooldown(ch, SKILL_RIOT) / 2;
      else
      ch->ability_timer += FIGHT_WAIT * 2 * ability_cooldown(ch, SKILL_RIOT) / 2;
    }
    else {
      if (is_helpless(ch) || is_ghost(ch)) {
        return;
      }

      if (institute_staff(ch) && clinic_patient(victim)) {
        if (ch->race == RACE_DEPUTY) {
          act("You fire a stungun at $N.  $N spasms uncontrollably and passes out.", ch, NULL, victim, TO_CHAR);
          act("$n stabs you with a syringe and a strange pulse-like sensation runs through your body.  You spasm uncontrollably and pass out.", ch, NULL, victim, TO_VICT);
          act("$n stabs $N with a syringe.  $N spasms uncontrollably and passes out.", ch, NULL, victim, TO_NOTVICT);
        }
        else {
          act("You stab $N with a syringe.", ch, NULL, victim, TO_CHAR);
          act("$n stabs you with a syringe and a strange pulse-like sensation runs through your body.  You pass out.", ch, NULL, victim, TO_VICT);
          act("$n stabs $N with a syringe.  $N crumples and passes out.", ch, NULL, victim, TO_NOTVICT);
        }

        if (!is_neutralized(victim)) {
          AFFECT_DATA af;
          af.where = TO_AFFECTS;
          af.type = 0;
          af.level = 10;
          af.duration = 3600 * 2;
          af.location = APPLY_NONE;
          af.modifier = 0;
          af.caster = NULL;
          af.weave = FALSE;
          af.bitvector = AFF_NEUTRALIZED;
          affect_to_char(victim, &af);
        }
        else {
          send_to_char("They're already neutralized.\n\r", ch);
        }
        victim->pcdata->sleeping = 400;
        return;
      }

      if (!has_consume(ch, ITEM_NEUTRALGRENADE)) {
        send_to_char("You need to have a neutralization grenade first.\n\r", ch);
        return;
      }

      act("You activate the neutralization grenade and throw it at your feet, a strange pulse-like sensation runs through you.\n\r", ch, NULL, NULL, TO_CHAR);
      act("$n takes out a grenade and throws it at $s feet, a strange pulse-like sensation runs through you.", ch, NULL, NULL, TO_ROOM);
      CHAR_DATA *newvict;
      for (CharList::iterator it = ch->in_room->people->begin();
      it != ch->in_room->people->end(); ++it) {
        newvict = *it;

        if (newvict == NULL)
        continue;

        if (newvict->in_room == NULL)
        continue;

        if (IS_NPC(newvict))
        continue;

        AFFECT_DATA af;
        af.where = TO_AFFECTS;
        af.type = 0;
        af.level = 10;
        af.duration = 12 * 20;
        af.location = APPLY_NONE;
        af.modifier = 0;
        af.caster = NULL;
        af.weave = FALSE;
        af.bitvector = AFF_NEUTRALIZED;
        affect_to_char(ch, &af);
      }
    }
  }

  _DOFUN(do_curseobject) {
    OBJ_DATA *obj;
    OBJ_DATA *obj_next;
    EXTRA_DESCR_DATA *ed;
    char arg[MSL];
    argument = one_argument_nouncap(argument, arg);
    char arg2[MSL];
    argument = one_argument_nouncap(argument, arg2);

    if (is_ghost(ch) && !higher_power(ch))
    return;

    if (!workshop_room(ch->in_room) && !higher_power(ch)) {
      send_to_char("You need to be in an arcane workshop to do that.\n\r", ch);
      return;
    }

    int cost = 75;
    int redc = UMIN(7, arcane_focus(ch) + get_skill(ch, SKILL_DARKMAGICFOCUS));
    cost = cost * (10 - redc) / 10;
    if (safe_strlen(argument) < 2 || safe_strlen(arg) < 2) {
      send_to_char("Syntax: curseobject (object) (body/mind) (imprint)\n\r", ch);
      return;
    }

    int faccost = 0;
    int cashcost = 0;
    if (ch->faction != 0 && clan_lookup(ch->faction) != NULL && has_trust(ch, TRUST_RESOURCES, ch->faction) && clan_lookup(ch->faction)->resource >= 8000 + faccost && can_spend_resources(clan_lookup(ch->faction))) {
      faccost = cost / 10;
    }
    else
    cashcost = cost * 100;

    if (ch->money < cashcost && cashcost > 0 && !higher_power(ch)) {
      printf_to_char(
      ch, "You'd need at least %d dollars in supplies to make that.\n\r", cashcost / 100);
      return;
    }
    if (faccost > 0 && ch->faction > 0 && clan_lookup(ch->faction)->resource < 8000 + faccost) {
      printf_to_char(ch, "That costs $%d in society resources.\n\r", faccost * 10);
      return;
    }
    if(str_cmp(arg2, "body") && str_cmp(arg2, "mind"))
    {
      send_to_char("Syntax: curseobject (object) (body/mind) (imprint)\n\r", ch);
      return;
    }

    if(!str_cmp(arg2, "mind"))
    {
      for (obj = ch->carrying; obj != NULL; obj = obj_next) {
        obj_next = obj->next_content;

        if (IS_SET(obj->extra_flags, ITEM_WARDROBE))
        continue;

        if (IS_SET(obj->extra_flags, ITEM_RELIC))
        continue;

        if (is_name(arg, obj->name) && can_see_obj(ch, obj)) {
          for (ed = obj->extra_descr; ed; ed = ed->next) {
            if (is_name("+imprint", ed->keyword))
            break;
          }

          if (!ed) {
            ed = new_extra_descr();
            ed->keyword = str_dup("+imprint");
            ed->next = obj->extra_descr;
            obj->extra_descr = ed;
            free_string(obj->extra_descr->description);
            obj->extra_descr->description = str_dup(argument);
          }
          else {
            free_string(ed->description);
            ed->description = str_dup(argument);
          }

          if(!higher_power(ch))  {
            if (cashcost > 0) {
              printf_to_char(ch, "For %d dollars in supplies you curse %s.\n\r", cashcost / 100, obj->description);
              ch->money -= cashcost;
            }
            else {
              printf_to_char(ch, "For $%d society resources you curse %s\n\r", faccost * 10, obj->description);
              use_resources(faccost, ch->faction, ch, "a curse");
            }
          }
          if (!IS_SET(obj->extra_flags, ITEM_CURSED))
          SET_BIT(obj->extra_flags, ITEM_CURSED);
          return;
        }
      }
    }
    if(!str_cmp(arg2, "body"))
    {
      for (obj = ch->carrying; obj != NULL; obj = obj_next) {
        obj_next = obj->next_content;

        if (IS_SET(obj->extra_flags, ITEM_WARDROBE))
        continue;

        if (IS_SET(obj->extra_flags, ITEM_RELIC))
        continue;

        if (is_name(arg, obj->name) && can_see_obj(ch, obj)) {
          for (ed = obj->extra_descr; ed; ed = ed->next) {
            if (is_name("+bimprint", ed->keyword))
            break;
          }

          if (!ed) {
            ed = new_extra_descr();
            ed->keyword = str_dup("+bimprint");
            ed->next = obj->extra_descr;
            obj->extra_descr = ed;
            free_string(obj->extra_descr->description);
            obj->extra_descr->description = str_dup(argument);
          }
          else {
            free_string(ed->description);
            ed->description = str_dup(argument);
          }

          if(!higher_power(ch))  {
            if (cashcost > 0) {
              printf_to_char(ch, "For %d dollars in supplies you curse %s.\n\r", cashcost / 100, obj->description);
              ch->money -= cashcost;
            }
            else {
              printf_to_char(ch, "For $%d society resources you curse %s\n\r", faccost * 10, obj->description);
              use_resources(faccost, ch->faction, ch, "a curse");
            }
          }
          if (!IS_SET(obj->extra_flags, ITEM_CURSED))
          SET_BIT(obj->extra_flags, ITEM_CURSED);
          return;
        }
      }
    }
    send_to_char("Syntax: curseobject (object) (body/mind) (imprint)\n\r", ch);
  }

  _DOFUN(do_makepotion) {
    OBJ_DATA *obj;
    EXTRA_DESCR_DATA *ed;
    char arg[MSL];
    argument = one_argument_nouncap(argument, arg);

    if (!alchemy_room(ch->in_room)) {
      send_to_char("You need to be in an alchemical facility to do that.\n\r", ch);
      return;
    }

    int cost = 50;
    if (ch->race == RACE_FACULTY)
    cost = cost / 2;

    if (safe_strlen(arg) < 2 || safe_strlen(argument) < 2) {
      send_to_char("Syntax: makepotion (type) (message)\n\r", ch);
      return;
    }

    cost = cost * (5 - get_skill(ch, SKILL_ALCHEMY)) / 5;
    int faccost = 0;
    int cashcost = 0;
    if (has_trust(ch, TRUST_RESOURCES, ch->faction) && clan_lookup(ch->faction)->resource >= 8000 + faccost && can_spend_resources(clan_lookup(ch->faction))) {
      faccost = cost / 10;
    }
    else
    cashcost = cost * 100;

    if (ch->money < cashcost && cashcost > 0) {
      printf_to_char(
      ch, "You'd need at least %d dollars in supplies to make that.\n\r", cashcost / 100);
      return;
    }
    if (faccost > 0 && clan_lookup(ch->faction)->resource < 8000 + faccost) {
      printf_to_char(ch, "That costs $%d in society resources.\n\r", faccost * 10);
      return;
    }

    if (!str_cmp(arg, "memory")) {
      obj = create_object(get_obj_index(ITEM_NEEDLEPOTION), 0);
      obj_to_char(obj, ch);
      obj->value[0] = 1;
      for (ed = obj->extra_descr; ed; ed = ed->next) {
        if (is_name("+imprint", ed->keyword))
        break;
      }

      if (!ed) {
        ed = new_extra_descr();
        ed->keyword = str_dup("+imprint");
        ed->next = obj->extra_descr;
        obj->extra_descr = ed;
        free_string(obj->extra_descr->description);
        obj->extra_descr->description = str_dup(argument);
      }
      else {
        free_string(ed->description);
        ed->description = str_dup(argument);
      }
      if (cashcost > 0) {
        printf_to_char(ch, "For %d dollars in supplies you create a syringe carrying the memory of: %s\n\r", cashcost / 100, argument);
        ch->money -= cashcost;
        return;
      }
      else {
        printf_to_char(ch, "For $%d society resources you create a syringe carrying the memory of: %s\n\r", faccost * 10, argument);
        use_resources(faccost, ch->faction, ch, "a potion");

        return;
      }
    }
    else if (!str_cmp(arg, "repression")) {
      obj = create_object(get_obj_index(ITEM_NEEDLEPOTION), 0);
      obj_to_char(obj, ch);
      obj->value[0] = 2;
      for (ed = obj->extra_descr; ed; ed = ed->next) {
        if (is_name("+imprint", ed->keyword))
        break;
      }

      if (!ed) {
        ed = new_extra_descr();
        ed->keyword = str_dup("+imprint");
        ed->next = obj->extra_descr;
        obj->extra_descr = ed;
        free_string(obj->extra_descr->description);
        obj->extra_descr->description = str_dup(argument);
      }
      else {
        free_string(ed->description);
        ed->description = str_dup(argument);
      }
      if (cashcost > 0) {
        printf_to_char(ch, "For %d dollars in supplies you create a syringe carrying the memory of: %s\n\r", cashcost / 100, argument);
        ch->money -= cashcost;
        return;
      }
      else {
        printf_to_char(ch, "For $%d society resources you create a syringe carrying the memory of: %s\n\r", faccost * 10, argument);
        use_resources(faccost, ch->faction, ch, "a potion");
        return;
      }
    }
    send_to_char("Valid types are memory and repression.\n\r", ch);
  }

  _DOFUN(do_dayactivate) {
    if (ch->pcdata->ci_editing == 12) {
      ch->pcdata->ci_absorb = 1;
      int num = atoi(argument);
      if (num == 0 && ch->pcdata->ci_discipline != COMPETE_CLOSED) {
        send_to_char("Syntax: Day (1-10)\n\r", ch);
        return;
      }
      else if (num < 0 || num > 10) {
        send_to_char("Syntax: Day (1-10)\n\r", ch);
        return;
      }
      ch->pcdata->ci_vnum = num;
      send_to_char("Done.\n\r", ch);
    }
  }

  void werewolf_live_kill(CHAR_DATA *ch) {
    if (in_fight(ch) || is_helpless(ch) || is_pinned(ch) || room_hostile(ch->in_room) || locked_room(ch->in_room, ch))
    return;

    ch->pcdata->lastaccident = current_time;
    send_to_char("Everything goes red and you come back to yourself a little while later.\n\r", ch);
    act("$n leaves.", ch, NULL, NULL, TO_ROOM);
    WAIT_STATE(ch, PULSE_PER_SECOND * 15);
    char_from_room(ch);
    char_to_room(ch, random_inner_forest());
    AFFECT_DATA af;
    af.where = TO_AFFECTS;
    af.type = 0;
    af.level = 10;
    af.duration = 12 * 60 * 4;
    af.location = APPLY_NONE;
    af.modifier = 0;
    af.caster = NULL;
    af.weave = FALSE;
    af.bitvector = AFF_MARKED;
    affect_to_char(ch, &af);
    habit_corpse(ch, "Animal attack");
    coverup_cost(ch, 2);

    if (number_percent() % 3 == 0) {
      NEWS_TYPE *news;
      news = new_news();
      news->timer = 1500;
      free_string(news->message);
      news->message = str_dup("A Haven resident was found critically injured from an animal attack last night.");
      free_string(news->author);
      news->author = str_dup("Town Events");
      NewsVect.push_back(news);
    }
  }

  _DOFUN(do_ammochange) {
    OBJ_DATA *obj;
    OBJ_DATA *obj_next;

    OBJ_DATA *weapon = NULL;
    for (obj = ch->carrying; obj != NULL; obj = obj_next) {
      obj_next = obj->next_content;

      if (IS_SET(obj->extra_flags, ITEM_WARDROBE))
      continue;

      if (obj->item_type != ITEM_RANGED && obj->item_type != ITEM_WEAPON)
      continue;
      if (is_name(argument, obj->name)) {
        weapon = obj;
        break;
      }
    }

    if (weapon == NULL) {
      send_to_char("Change the ammo on what?\n\r", ch);
      return;
    }
    if (is_helpless(ch) || is_pinned(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (weapon->value[2] == 0) {
      send_to_char("That weapon doesn't have any sort of augmentation.\n\r", ch);
      return;
    }

    if (in_fight(ch) && default_ranged(ch) != DIS_BOWS && default_ranged(ch) != DIS_THROWN && get_skill(ch, SKILL_QUICKRELOAD) <= 0)
    useattack(ch);

    if (IS_SET(weapon->extra_flags, ITEM_AMMOCHANGED)) {
      REMOVE_BIT(weapon->extra_flags, ITEM_AMMOCHANGED);
      send_to_char("You load in your augmented amunition.\n\r", ch);
      return;
    }
    else {
      SET_BIT(weapon->extra_flags, ITEM_AMMOCHANGED);
      send_to_char("You replace your augmented amunition with more mundane types for now.\n\r", ch);
      return;
    }
  }

  char *const contact_job_names[] = {
    "Idle", "Muscle", "Reputation", "Schemes",
    "Influence", "Capital", "Politics", "Planning",
    "Labor"
  };

  int skillpoint_by_vnum(int num) {
    for (int i = 0; i < SKILL_USED; i++) {
      if (skill_table[i].vnum == num)
      return i;
    }
    return 0;
  }

  _DOFUN(do_contact) {
    char arg1[MSL];
    char arg2[MSL];

    if (!str_cmp(argument, "")) {
      send_to_char("`WContacts`x\n\r", ch);
      
      for (int i = 0; i < MAX_CONTACTS; i++) {
        if (get_skill(ch, contacts_table[i]) > 0) {
          printf_to_char(ch, "Level %d %s Contact: %s\n\r", get_skill(ch, contacts_table[i]), skill_table[skillpoint_by_vnum(contacts_table[i])].name, ch->pcdata->contact_names[i]);
          if (ch->pcdata->contact_jobs[i] == 0) {
            if (ch->pcdata->contact_cooldowns[i] > current_time)
            printf_to_char(ch, "Job: Recovering\n\r");
            else
            printf_to_char(ch, "Job: Idle\n\r");
          }
          else
          printf_to_char(ch, "Job: %s\n\r", contact_job_names[ch->pcdata->contact_jobs[i]]);
          printf_to_char(ch, "Desc: %s\n\n\r", ch->pcdata->contact_descs[i]);
        }
      }
      return;
    }
    argument = one_argument_nouncap(argument, arg1);

    if (!str_cmp(arg1, "name")) {
      argument = one_argument_nouncap(argument, arg2);
      for (int i = 0; i < MAX_CONTACTS; i++) {
        if (get_skill(ch, contacts_table[i]) > 0 && (!str_cmp(arg2, skill_table[skillpoint_by_vnum(contacts_table[i])].name) || !str_cmp(arg2, ch->pcdata->contact_names[i]))) {
          if (safe_strlen(argument) < 2) {
            send_to_char("Name them what?\n\r", ch);
            return;
          }
          free_string(ch->pcdata->contact_names[i]);
          ch->pcdata->contact_names[i] = str_dup(argument);
          printf_to_char(ch, "Your %s contact is now named %s.\n\r", skill_table[skillpoint_by_vnum(contacts_table[i])].name, ch->pcdata->contact_names[i]);
          return;
        }
      }
      send_to_char("Syntax: Contact name (Occult/Government etc) (New name)\n\r", ch);
      return;
    }
    if (!str_cmp(arg1, "description")) {
      argument = one_argument_nouncap(argument, arg2);
      for (int i = 0; i < MAX_CONTACTS; i++) {
        if (get_skill(ch, contacts_table[i]) > 0 && (!str_cmp(arg2, skill_table[skillpoint_by_vnum(contacts_table[i])].name) || !str_cmp(arg2, ch->pcdata->contact_names[i]))) {
          string_append(ch, &ch->pcdata->contact_descs[i]);
          return;
        }
      }
      send_to_char("Syntax: Contact description (Occult/Government etc)\n\r", ch);
      return;
    }
    if (!str_cmp(arg1, "job")) {
      argument = one_argument_nouncap(argument, arg2);
      for (int i = 0; i < MAX_CONTACTS; i++) {
        if (get_skill(ch, contacts_table[i]) > 0 && (!str_cmp(arg2, skill_table[skillpoint_by_vnum(contacts_table[i])].name) || !str_cmp(arg2, ch->pcdata->contact_names[i]))) {
          if (safe_strlen(argument) < 2) {
            send_to_char("What job do you want them to have?\n\r", ch);
            return;
          }
          if (!str_cmp(argument, "Idle") || !str_cmp(argument, "recover") || !str_cmp(argument, "none") || !str_cmp(argument, "recovery")) {
            if (ch->pcdata->contact_jobs[i] == 0) {
              send_to_char("They are already doing that.\n\r", ch);
              return;
            }
            ch->pcdata->contact_jobs[i] = 0;
            ch->pcdata->contact_cooldowns[i] = current_time + (3600 * 24 * 4);
            send_to_char("Done.\n\r", ch);
            return;
          }
          else {
            if (ch->pcdata->contact_jobs[i] != 0) {
              send_to_char("They need to go through a recovery period before being assigned to a new job.\n\r", ch);
              return;
            }
            if (ch->pcdata->contact_cooldowns[i] > current_time) {
              send_to_char("They're not ready to be assigned a new job yet.\n\r", ch);
              return;
            }
            for (int j = 1; j < 9; j++) {
              if (safe_strlen(argument) > 1 && safe_strlen(contact_job_names[j]) > 1) {
                if (!str_cmp(argument, contact_job_names[j])) {
                  ch->pcdata->contact_jobs[i] = j;
                  printf_to_char(
                  ch, "Your %s Contact starts working on providing %s\n\r", skill_table[skillpoint_by_vnum(contacts_table[i])].name, contact_job_names[j]);
                  return;
                }
              }
            }
          }
        }
      }
      send_to_char("Syntax: Contact job (Occult/Governemnt etc) (recover", ch);
      for (int j = 1; j < 9; j++)
      printf_to_char(ch, " %s", contact_job_names[j]);
      send_to_char(")\n\r", ch);
      return;
    }
    send_to_char("Syntax: Contact Name/Description/Job\n\r", ch);
  }

  _DOFUN(do_frisk) {

    CHAR_DATA *victim;
    char arg1[MSL];

    argument = one_argument_nouncap(argument, arg1);

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (is_ghost(ch)) {
      send_to_char("Being alive might help.\n\r", ch);
      return;
    }

    if (ch->race != RACE_DEPUTY && !IS_IMMORTAL(ch)) {
      send_to_char("A badge might help.\n\r", ch);
      return;
    }

    if (!institute_room(ch->in_room)) {
      send_to_char("There's no point to confiscate contraband outside of the Institute.\n\r", ch);
      return;
    }

    if (has_institute_contraband(victim)) {
      remove_institute_contraband(victim);
    }
    else {
      act("A deputy frisks you, but finds nothing.", ch, NULL, NULL, TO_CHAR);
      act("A deputy frisks $n, but finds nothing.", ch, NULL, NULL, TO_ROOM);
    }
  }

  _DOFUN(do_detain) {
    CHAR_DATA *victim;
    char arg1[MSL];

    argument = one_argument_nouncap(argument, arg1);

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (is_ghost(ch)) {
      send_to_char("Being alive might help.\n\r", ch);
      return;
    }

    if (ch->race != RACE_DEPUTY && !IS_IMMORTAL(ch)) {
      send_to_char("A badge might help.\n\r", ch);
      return;
    }
    if (!in_haven(ch->in_room) || !cell_signal(ch)) {
      send_to_char("You can't get a signal to dispatch.\n\r", ch);
      return;
    }
    if (ch->in_room != NULL && ch->in_room->area->vnum >= 19) {
      send_to_char("You have no authority out here.\n\r", ch);
      return;
    }
    if (ch->pcdata->deputy_cooldown > current_time + (3600)) {
      send_to_char("You still haven't finished with all your previous paperwork.\n\r", ch);
      return;
    }
    if (victim->fcore != 0 && has_symbol_core(victim)) {
      send_to_char("Best to stay out of society business.\n\r", ch);
      return;
    }
    if (victim->fsect != 0 && has_symbol_sect(victim)) {
      send_to_char("Best to stay out of society business.\n\r", ch);
      return;
    }

    if (get_tier(victim) > 3) {
      send_to_char("You're a little out of your league with that one.\n\r", ch);
      return;
    }
    if (victim->race == RACE_DEPUTY) {
      send_to_char("Police corruption will have to be handled some other way.\n\r", ch);
      return;
    }

    act("You call for backup and have $N taken away to a holding cell.", ch, NULL, victim, TO_CHAR);
    act("$n radios in and has $N taken away to a holding cell.", ch, NULL, victim, TO_ROOM);
    auto_arrest(victim);
    ch->pcdata->deputy_cooldown = current_time + 3600;

    victim->pcdata->public_alarm = -120;
  }

  _DOFUN(do_disperse) {
    CHAR_DATA *victim;
    char arg1[MSL];

    argument = one_argument_nouncap(argument, arg1);

    if (is_ghost(ch)) {
      send_to_char("Being alive might help.\n\r", ch);
      return;
    }

    if (ch->pcdata->deputy_cooldown > current_time + (3600)) {
      send_to_char("You still haven't finished with all your previous paperwork.\n\r", ch);
      return;
    }


    if (!in_haven(ch->in_room) || !cell_signal(ch)) {
      send_to_char("You can't get a signal to dispatch.\n\r", ch);
      return;
    }
    if (ch->race != RACE_DEPUTY && !IS_IMMORTAL(ch)) {
      send_to_char("A badge might help.\n\r", ch);
      return;
    }
    if (ch->in_room != NULL && ch->in_room->area->vnum >= 19) {
      send_to_char("You have no authority out here.\n\r", ch);
      return;
    }
    if (!public_room(ch->in_room)) {
      send_to_char("You can't do that in private areas.\n\r", ch);
      return;
    }
    if (IS_SET(ch->in_room->room_flags, ROOM_INDOORS)) {
      send_to_char("You can only do that outside.\n\r", ch);
      return;
    }
    for (DescList::iterator it = descriptor_list.begin();
    it != descriptor_list.end(); ++it) {
      DESCRIPTOR_DATA *d = *it;

      if (d->connected != CON_PLAYING)
      continue;
      victim = CH(d);
      if (victim == NULL)
      continue;
      if (IS_NPC(victim))
      continue;
      if (victim->in_room == NULL)
      continue;
      if (is_gm(victim))
      continue;
      if (victim->in_room != ch->in_room)
      continue;
      if (victim->race == RACE_DEPUTY)
      continue;

      victim->pcdata->disperse_timer = 0;
      victim->pcdata->disperse_room = ch->in_room->vnum;
    }
    act("$n calls in the deputies to break up the crowd, warning people that anyone who continues to linger will be apprehended.", ch, NULL, NULL, TO_ROOM);
    act("You call in the deputies to break up the crowd, warning people that anyone who continues to linger will be apprehended.", ch, NULL, NULL, TO_CHAR);
    ch->pcdata->deputy_cooldown = current_time + (3600 * 2);
  }

  _DOFUN(do_movealong) {
    CHAR_DATA *victim;
    char arg1[MSL];

    argument = one_argument_nouncap(argument, arg1);

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (is_ghost(ch)) {
      send_to_char("Being alive might help.\n\r", ch);
      return;
    }

    if (ch->pcdata->deputy_cooldown > current_time + (3600)) {
      send_to_char("You still haven't finished with all your previous paperwork.\n\r", ch);
      return;
    }

    if (!in_haven(ch->in_room) || !cell_signal(ch)) {
      send_to_char("You can't get a signal to dispatch.\n\r", ch);
      return;
    }
    if (ch->race != RACE_DEPUTY && !IS_IMMORTAL(ch)) {
      send_to_char("A badge might help.\n\r", ch);
      return;
    }
    if (ch->in_room != NULL && ch->in_room->area->vnum >= 19) {
      send_to_char("You have no authority out here.\n\r", ch);
      return;
    }

    if (prop_from_room(ch->in_room) == NULL) {
      send_to_char("You're not in a private property.\n\r", ch);
      return;
    }
    PROP_TYPE *prop = prop_from_room(ch->in_room);
    if (!str_cmp(victim->name, prop->owner)) {
      send_to_char("You can't move them along from their own property.\n\r",ch);
      return;
    }
    for (int i = 0; i < 50; i++) {
      if (!str_cmp(victim->name, prop->tenants[i])) {
        send_to_char("They seem to have a key.\n\r", ch);
        return;
      }
    }
    if (victim->race == RACE_DEPUTY) {
      send_to_char("Police corruption will have to be handled some other way.\n\r", ch);
      return;
    }

    victim->pcdata->movealong_vnum = victim->in_room->vnum;
    victim->pcdata->movealong_timer = 0;
    act("You inform $N that they're tresspassing and ask them to move along.", ch, NULL, victim, TO_CHAR);
    act("$n says you're tresspassing and gives you a few minutes to move along before you'll be apprehended.", ch, NULL, victim, TO_VICT);
    act("$n informs $N they're tresspassing and asks them to move along.", ch, NULL, victim, TO_NOTVICT);
    ch->pcdata->deputy_cooldown = current_time + (3600 * 2);
  }

  _DOFUN(do_exsanguinate) {
    if (!is_vampire(ch)) {
      send_to_char("You'd need fangs first.\n\r", ch);
      return;
    }
    if (in_haven(ch->in_room)) {
      send_to_char("You'd have to venture somewhere without sancturary protection first.\n\r", ch);
      return;
    }
    if (public_room(ch->in_room)) {
      send_to_char("There's a few too many witnesses around.\n\r", ch);
      return;
    }
    if (event_aegis == 1) {
      send_to_char("Not now.\n\r", ch);
      return;
    }

    if (is_helpless(ch) || is_ghost(ch)) {
      send_to_char("Not now.\n\r", ch);
      return;
    }
    act("You find a victim and drag them somewhere private to completely drain them of blood.", ch, NULL, NULL, TO_CHAR);
    act("$n finds a victim to drain completely of blood.", ch, NULL, NULL, TO_ROOM);
    habit_corpse(ch, "Exsanguination");
    coverup_cost(ch, 2);
    ch->pcdata->lastaccident = current_time;
    ch->pcdata->last_drained_person = current_time;
  }

  _DOFUN(do_gag) {
    CHAR_DATA *victim;
    char arg1[MSL];

    if ((victim = get_char_world_pc(argument)) != NULL && victim->pcdata->ghost_room == ch->in_room->vnum && (IS_FLAG(victim->act, PLR_GHOSTWALKING) || victim->pcdata->spectre > 0)) {
      if (is_helpless(ch)) {
        send_to_char("You can't do that.\n\r", ch);
        return;
      }

      if (is_ghost(ch)) {
        send_to_char("You can't get a grip on them.\n\r", ch);
        return;
      }

      if (IS_FLAG(victim->comm, COMM_GAG)) {
        REMOVE_FLAG(victim->comm, COMM_GAG);
        act("You remove $N's gag.", ch, NULL, victim, TO_CHAR);
        act("$n removes $N's gag.", ch, NULL, victim, TO_NOTVICT);
        act("You feel something happen to your body.", ch, NULL, victim, TO_VICT);
      }
      else {
        act("You gag $N.", ch, NULL, victim, TO_CHAR);
        act("$n gags $N.", ch, NULL, victim, TO_NOTVICT);
        act("You feel something happen to your body.", ch, NULL, victim, TO_VICT);
        SET_FLAG(victim->comm, COMM_GAG);
      }
      return;
    }
    argument = one_argument_nouncap(argument, arg1);

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (is_ghost(victim)) {
      send_to_char("The dead see in ways no blindfold can hinder.\n\r", ch);
      return;
    }

    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (is_animal(ch))
    return;

    if (is_pinned(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (IS_NPC(victim)) {
      send_to_char("Not on NPCS.\n\r", ch);
      return;
    }

    if (!is_helpless(victim) && victim != ch) {
      send_to_char("Might help if you tie them up first.\n\r", ch);
      return;
    }

    // ghostie check and limit for blindfold -Discordance
    if (is_ghost(ch)) {
      if (is_manifesting(ch)) {
        if (deplete_ghostpool(ch, GHOST_MANIFESTATION) == FALSE) {
          send_to_char("You can't muster the strength to manifest your will any more today.\n\r", ch);
          return;
        }
      }
      else {
        send_to_char("You must be prepared to manifest your will.\n\r", ch);
        return;
      }
    }

    if (IS_FLAG(victim->comm, COMM_GAG)) {
      REMOVE_FLAG(victim->comm, COMM_GAG);
      act("You remove $N's gag.", ch, NULL, victim, TO_CHAR);
      act("$n removes $N's gag.", ch, NULL, victim, TO_NOTVICT);
      act("$n removes your gag.", ch, NULL, victim, TO_VICT);
    }
    else {
      act("You gag $N.", ch, NULL, victim, TO_CHAR);
      act("$n gags $N.", ch, NULL, victim, TO_NOTVICT);
      act("$n gags you.", ch, NULL, victim, TO_VICT);
      SET_FLAG(victim->comm, COMM_GAG);
    }
  }

  _DOFUN(do_helpless) {
    char arg1[MSL];
    argument = one_argument_nouncap(argument, arg1);
    if (in_fight(ch)) {
      send_to_char("That's a bit dangerous.\n\r", ch);
      return;
    }
    if (ch->pcdata->trance > 0) {
      send_to_char("You become helpless.\n\r", ch);
      return;
    }
    if (!str_cmp(arg1, "request")) {
      char arg2[MSL];
      argument = one_argument_nouncap(argument, arg2);
      CHAR_DATA *victim;

      if ((victim = get_char_room(ch, NULL, arg2)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      send_to_char("Request sent.\n\r", ch);
      if (safe_strlen(argument) > 2) {
        printf_to_char(victim, "%s wants you to become helpless so that %s.(type helpless to toggle this state)\n\r", PERS(ch, victim), argument);
      }
      else
      printf_to_char(victim, "%s wants you to become helpless.(Type helpless to toggle this state)\n\r", PERS(ch, victim));
      return;
    }
    if (IS_FLAG(ch->comm, COMM_HELPLESS)) {
      send_to_char("You stop being helpless.\n\r", ch);
      act("$n is no longer helpless.", ch, NULL, NULL, TO_ROOM);
      REMOVE_FLAG(ch->comm, COMM_HELPLESS);
    }
    else {
      send_to_char("You become helpless.\n\r", ch);
      act("$n is now helpless.", ch, NULL, NULL, TO_ROOM);
      SET_FLAG(ch->comm, COMM_HELPLESS);
    }
  }

  _DOFUN(do_exterminate) {
    CHAR_DATA *victim;

    if ((victim = get_char_room(ch, NULL, argument)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (is_ghost(ch)) {
      send_to_char("Slaying the living is no longer so simple./n/r", ch);
      return;
    }

    if (is_ghost(victim)) {
      send_to_char("Slaying a ghost is not so simple./n/r", ch);
      return;
    }

    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (!operating_room(ch->in_room)) {
      send_to_char("You need to be in a medical lab to do that.\n\r", ch);
      return;
    }
    if (get_skill(ch, SKILL_MEDICINE) < 1) {
      send_to_char("You'd need at least basic medical knowledge to attempt that.\n\r", ch);
      return;
    }
    if (victim->pcdata->egg_daddy == 0) {
      send_to_char("They don't seem to have anything that needs to be exterminated.\n\r", ch);
      return;
    }

    ch->pcdata->process = PROCESS_EXTERMINATE;
    ch->pcdata->process_timer = 60;
    ch->pcdata->process_target = victim;
    act("You start surgery on $N.", ch, NULL, victim, TO_CHAR);
    act("$n starts to perform surgery on you.", ch, NULL, victim, TO_VICT);
    act("$n starts to perform surgery on $N.", ch, NULL, victim, TO_NOTVICT);
  }

  void maim_char(CHAR_DATA *ch, char *message) {
    char buf[MSL];
    if (safe_strlen(ch->pcdata->maim) > 3) {
      sprintf(buf, "%s and %s", ch->pcdata->maim, message);
      free_string(ch->pcdata->maim);
      ch->pcdata->maim = str_dup(buf);
    }
    else {
      free_string(ch->pcdata->maim);
      ch->pcdata->maim = str_dup(message);
    }
  }

  char *trimwhitespace(char *str) {
    char *end;

    // Trim leading space
    while (isspace((unsigned char)*str))
    str++;

    if (*str == 0) // All spaces?
    return str;

    // Trim trailing space
    end = str + safe_strlen(str) - 1;
    while (end > str && isspace((unsigned char)*end))
    end--;

    // Write new null terminator character
    end[1] = '\0';

    return str;
  }

  void auto_imprint(CHAR_DATA *ch, char *message, int type) {
    if (is_gm(ch))
    return;
    char buf[MSL];
    remove_newlines(buf, message);
    for (int i = 0; i < 25; i++) {
      if (!str_cmp(trimwhitespace(buf), ch->pcdata->imprint[i])) {
        ch->pcdata->imprint_pending[i] =
        UMAX(ch->pcdata->imprint_pending[i], 100);
        return;
      }
    }
    for (int i = 0; i < 25; i++) {
      if (ch->pcdata->imprint_type[i] == 0) {
        ch->pcdata->imprint_type[i] = type;
        free_string(ch->pcdata->imprint[i]);
        ch->pcdata->imprint[i] = str_dup(trimwhitespace(buf));
        if (type == IMPRINT_INFLUENCE)
        ch->pcdata->imprint_pending[i] = 190;
        else if (type == IMPRINT_DRUGS)
        ch->pcdata->imprint_pending[i] = 100;
        else
        ch->pcdata->imprint_pending[i] = 0;
        do_function(ch, &do_imprint, "");
        return;
      }
    }
  }

  void auto_imprint_timed(CHAR_DATA *ch, char *message, int type, int time) {
    if (is_gm(ch))
    return;
    char buf[MSL];
    remove_newlines(buf, message);
    for (int i = 0; i < 25; i++) {
      if (!str_cmp(trimwhitespace(buf), ch->pcdata->imprint[i])) {
        ch->pcdata->imprint_pending[i] =
        UMAX(ch->pcdata->imprint_pending[i], 100);
        return;
      }
    }
    for (int i = 0; i < 25; i++) {
      if (ch->pcdata->imprint_type[i] == 0) {
        ch->pcdata->imprint_type[i] = type;
        free_string(ch->pcdata->imprint[i]);
        ch->pcdata->imprint[i] = str_dup(trimwhitespace(buf));
        if (type == IMPRINT_INFLUENCE)
        ch->pcdata->imprint_pending[i] = time;
        else if (type == IMPRINT_DRUGS)
        ch->pcdata->imprint_pending[i] = time;
        else
        ch->pcdata->imprint_pending[i] = time;
        do_function(ch, &do_imprint, "");
        return;
      }
    }
  }

  void show_imprints(CHAR_DATA *ch) {


    if (is_ill(ch))
    send_to_char("You have some sort of flu-like illness.\n\r", ch);
    if (is_deaf(ch))
    send_to_char("You cannot hear.\n\r", ch);

    if (IS_AFFECTED(ch, AFF_ARTHRITIS))
    send_to_char("Your joints ache, particularly when you try to move around quickly.\n\r", ch);
    if (IS_AFFECTED(ch, AFF_WEAKENED))
    send_to_char("Your muscles feel weaker than normal.\n\r", ch);

    if (event_cleanse == 1)
    return;

    if(strlen(ch->pcdata->fixation_name) > 2 && ch->pcdata->fixation_timeout > current_time)
    {
      printf_to_char(ch, "You are fixated with %s.\n\r", ch->pcdata->fixation_name);
    }

    if(ch->pcdata->boon == BOON_NOWORRIES && ch->pcdata->boon_timeout > current_time)
    {
      send_to_char("You are incapble of worry, anxiety or negative self-thought.\n\r", ch);
    }
    if(ch->pcdata->boon == BOON_BLISS && ch->pcdata->boon_timeout > current_time)
    {
      send_to_char("You feel happy, energized and optomistic about life.\n\r", ch);
    }
    if(ch->pcdata->curse == CURSE_GULLIBLITY && ch->pcdata->curse_timeout > current_time)
    {
      send_to_char("You believe any claim you are told unless you can see first hand evidence of it being false.\n\r", ch);
    }
    if(ch->pcdata->curse == CURSE_NARCISSISM && ch->pcdata->curse_timeout > current_time)
    {
      send_to_char("You are in love with yourself and incapable of believing there is anything you cannot do or will fail at.\n\r", ch);
    }
    if(ch->pcdata->curse == CURSE_REVELATION && ch->pcdata->curse_timeout > current_time)
    {
      send_to_char("You verbalize your internal thoughts without realizing it.\n\r", ch);
    }
    if(ch->pcdata->curse == CURSE_TIMID && ch->pcdata->curse_timeout > current_time)
    {
      send_to_char("You believe any physically possible threat made against you is genuine and don't believe you will be able to prevent it from being carried out.\n\r", ch);
    }
    if(ch->pcdata->curse == CURSE_PURITANICAL && ch->pcdata->curse_timeout > current_time)
    {
      send_to_char("Anything even slightly offputting is disgusting to you.\n\r", ch);
    }
    if(ch->pcdata->curse == CURSE_DEPENDENCY && ch->pcdata->curse_timeout > current_time)
    {
      send_to_char("Your self worth is entirely dependent on what others seem to think of you, you believe that any compliment given to you is sincere.\n\r", ch);
    }
    if(ch->pcdata->curse == CURSE_PHOBIA && ch->pcdata->curse_timeout > current_time)
    {
      printf_to_char(ch, "You have a phobia of %s.\n\r", ch->pcdata->curse_text);
    }
    if(ch->pcdata->curse == CURSE_IMPRINT && ch->pcdata->curse_timeout > current_time)
    {
      printf_to_char(ch, "You need to %s.\n\r", ch->pcdata->curse_text);
    }

    if (ch->pcdata->haunt_timer > 0)
    send_to_char("You feel watched.\n\r", ch);

    for (int i = 0; i < 25; i++) {
      for (int j = 0; j < 25; j++) {
        if (!str_cmp(ch->pcdata->imprint[i], ch->pcdata->imprint[j]) && i != j) {
          ch->pcdata->imprint_type[j] = 0;
        }
      }
      if (ch->pcdata->imprint_type[i] != 0 && ch->pcdata->imprint_pending[i] >= 0) {
        if (ch->pcdata->imprint_type[i] == IMPRINT_DRUGS)
        printf_to_char(ch, "You feel %s.\n\r", ch->pcdata->imprint[i]);
        if (ch->pcdata->imprint_type[i] == IMPRINT_INFLUENCE)
        printf_to_char(ch, "You want to %s.\n\r", ch->pcdata->imprint[i]);
        if (ch->pcdata->imprint_type[i] == IMPRINT_BODYINSTRUCTION)
        printf_to_char(ch, "Your body %s.\n\r", ch->pcdata->imprint[i]);
        if (ch->pcdata->imprint_type[i] == IMPRINT_BODYCOMPULSION)
        printf_to_char(ch, "Your body %s.\n\r", ch->pcdata->imprint[i]);
        if (ch->pcdata->imprint_type[i] == IMPRINT_INSTRUCTION)
        printf_to_char(ch, "You need to %s.\n\r", ch->pcdata->imprint[i]);
        if (ch->pcdata->imprint_type[i] == IMPRINT_PERSUADE)
        printf_to_char(ch, "You need to %s.\n\r", ch->pcdata->imprint[i]);
        if (ch->pcdata->imprint_type[i] == IMPRINT_COMPULSION)
        printf_to_char(ch, "You need to %s.\n\r", ch->pcdata->imprint[i]);
        if (ch->pcdata->imprint_type[i] == IMPRINT_LOCKEDCOMPULSION)
        printf_to_char(ch, "You need to %s.\n\r", ch->pcdata->imprint[i]);
        if (ch->pcdata->imprint_type[i] == IMPRINT_LOCKEDBODYCOMPULSION)
        printf_to_char(ch, "Your body %s.\n\r", ch->pcdata->imprint[i]);
        if (ch->pcdata->imprint_type[i] == IMPRINT_CURSED)
        printf_to_char(ch, "You need to %s.\n\r", ch->pcdata->imprint[i]);
        if (ch->pcdata->imprint_type[i] == IMPRINT_BCURSED)
        printf_to_char(ch, "Your body %s.\n\r", ch->pcdata->imprint[i]);

      }
    }
  }

  bool mindbroken(CHAR_DATA *ch) {
    if (IS_NPC(ch))
    return FALSE;
    if (ch->pcdata->destiny_feature == DEST_FEAT_IMPRINTABLE)
    return TRUE;
    if (ch->pcdata->mindbroken != 1)
    return FALSE;
    if (is_gm(ch))
    return FALSE;

    if (!brainwash_room(ch->in_room) && !sandbox_room(ch->in_room)) {
      ch->pcdata->mindbroken = 0;
      return FALSE;
    }
    return TRUE;
  }

  _DOFUN(do_hypnotise) {
    CHAR_DATA *victim;
    char arg1[MSL];
    char arg2[MSL];
    char arg3[MSL];
    char arg4[MSL];
    char arg5[MSL];
    char buf[MSL];

    int pone = 0, ptwo = 0, pthree = 0;

    argument = one_argument_nouncap(argument, arg1);
    argument = one_argument_nouncap(argument, arg2);

    if (is_gm(ch) && !IS_IMMORTAL(ch))
    return;

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }
    if (IS_NPC(victim)) {
      send_to_char("Not on NPCs.\n\r", ch);
      return;
    }
    if (get_skill(ch, SKILL_HYPNOTISM) <= 0 && !mindbroken(victim)) {
      send_to_char("You don't have that skill.\n\r", ch);
      return;
    }
    if (is_mute(ch) || IS_FLAG(ch->comm, COMM_GAG)) {
      send_to_char("You can't speak.\n\r", ch);
      return;
    }
    if (IS_FLAG(ch->act, PLR_SINSPIRIT)) {
      if (ch->pcdata->spirit_type == SPIRIT_JUSTICARUM && !justi_vuln(victim)) {
        send_to_char("They're not vulnerable to your sin.\n\r", ch);
        return;
      }
      if (ch->pcdata->spirit_type == SPIRIT_MALEFICARUM && !mali_vuln(victim)) {
        send_to_char("They're not vulnerable to your sin.\n\r", ch);
        return;
      }
    }

    if (is_deaf(victim)) {
      send_to_char("They can't hear you.\n\r", ch);
      return;
    }
    if (!str_cmp(arg2, "amnesia")) {
      if (get_skill(ch, SKILL_HYPNOTISM) < 2 && !mindbroken(victim)) {
        send_to_char("You don't have that skill.\n\r", ch);
        return;
      }

      if (safe_strlen(argument) < 2) {
        send_to_char("Syntax: Hypnotize (person) amnesia (thing to forget)\n\r", ch);
        return;
      }
      if (victim->pcdata->trance <= 0 && !mindbroken(victim)) {
        do_function(ch, &do_trance, arg1);
        if (victim->pcdata->trance <= 0 && !mindbroken(victim)) {
          send_to_char("They're not in a trance.\n\r", ch);
          return;
        }
      }

      printf_to_char(ch, "You make them recollect %s as if it happened in a dream instead of reality.\n\r", argument);
      printf_to_char(victim, "You forget %s, recollecting it as if it happened in a dream instead of reality.\n\r", argument);
      if (is_helpless(victim))
      victim->pcdata->trance = -5;
      else
      victim->pcdata->trance = -20;
      return;
    }
    if (!str_cmp(arg2, "lock")) {
      if (get_skill(ch, SKILL_HYPNOTISM) < 4 && !mindbroken(victim)) {
        send_to_char("You don't have that skill.\n\r", ch);
        return;
      }
      if (under_understanding(victim, ch)) {
        send_to_char("You can't seem to manage to do that.\n\r", ch);
        return;
      }

      argument = one_argument_nouncap(argument, arg3);
      argument = one_argument_nouncap(argument, arg4);
      argument = one_argument_nouncap(argument, arg5);
      for (int i = 1; i <= HYPNO_PITY; i++) {
        if (!str_cmp(arg3, hypno_names[i]))
        pone = i;
        if (!str_cmp(arg4, hypno_names[i]))
        ptwo = i;
        if (!str_cmp(arg5, hypno_names[i]))
        pthree = i;
      }
      if (pone < 1 || ptwo < 1 || pthree < 1 || safe_strlen(argument) < 2) {
        send_to_char("Syntax: Hypnotize (person) (lock) (pressure one) (pressure two) (pressure three) (instruction to lock)\n\r", ch);
        return;
      }
      victim->pcdata->trance = -5;
      for (int i = 0; i < 25; i++) {
        if (!str_cmp(victim->pcdata->imprint[i], argument)) {
          if (victim->pcdata->imprint_type[i] == IMPRINT_COMPULSION) {
            victim->pcdata->imprint_type[i] = IMPRINT_LOCKEDCOMPULSION;
            send_to_char("You seal the compulsion into their mind.\n\r", ch);
            return;
          }
          if (victim->pcdata->imprint_type[i] == IMPRINT_BODYCOMPULSION) {
            victim->pcdata->imprint_type[i] = IMPRINT_LOCKEDBODYCOMPULSION;
            send_to_char("You seal the compulsion into their mind.\n\r", ch);
            return;
          }
        }
      }
      send_to_char("They don't seem to have any such compulsion to seal in place.\n\r", ch);
      return;
    }
    if (!str_cmp(arg2, "unlock")) {
      if (get_skill(ch, SKILL_HYPNOTISM) < 4 && !mindbroken(victim)) {
        send_to_char("You don't have that skill.\n\r", ch);
        return;
      }

      argument = one_argument_nouncap(argument, arg3);
      argument = one_argument_nouncap(argument, arg4);
      argument = one_argument_nouncap(argument, arg5);
      for (int i = 1; i <= HYPNO_PITY; i++) {
        if (!str_cmp(arg3, hypno_names[i]))
        pone = i;
        if (!str_cmp(arg4, hypno_names[i]))
        ptwo = i;
        if (!str_cmp(arg5, hypno_names[i]))
        pthree = i;
      }
      if (pone < 1 || ptwo < 1 || pthree < 1) {
        send_to_char("Syntax: Hypnotize (person) unlock (pressure one) (pressure two) (pressure three)\n\r", ch);
        return;
      }
      victim->pcdata->trance = -15;
      for (int i = 0; i < 25; i++) {
        if (pone == victim->pcdata->imprint_pressure_one[i] && ptwo == victim->pcdata->imprint_pressure_two[i] && pthree == victim->pcdata->imprint_pressure_three[i]) {
          if (victim->pcdata->imprint_type[i] == IMPRINT_LOCKEDCOMPULSION) {
            send_to_char("You break the compulsion.\n\r", ch);
            printf_to_char(victim, "You no longer need to %s.\n\r", victim->pcdata->imprint[i]);
            victim->pcdata->imprint_type[i] = 0;
            return;
          }
          if (victim->pcdata->imprint_type[i] == IMPRINT_LOCKEDBODYCOMPULSION) {
            send_to_char("You break the compulsion.\n\r", ch);
            printf_to_char(victim, "Your body no longer %s.\n\r", victim->pcdata->imprint[i]);
            victim->pcdata->imprint_type[i] = 0;
            return;
          }
        }
      }
      send_to_char("Pain flares through your head as you fail to unlock any compulsions.\n\r", ch);
      use_lifeforce(ch, 500, "Failed unlock.");
    }
    if (!str_cmp(ch->pcdata->last_sexed[0], victim->name) || !str_cmp(ch->pcdata->last_sexed[1], victim->name) || !str_cmp(ch->pcdata->last_sexed[2], victim->name)) {
    }
    else {
      villain_mod(ch, 5, "Hypnotism");
    }
    if (!str_cmp(arg2, "instruction")) {
      if (get_skill(ch, SKILL_HYPNOTISM) < 2 && !mindbroken(victim)) {
        send_to_char("You don't have that skill.\n\r", ch);
        return;
      }
      argument = one_argument_nouncap(argument, arg3);
      argument = one_argument_nouncap(argument, arg4);
      argument = one_argument_nouncap(argument, arg5);
      for (int i = 1; i <= HYPNO_PITY; i++) {
        if (!str_cmp(arg3, hypno_names[i]))
        pone = i;
        if (!str_cmp(arg4, hypno_names[i]))
        ptwo = i;
        if (!str_cmp(arg5, hypno_names[i]))
        pthree = i;
      }
      if (pone < 1 || ptwo < 1 || pthree < 1 || safe_strlen(argument) < 2) {
        send_to_char("Syntax: Hypnotize (person) instruction (pressure one) (pressure two) (pressure three) (instruction)\n\rPossible Pressures", ch);
        for (int i = 1; i <= HYPNO_PITY; i++)
        printf_to_char(ch, ", %s", hypno_names[i]);
        send_to_char(".\n\r", ch);
        return;
      }
      if (victim->pcdata->trance <= 0 && !mindbroken(victim)) {
        do_function(ch, &do_trance, arg1);
        if (victim->pcdata->trance <= 0 && !mindbroken(victim)) {
          send_to_char("They're not in a trance.\n\r", ch);
          return;
        }
      }

      for (int i = 0; i < 25; i++) {
        if (victim->pcdata->imprint_type[i] == 0) {
          victim->pcdata->imprint_type[i] = IMPRINT_INSTRUCTION;
          free_string(victim->pcdata->imprint[i]);
          victim->pcdata->imprint[i] = str_dup(argument);
          victim->pcdata->imprint_pending[i] = -5;
          victim->pcdata->imprint_pressure_one[i] = pone;
          victim->pcdata->imprint_pressure_two[i] = ptwo;
          victim->pcdata->imprint_pressure_three[i] = pthree;
          victim->pcdata->imprinter = ch;
          if (is_helpless(victim))
          victim->pcdata->trance = -5;
          else
          victim->pcdata->trance = -60;

          printf_to_char(ch, "You attempt to instruct %s to %s with a combination of %s, %s, and %s.\n\r", PERS(victim, ch), argument, hypno_names[pone], hypno_names[ptwo], hypno_names[pthree]);
          sprintf(buf, "$n tells $N to '%s'", argument);
          act(buf, ch, NULL, victim, TO_NOTVICT);
          printf_to_char(
          victim, "Your subconcious has received an instruction to %s.\nTo accept this instruction use imprint accept, to try to resist use imprint resist (pressure one) (pressure two) (pressure three) where each pressure is a type of manipulation most likely to make your character succumb to the instruction and are given in order of strength. Possible pressures are", argument);
          for (int i = 1; i <= HYPNO_PITY; i++)
          printf_to_char(victim, ", %s", hypno_names[i]);
          send_to_char(".\n\r", victim);
          return;
        }
      }
    }
    if (!str_cmp(arg2, "compulsion")) {
      if (get_skill(ch, SKILL_HYPNOTISM) < 3 && !mindbroken(victim)) {
        send_to_char("You don't have that skill.\n\r", ch);
        return;
      }
      argument = one_argument_nouncap(argument, arg3);
      argument = one_argument_nouncap(argument, arg4);
      argument = one_argument_nouncap(argument, arg5);
      for (int i = 1; i <= HYPNO_PITY; i++) {
        if (!str_cmp(arg3, hypno_names[i]))
        pone = i;
        if (!str_cmp(arg4, hypno_names[i]))
        ptwo = i;
        if (!str_cmp(arg5, hypno_names[i]))
        pthree = i;
      }
      if (pone < 1 || ptwo < 1 || pthree < 1 || safe_strlen(argument) < 2) {
        send_to_char("Syntax: Hypnotize (person) compulsion (pressure one) (pressure two) (pressure three) (instruction)\n\rPossible Pressures", ch);
        for (int i = 1; i <= HYPNO_PITY; i++)
        printf_to_char(ch, ", %s", hypno_names[i]);
        send_to_char(".\n\r", ch);
        return;
      }
      if (victim->pcdata->trance <= 0 && !mindbroken(victim)) {
        do_function(ch, &do_trance, arg1);
        if (victim->pcdata->trance <= 0 && !mindbroken(victim)) {
          send_to_char("They're not in a trance.\n\r", ch);
          return;
        }
      }

      for (int i = 0; i < 25; i++) {
        if (victim->pcdata->imprint_type[i] == 0) {
          victim->pcdata->imprint_type[i] = IMPRINT_COMPULSION;
          free_string(victim->pcdata->imprint[i]);
          victim->pcdata->imprint[i] = str_dup(argument);
          victim->pcdata->imprint_pending[i] = -5;
          victim->pcdata->imprint_pressure_one[i] = pone;
          victim->pcdata->imprint_pressure_two[i] = ptwo;
          victim->pcdata->imprint_pressure_three[i] = pthree;
          victim->pcdata->imprinter = ch;
          if (is_helpless(victim))
          victim->pcdata->trance = -5;
          else
          victim->pcdata->trance = -60;

          printf_to_char(ch, "You attempt to compel %s to %s with a combination of %s, %s, and %s.\n\r", PERS(victim, ch), argument, hypno_names[pone], hypno_names[ptwo], hypno_names[pthree]);
          sprintf(buf, "$n tells $N to '%s'", argument);
          act(buf, ch, NULL, victim, TO_NOTVICT);
          printf_to_char(
          victim, "Your subconcious has received a compulsion to %s.\nTo accept this instruction  use imprint accept, to try to resist use imprint resist (pressure one) (pressure two) (pressure three) where each pressure is a type of manipulation most likely to make your character succumb to the instruction and are given in order of strength. Possible pressures are", argument);
          for (int i = 1; i <= HYPNO_PITY; i++)
          printf_to_char(victim, ", %s", hypno_names[i]);
          send_to_char(".\n\r", victim);
          return;
        }
      }
    }
    if (!str_cmp(arg2, "body")) {
      char arg6[MSL];
      argument = one_argument_nouncap(argument, arg6);
      if (!str_cmp(arg6, "instruction")) {
        if (get_skill(ch, SKILL_HYPNOTISM) < 3 && !mindbroken(victim)) {
          send_to_char("You don't have that skill.\n\r", ch);
          return;
        }
        argument = one_argument_nouncap(argument, arg3);
        argument = one_argument_nouncap(argument, arg4);
        argument = one_argument_nouncap(argument, arg5);
        for (int i = 1; i <= HYPNO_PITY; i++) {
          if (!str_cmp(arg3, hypno_names[i]))
          pone = i;
          if (!str_cmp(arg4, hypno_names[i]))
          ptwo = i;
          if (!str_cmp(arg5, hypno_names[i]))
          pthree = i;
        }
        if (pone < 1 || ptwo < 1 || pthree < 1 || safe_strlen(argument) < 2) {
          send_to_char("Syntax: Hypnotize (person) body instruction (pressure one) (pressure two) (pressure three) (instruction)\n\rPossible Pressures", ch);
          for (int i = 1; i <= HYPNO_PITY; i++)
          printf_to_char(ch, ", %s", hypno_names[i]);
          send_to_char(".\n\r", ch);
          return;
        }
        if (victim->pcdata->trance <= 0 && !mindbroken(victim)) {
          do_function(ch, &do_trance, arg1);
          if (victim->pcdata->trance <= 0 && !mindbroken(victim)) {
            send_to_char("They're not in a trance.\n\r", ch);
            return;
          }
        }

        for (int i = 0; i < 25; i++) {
          if (victim->pcdata->imprint_type[i] == 0) {
            victim->pcdata->imprint_type[i] = IMPRINT_BODYINSTRUCTION;
            free_string(victim->pcdata->imprint[i]);
            victim->pcdata->imprint[i] = str_dup(argument);
            victim->pcdata->imprint_pending[i] = -5;
            victim->pcdata->imprint_pressure_one[i] = pone;
            victim->pcdata->imprint_pressure_two[i] = ptwo;
            victim->pcdata->imprint_pressure_three[i] = pthree;
            victim->pcdata->imprinter = ch;
            victim->pcdata->trance = -60;
            printf_to_char(
            ch, "You attempt to instruct %s's motor cortex to make it so their body %s with a combination of %s, %s, and %s.\n\r", PERS(victim, ch), argument, hypno_names[pone], hypno_names[ptwo], hypno_names[pthree]);
            sprintf(buf, "$n tells $N to '%s'", argument);
            act(buf, ch, NULL, victim, TO_NOTVICT);
            printf_to_char(
            victim, "Your motor cortext has recieved and instruction to make it so your body %s.\nTo accept this instruction  use imprint accept, to try to resist use imprint resist (pressure one) (pressure two) (pressure three) where each pressure is a type of manipulation most likely to make your character succumb to the instruction and are given in order of strength. Possible pressures are", argument);
            for (int i = 1; i <= HYPNO_PITY; i++)
            printf_to_char(victim, ", %s", hypno_names[i]);
            send_to_char(".\n\r", victim);
            return;
          }
        }
      }
      if (!str_cmp(arg6, "compulsion")) {
        if (get_skill(ch, SKILL_HYPNOTISM) < 3 && !mindbroken(victim)) {
          send_to_char("You don't have that skill.\n\r", ch);
          return;
        }
        argument = one_argument_nouncap(argument, arg3);
        argument = one_argument_nouncap(argument, arg4);
        argument = one_argument_nouncap(argument, arg5);
        for (int i = 1; i <= HYPNO_PITY; i++) {
          if (!str_cmp(arg3, hypno_names[i]))
          pone = i;
          if (!str_cmp(arg4, hypno_names[i]))
          ptwo = i;
          if (!str_cmp(arg5, hypno_names[i]))
          pthree = i;
        }
        if (pone < 1 || ptwo < 1 || pthree < 1 || safe_strlen(argument) < 2) {
          send_to_char("Syntax: Hypnotize (person) body compulsion (pressure one) (pressure two) (pressure three) (instruction)\n\rPossible Pressures", ch);
          for (int i = 1; i <= HYPNO_PITY; i++)
          printf_to_char(ch, ", %s", hypno_names[i]);
          send_to_char(".\n\r", ch);
          return;
        }
        if (victim->pcdata->trance <= 0 && !mindbroken(victim)) {
          do_function(ch, &do_trance, arg1);
          if (victim->pcdata->trance <= 0 && !mindbroken(victim)) {
            send_to_char("They're not in a trance.\n\r", ch);
            return;
          }
        }

        for (int i = 0; i < 25; i++) {
          if (victim->pcdata->imprint_type[i] == 0) {
            victim->pcdata->imprint_type[i] = IMPRINT_BODYCOMPULSION;
            free_string(victim->pcdata->imprint[i]);
            victim->pcdata->imprint[i] = str_dup(argument);
            victim->pcdata->imprint_pending[i] = -5;
            victim->pcdata->imprint_pressure_one[i] = pone;
            victim->pcdata->imprint_pressure_two[i] = ptwo;
            victim->pcdata->imprint_pressure_three[i] = pthree;
            victim->pcdata->imprinter = ch;
            victim->pcdata->trance = -60;
            printf_to_char(
            ch, "You attempt to compel %s's motor cortex to make their body %s with a combination of %s, %s, and %s.\n\r", PERS(victim, ch), argument, hypno_names[pone], hypno_names[ptwo], hypno_names[pthree]);
            sprintf(buf, "$n tells $N to '%s'", argument);
            act(buf, ch, NULL, victim, TO_NOTVICT);
            printf_to_char(
            victim, "Your motor cortex has recieved a compulsion to make it so your body %s.\nTo accept this instruction  use imprint accept, to try to resist use imprint resist (pressure one) (pressure two) (pressure three) where each pressure is a type of manipulation most likely to make your character succumb to the instruction and are given in order of strength. Possible pressures are", argument);
            for (int i = 1; i <= HYPNO_PITY; i++)
            printf_to_char(victim, ", %s", hypno_names[i]);
            send_to_char(".\n\r", victim);
            return;
          }
        }
      }
    }
    if (!str_cmp(arg2, "triggered")) {
      char arg6[MSL];
      argument = one_argument_nouncap(argument, arg6);
      if (!str_cmp(arg6, "instruction")) {

        if (get_skill(ch, SKILL_HYPNOTISM) < 3 && !mindbroken(victim)) {
          send_to_char("You don't have that skill.\n\r", ch);
          return;
        }
        argument = one_argument_nouncap(argument, arg3);
        argument = one_argument_nouncap(argument, arg4);
        argument = one_argument_nouncap(argument, arg5);
        for (int i = 1; i <= HYPNO_PITY; i++) {
          if (!str_cmp(arg3, hypno_names[i]))
          pone = i;
          if (!str_cmp(arg4, hypno_names[i]))
          ptwo = i;
          if (!str_cmp(arg5, hypno_names[i]))
          pthree = i;
        }
        if (pone < 1 || ptwo < 1 || pthree < 1 || safe_strlen(argument) < 2) {
          send_to_char("Syntax: Hypnotize [person] triggered instruction [pressure one] [pressure two] [pressure three] ([trigger]) [instruction]\n\rPossible Pressures", ch);
          for (int i = 1; i <= HYPNO_PITY; i++)
          printf_to_char(ch, ", %s", hypno_names[i]);
          send_to_char(".\n\r", ch);
          return;
        }
        bool eataletter = FALSE;
        char tmp[MSL], blah[MSL], rectalk[MSL], talktalk[MSL];
        sprintf(tmp, "%s", argument);
        rectalk[0] = 0;
        talktalk[0] = 0;
        bool rectotalk = FALSE;
        for (int i = 0; tmp[i] != '\0' && i < (int)(safe_strlen(tmp)); i++) {
          if (tmp[i] == '(') {
            eataletter = TRUE;
            rectotalk = TRUE;
          }
          else if (tmp[i] == ')') {
            rectotalk = FALSE;
          }
          else {
            if (rectotalk == TRUE) {
              sprintf(blah, "%c", tmp[i]);
              strcat(rectalk, blah);
            }
            else {
              if (eataletter == TRUE && tmp[i] == ' ') {
                eataletter = FALSE;
              }
              else {
                sprintf(blah, "%c", tmp[i]);
                strcat(talktalk, blah);
              }
            }
          }
        }
        argument = str_dup(talktalk);
        if (safe_strlen(argument) < 2 || safe_strlen(rectalk) < 2) {
          send_to_char("Syntax: Hypnotize [person] triggered instruction [pressure one] [pressure two] [pressure three] ([trigger]) [instruction]\n\rPossible Pressures", ch);
          for (int i = 1; i <= HYPNO_PITY; i++)
          printf_to_char(ch, ", %s", hypno_names[i]);
          send_to_char(".\n\r", ch);
          return;
        }
        if (victim->pcdata->trance <= 0 && !mindbroken(victim)) {
          do_function(ch, &do_trance, arg1);
          if (victim->pcdata->trance <= 0 && !mindbroken(victim)) {
            send_to_char("They're not in a trance.\n\r", ch);
            return;
          }
        }

        for (int i = 0; i < 25; i++) {
          if (victim->pcdata->imprint_type[i] == 0) {
            victim->pcdata->imprint_type[i] = IMPRINT_TRIGGEREDINSTRUCTION;
            free_string(victim->pcdata->imprint[i]);
            victim->pcdata->imprint[i] = str_dup(argument);
            free_string(victim->pcdata->imprint_trigger[i]);
            victim->pcdata->imprint_trigger[i] = str_dup(rectalk);
            victim->pcdata->imprint_pending[i] = -5;
            victim->pcdata->imprint_pressure_one[i] = pone;
            victim->pcdata->imprint_pressure_two[i] = ptwo;
            victim->pcdata->imprint_pressure_three[i] = pthree;
            victim->pcdata->imprinter = ch;
            victim->pcdata->trance = -60;
            printf_to_char(ch, "You attempt to instruct %s to %s when they see or hear '%s' with a combination of %s, %s, and %s.\n\r", PERS(victim, ch), argument, rectalk, hypno_names[pone], hypno_names[ptwo], hypno_names[pthree]);
            sprintf(buf, "$n tells $N to '%s'", argument);
            act(buf, ch, NULL, victim, TO_NOTVICT);
            printf_to_char(
            victim, "Your subconcious has received a compulsion to %s.\nTo accept this instruction  use imprint accept, to try to resist use imprint resist (pressure one) (pressure two) (pressure three) where each pressure is a type of manipulation most likely to make your character succumb to the instruction and are given in order of strength. Possible pressures are", argument);
            for (int i = 1; i <= HYPNO_PITY; i++)
            printf_to_char(victim, ", %s", hypno_names[i]);
            send_to_char(".\n\r", victim);
            return;
          }
        }
      }
      if (!str_cmp(arg6, "compulsion")) {
        if (get_skill(ch, SKILL_HYPNOTISM) < 4 && !mindbroken(victim)) {
          send_to_char("You don't have that skill.\n\r", ch);
          return;
        }
        argument = one_argument_nouncap(argument, arg3);
        argument = one_argument_nouncap(argument, arg4);
        argument = one_argument_nouncap(argument, arg5);
        for (int i = 1; i <= HYPNO_PITY; i++) {
          if (!str_cmp(arg3, hypno_names[i]))
          pone = i;
          if (!str_cmp(arg4, hypno_names[i]))
          ptwo = i;
          if (!str_cmp(arg5, hypno_names[i]))
          pthree = i;
        }
        if (pone < 1 || ptwo < 1 || pthree < 1 || safe_strlen(argument) < 2) {
          send_to_char("Syntax: Hypnotize [person] triggered compulsion [pressure one] [pressure two] [pressure three] ([trigger]) [instruction]\n\rPossible Pressures", ch);
          for (int i = 1; i <= HYPNO_PITY; i++)
          printf_to_char(ch, ", %s", hypno_names[i]);
          send_to_char(".\n\r", ch);
        }
        bool eataletter = FALSE;
        char tmp[MSL], blah[MSL], rectalk[MSL], talktalk[MSL];
        sprintf(tmp, "%s", argument);
        rectalk[0] = 0;
        talktalk[0] = 0;
        bool rectotalk = FALSE;
        for (int i = 0; tmp[i] != '\0' && i < (int)(safe_strlen(tmp)); i++) {
          if (tmp[i] == '(') {
            eataletter = TRUE;
            rectotalk = TRUE;
          }
          else if (tmp[i] == ')') {
            rectotalk = FALSE;
          }
          else {
            if (rectotalk == TRUE) {
              sprintf(blah, "%c", tmp[i]);
              strcat(rectalk, blah);
            }
            else {
              if (eataletter == TRUE && tmp[i] == ' ') {
                eataletter = FALSE;
              }
              else {
                sprintf(blah, "%c", tmp[i]);
                strcat(talktalk, blah);
              }
            }
          }
        }
        argument = str_dup(talktalk);
        if (safe_strlen(argument) < 2 || safe_strlen(rectalk) < 2) {
          send_to_char("Syntax: Hypnotize [person] triggered compulsion [pressure one] [pressure two] [pressure three] ([trigger]) [instruction]\n\rPossible Pressures", ch);
          for (int i = 1; i <= HYPNO_PITY; i++)
          printf_to_char(ch, ", %s", hypno_names[i]);
          send_to_char(".\n\r", ch);
        }
        if (victim->pcdata->trance <= 0 && !mindbroken(victim)) {
          do_function(ch, &do_trance, arg1);
          if (victim->pcdata->trance <= 0 && !mindbroken(victim)) {
            send_to_char("They're not in a trance.\n\r", ch);
            return;
          }
        }

        for (int i = 0; i < 25; i++) {
          if (victim->pcdata->imprint_type[i] == 0) {
            victim->pcdata->imprint_type[i] = IMPRINT_TRIGGEREDCOMPULSION;
            free_string(victim->pcdata->imprint[i]);
            victim->pcdata->imprint[i] = str_dup(argument);
            free_string(victim->pcdata->imprint_trigger[i]);
            victim->pcdata->imprint_trigger[i] = str_dup(rectalk);
            victim->pcdata->imprint_pending[i] = -5;
            victim->pcdata->imprint_pressure_one[i] = pone;
            victim->pcdata->imprint_pressure_two[i] = ptwo;
            victim->pcdata->imprint_pressure_three[i] = pthree;
            victim->pcdata->imprinter = ch;
            victim->pcdata->trance = -60;
            printf_to_char(ch, "You attempt to instruct %s to %s when they see or hear '%s' with a combination of %s, %s, and %s.\n\r", PERS(victim, ch), argument, rectalk, hypno_names[pone], hypno_names[ptwo], hypno_names[pthree]);
            sprintf(buf, "$n tells $N to '%s'", argument);
            act(buf, ch, NULL, victim, TO_NOTVICT);
            printf_to_char(
            victim, "Your subconcious has received a compulsion to %s.\nTo accept this instruction use imprint accept, to try to resist use imprint resist (pressure one) (pressure two) (pressure three) where each pressure is a type of manipulation most likely to make your character succumb to the instruction and are given in order of strength. Possible pressures are", argument);
            for (int i = 1; i <= HYPNO_PITY; i++)
            printf_to_char(victim, ", %s", hypno_names[i]);
            send_to_char(".\n\r", victim);
            return;
          }
        }
      }
      if (!str_cmp(arg6, "body")) {
        char arg7[MSL];
        argument = one_argument_nouncap(argument, arg7);
        if (!str_cmp(arg7, "instruction")) {

          if (get_skill(ch, SKILL_HYPNOTISM) < 3 && !mindbroken(victim)) {
            send_to_char("You don't have that skill.\n\r", ch);
            return;
          }
          argument = one_argument_nouncap(argument, arg3);
          argument = one_argument_nouncap(argument, arg4);
          argument = one_argument_nouncap(argument, arg5);
          for (int i = 1; i <= HYPNO_PITY; i++) {
            if (!str_cmp(arg3, hypno_names[i]))
            pone = i;
            if (!str_cmp(arg4, hypno_names[i]))
            ptwo = i;
            if (!str_cmp(arg5, hypno_names[i]))
            pthree = i;
          }
          if (pone < 1 || ptwo < 1 || pthree < 1 || safe_strlen(argument) < 2) {
            send_to_char("Syntax: Hypnotize [person] triggered body instruction [pressure one] [pressure two] [pressure three] ([trigger]) [instruction]\n\rPossible Pressures", ch);
            for (int i = 1; i <= HYPNO_PITY; i++)
            printf_to_char(ch, ", %s", hypno_names[i]);
            send_to_char(".\n\r", ch);
            return;
          }
          bool eataletter = FALSE;
          char tmp[MSL], blah[MSL], rectalk[MSL], talktalk[MSL];
          sprintf(tmp, "%s", argument);
          rectalk[0] = 0;
          talktalk[0] = 0;
          bool rectotalk = FALSE;
          for (int i = 0; tmp[i] != '\0' && i < (int)(safe_strlen(tmp)); i++) {
            if (tmp[i] == '(') {
              eataletter = TRUE;
              rectotalk = TRUE;
            }
            else if (tmp[i] == ')') {
              rectotalk = FALSE;
            }
            else {
              if (rectotalk == TRUE) {
                sprintf(blah, "%c", tmp[i]);
                strcat(rectalk, blah);
              }
              else {
                if (eataletter == TRUE && tmp[i] == ' ') {
                  eataletter = FALSE;
                }
                else {
                  sprintf(blah, "%c", tmp[i]);
                  strcat(talktalk, blah);
                }
              }
            }
          }
          argument = str_dup(talktalk);
          if (safe_strlen(argument) < 2 || safe_strlen(rectalk) < 2) {
            send_to_char("Syntax: Hypnotize [person] triggered body instruction [pressure one] [pressure two] [pressure three] ([trigger]) [instruction]\n\rPossible Pressures", ch);
            for (int i = 1; i <= HYPNO_PITY; i++)
            printf_to_char(ch, ", %s", hypno_names[i]);
            send_to_char(".\n\r", ch);
            return;
          }
          if (victim->pcdata->trance <= 0 && !mindbroken(victim)) {
            do_function(ch, &do_trance, arg1);
            if (victim->pcdata->trance <= 0 && !mindbroken(victim)) {
              send_to_char("They're not in a trance.\n\r", ch);
              return;
            }
          }

          for (int i = 0; i < 25; i++) {
            if (victim->pcdata->imprint_type[i] == 0) {
              victim->pcdata->imprint_type[i] = IMPRINT_TRIGGEREDBODYINSTRUCTION;
              free_string(victim->pcdata->imprint[i]);
              victim->pcdata->imprint[i] = str_dup(argument);
              free_string(victim->pcdata->imprint_trigger[i]);
              victim->pcdata->imprint_trigger[i] = str_dup(rectalk);
              victim->pcdata->imprint_pending[i] = -5;
              victim->pcdata->imprint_pressure_one[i] = pone;
              victim->pcdata->imprint_pressure_two[i] = ptwo;
              victim->pcdata->imprint_pressure_three[i] = pthree;
              victim->pcdata->imprinter = ch;
              victim->pcdata->trance = -60;
              printf_to_char(ch, "You attempt to instruct %s's motor cortext so that their body %s when they see or hear '%s' with a combination of %s, %s, and %s.\n\r", PERS(victim, ch), argument, rectalk, hypno_names[pone], hypno_names[ptwo], hypno_names[pthree]);
              sprintf(buf, "$n tells $N to '%s'", argument);
              act(buf, ch, NULL, victim, TO_NOTVICT);
              printf_to_char(
              victim, "Your motor cortext has recieved and instruction, attempting to make it so you body %s.\nTo accept this instruction  use imprint accept, to try to resist use imprint resist (pressure one) (pressure two) (pressure three) where each pressure is a type of manipulation most likely to make your character succumb to the instruction and are given in order of strength. Possible pressures are", argument);
              for (int i = 1; i <= HYPNO_PITY; i++)
              printf_to_char(victim, ", %s", hypno_names[i]);
              send_to_char(".\n\r", victim);
              return;
            }
          }
        }
        if (!str_cmp(arg7, "compulsion")) {

          if (get_skill(ch, SKILL_HYPNOTISM) < 4 && !mindbroken(victim)) {
            send_to_char("You don't have that skill.\n\r", ch);
            return;
          }
          argument = one_argument_nouncap(argument, arg3);
          argument = one_argument_nouncap(argument, arg4);
          argument = one_argument_nouncap(argument, arg5);
          for (int i = 1; i <= HYPNO_PITY; i++) {
            if (!str_cmp(arg3, hypno_names[i]))
            pone = i;
            if (!str_cmp(arg4, hypno_names[i]))
            ptwo = i;
            if (!str_cmp(arg5, hypno_names[i]))
            pthree = i;
          }
          if (pone < 1 || ptwo < 1 || pthree < 1 || safe_strlen(argument) < 2) {
            send_to_char("Syntax: Hypnotize [person] triggered body compulsion [pressure one] [pressure two] [pressure three] ([trigger]) [instruction]\n\rPossible Pressures", ch);
            for (int i = 1; i <= HYPNO_PITY; i++)
            printf_to_char(ch, ", %s", hypno_names[i]);
            send_to_char(".\n\r", ch);
            return;
          }
          bool eataletter = FALSE;
          char tmp[MSL], blah[MSL], rectalk[MSL], talktalk[MSL];
          sprintf(tmp, "%s", argument);
          rectalk[0] = 0;
          talktalk[0] = 0;
          bool rectotalk = FALSE;
          for (int i = 0; tmp[i] != '\0' && i < (int)(safe_strlen(tmp)); i++) {
            if (tmp[i] == '(') {
              eataletter = TRUE;
              rectotalk = TRUE;
            }
            else if (tmp[i] == ')') {
              rectotalk = FALSE;
            }
            else {
              if (rectotalk == TRUE) {
                sprintf(blah, "%c", tmp[i]);
                strcat(rectalk, blah);
              }
              else {
                if (eataletter == TRUE && tmp[i] == ' ') {
                  eataletter = FALSE;
                }
                else {
                  sprintf(blah, "%c", tmp[i]);
                  strcat(talktalk, blah);
                }
              }
            }
          }
          argument = str_dup(talktalk);
          if (safe_strlen(argument) < 2 || safe_strlen(rectalk) < 2) {
            send_to_char("Syntax: Hypnotize [person] triggered body compulsion [pressure one] [pressure two] [pressure three] ([trigger]) [instruction]\n\rPossible Pressures", ch);
            for (int i = 1; i <= HYPNO_PITY; i++)
            printf_to_char(ch, ", %s", hypno_names[i]);
            send_to_char(".\n\r", ch);
          }
          if (victim->pcdata->trance <= 0 && !mindbroken(victim)) {
            do_function(ch, &do_trance, arg1);
            if (victim->pcdata->trance <= 0 && !mindbroken(victim)) {
              send_to_char("They're not in a trance.\n\r", ch);
              return;
            }
          }

          for (int i = 0; i < 25; i++) {
            if (victim->pcdata->imprint_type[i] == 0) {
              victim->pcdata->imprint_type[i] = IMPRINT_TRIGGEREDBODYCOMPULSION;
              free_string(victim->pcdata->imprint[i]);
              victim->pcdata->imprint[i] = str_dup(argument);
              free_string(victim->pcdata->imprint_trigger[i]);
              victim->pcdata->imprint_trigger[i] = str_dup(rectalk);
              victim->pcdata->imprint_pending[i] = -5;
              victim->pcdata->imprint_pressure_one[i] = pone;
              victim->pcdata->imprint_pressure_two[i] = ptwo;
              victim->pcdata->imprint_pressure_three[i] = pthree;
              victim->pcdata->imprinter = ch;
              victim->pcdata->trance = -60;
              printf_to_char(ch, "You attempt to compel %s's motor cortex so that their body %s from when they see or hear '%s' with a combination of %s, %s, and %s.\n\r", PERS(victim, ch), argument, rectalk, hypno_names[pone], hypno_names[ptwo], hypno_names[pthree]);
              sprintf(buf, "$n tells $N to '%s'", argument);
              act(buf, ch, NULL, victim, TO_NOTVICT);
              printf_to_char(
              victim, "Your motor cortex has recieved a compulsion, attempting to make it so your body %s.\nTo accept this instruction  use imprint accept, to try to resist use imprint resist (pressure one) (pressure two) (pressure three) where each pressure is a type of manipulation most likely to make your character succumb to the instruction and are given in order of strength. Possible pressures are", argument);
              for (int i = 1; i <= HYPNO_PITY; i++)
              printf_to_char(victim, ", %s", hypno_names[i]);
              send_to_char(".\n\r", victim);
              return;
            }
          }
        }
      }
    }
  }

  _DOFUN(do_satiate) {
    for (int i = 0; i < 25; i++) {
      if (ch->pcdata->imprint_type[i] == IMPRINT_INSTRUCTION && (!str_cmp(argument, ch->pcdata->imprint[i]) || (safe_strlen(argument) > 10 && strcasestr(ch->pcdata->imprint[i], argument) != NULL))) {
        send_to_char("You satiate that desire and it fades from your mind.\n\r", ch);
        if (ch->pcdata->imprint_pending[i] == 5 && ch->pcdata->branddate > 0) {
          ch->pcdata->imprint_pending[i] = 4;
          ch->pcdata->imprint_type[i] = IMPRINT_TRIGGEREDINSTRUCTION;
        }
        else
        ch->pcdata->imprint_type[i] = 0;
        return;
      }
      else if (ch->pcdata->imprint_type[i] == IMPRINT_PERSUADE && (!str_cmp(argument, ch->pcdata->imprint[i]) || (safe_strlen(argument) > 10 && strcasestr(ch->pcdata->imprint[i], argument) != NULL))) {
        send_to_char("You satiate that desire and it fades from your mind.\n\r", ch);
        ch->pcdata->imprint_type[i] = 0;
        return;
      }
      else if (ch->pcdata->imprint_type[i] == IMPRINT_BODYINSTRUCTION && (!str_cmp(argument, ch->pcdata->imprint[i]) || (safe_strlen(argument) > 10 && strcasestr(ch->pcdata->imprint[i], argument) != NULL))) {
        send_to_char("You satiate that desire and it fades from your motor cortex.\n\r", ch);
        if (ch->pcdata->imprint_pending[i] == 5 && ch->pcdata->branddate > 0) {
          ch->pcdata->imprint_pending[i] = 4;
          ch->pcdata->imprint_type[i] = IMPRINT_TRIGGEREDBODYINSTRUCTION;
        }
        else
        ch->pcdata->imprint_type[i] = 0;
        return;
      }
      else if (ch->pcdata->imprint_type[i] == IMPRINT_COMPULSION && (!str_cmp(argument, ch->pcdata->imprint[i]) || (safe_strlen(argument) > 10 && strcasestr(ch->pcdata->imprint[i], argument) != NULL))) {
        send_to_char("You satiate that desire.\n\r", ch);
        if (ch->pcdata->imprint_pending[i] != 3 || ch->pcdata->branddate == 0)
        ch->pcdata->imprint_pending[i] = 1;
        return;
      }
      else if (ch->pcdata->imprint_type[i] == IMPRINT_BODYCOMPULSION && (!str_cmp(argument, ch->pcdata->imprint[i]) || (safe_strlen(argument) > 10 && strcasestr(ch->pcdata->imprint[i], argument) != NULL))) {
        send_to_char("You satiate that desire.\n\r", ch);
        if (ch->pcdata->imprint_pending[i] != 3 || ch->pcdata->branddate == 0)
        ch->pcdata->imprint_pending[i] = 1;
        return;
      }
      else if (!str_cmp(argument, ch->pcdata->imprint[i]) && safe_strlen(argument) > 2) {
        send_to_char("That desire cannot be satiated.\n\r", ch);
        return;
      }
    }
    printf_to_char(ch, "You don't have a desire like %s, these are your possible targets for satiation:\n\r", argument);
    for (int i = 0; i < 25; i++) {
      if (safe_strlen(ch->pcdata->imprint[i]) > 1 && (ch->pcdata->imprint_type[i] == IMPRINT_BODYCOMPULSION || ch->pcdata->imprint_type[i] == IMPRINT_COMPULSION || ch->pcdata->imprint_type[i] == IMPRINT_PERSUADE || ch->pcdata->imprint_type[i] == IMPRINT_INSTRUCTION || ch->pcdata->imprint_type[i] == IMPRINT_BODYINSTRUCTION))
      printf_to_char(ch, "%s\n\r", ch->pcdata->imprint[i]);
    }
    return;
  }

  void triggercheck(CHAR_DATA *ch, char *message) {
    if (IS_NPC(ch))
    return;
    for (int i = 0; i < 25; i++) {
      if (ch->pcdata->imprint_type[i] == IMPRINT_TRIGGEREDINSTRUCTION) {
        if (strcasestr(message, ch->pcdata->imprint_trigger[i]) != NULL) {
          ch->pcdata->imprint_type[i] = IMPRINT_INSTRUCTION;
          printf_to_char(ch, "You now need to %s.\n\r", ch->pcdata->imprint[i]);
          if (ch->pcdata->imprint_pending[i] == 4)
          ch->pcdata->imprint_pending[i] = 5;
        }
      }
      if (ch->pcdata->imprint_type[i] == IMPRINT_TRIGGEREDBODYINSTRUCTION) {
        if (strcasestr(message, ch->pcdata->imprint_trigger[i]) != NULL) {
          ch->pcdata->imprint_type[i] = IMPRINT_BODYINSTRUCTION;
          printf_to_char(ch, "Your body now %s.\n\r", ch->pcdata->imprint[i]);
          if (ch->pcdata->imprint_pending[i] == 4)
          ch->pcdata->imprint_pending[i] = 5;
        }
      }
      if (ch->pcdata->imprint_type[i] == IMPRINT_TRIGGEREDCOMPULSION) {
        if (strcasestr(message, ch->pcdata->imprint_trigger[i]) != NULL) {
          ch->pcdata->imprint_type[i] = IMPRINT_COMPULSION;
          printf_to_char(ch, "You now need to %s.\n\r", ch->pcdata->imprint[i]);
          if (ch->pcdata->imprint_pending[i] == 4)
          ch->pcdata->imprint_pending[i] = 3;
        }
      }
      if (ch->pcdata->imprint_type[i] == IMPRINT_TRIGGEREDBODYCOMPULSION) {
        if (strcasestr(message, ch->pcdata->imprint_trigger[i]) != NULL) {
          ch->pcdata->imprint_type[i] = IMPRINT_BODYCOMPULSION;
          printf_to_char(ch, "Your body now %s.\n\r", ch->pcdata->imprint[i]);
          if (ch->pcdata->imprint_pending[i] == 4)
          ch->pcdata->imprint_pending[i] = 3;
        }
      }
    }
  }

  void persuade_char(CHAR_DATA *victim, CHAR_DATA *persuader, char *message, int pone, int ptwo, int pthree) {
    if (IS_NPC(victim) || IS_NPC(persuader))
    return;

    if(persuader->pcdata->boon == BOON_SILVERTONGUE && persuader->pcdata->boon_timeout > current_time)
    {
      auto_imprint_timed(victim, message, IMPRINT_INFLUENCE, 60);
      send_to_char("You use your silver tongue to influence them.\n\r", persuader);
      persuader->pcdata->persuade_target = NULL;
      persuader->pcdata->persuade_pone = 0;
      return;
    }


    for (int i = 0; i < 25; i++) {
      if (victim->pcdata->imprint_type[i] == 0) {
        victim->pcdata->imprint_type[i] = IMPRINT_PERSUADE;
        free_string(victim->pcdata->imprint[i]);
        victim->pcdata->imprint[i] = str_dup(message);
        victim->pcdata->imprint_pending[i] = -5;
        victim->pcdata->imprint_pressure_one[i] = pone;
        victim->pcdata->imprint_pressure_two[i] = ptwo;
        victim->pcdata->imprint_pressure_three[i] = pthree;
        victim->pcdata->imprinter = persuader;

        printf_to_char(
        victim, "Your subconcious is being supernaturally persuaded to %s.\nTo accept this instruction use imprint accept, to try to resist use imprint resist (pressure one) (pressure two) (pressure three) where each pressure is a type of manipulation most likely to make your character succumb to the instruction and are given in order of strength. Possible pressures are", message);
        for (int i = 1; i <= HYPNO_PITY; i++)
        printf_to_char(victim, ", %s", hypno_names[i]);
        send_to_char(".\n\r", victim);
        persuader->pcdata->persuade_target = NULL;
        persuader->pcdata->persuade_pone = 0;
        return;
      }
    }
  }

  void persuade_check(CHAR_DATA *ch, CHAR_DATA *victim, char *message) {
    if (IS_NPC(ch) || IS_NPC(victim))
    return;
    if (ch->pcdata->persuade_target == NULL || ch->pcdata->persuade_target != victim)
    return;
    log_string("Checking Persuasion.");
    if (strcasestr(message, ch->pcdata->persuade_message) != NULL && ch->pcdata->persuade_pone != 0) {
      persuade_char(victim, ch, ch->pcdata->persuade_message, ch->pcdata->persuade_pone, ch->pcdata->persuade_ptwo, ch->pcdata->persuade_pthree);
      send_to_char("You begin your attempt at psychic persuasion.\n\r", ch);
    }
  }

  _DOFUN(do_persuade) {
    CHAR_DATA *victim;
    char arg1[MSL];
    char arg5[MSL];
    char arg3[MSL];
    char arg4[MSL];
    int pone = 0, ptwo = 0, pthree = 0;
    argument = one_argument_nouncap(argument, arg1);

    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }
    if (IS_NPC(victim)) {
      send_to_char("Not on NPCs.\n\r", ch);
      return;
    }
    if (ch->pcdata->persuade_cooldown > 0) {
      send_to_char("You can't do that yet.\n\r", ch);
      return;
    }
    if (base_lifeforce(ch) < 9000) {
      send_to_char("You lack the life energy to do that.\n\r", ch);
      return;
    }
    if (get_skill(ch, SKILL_PERSUADE) <= 0) {
      send_to_char("You do not have that power.\n\r", ch);
      return;
    }
    if (is_mute(ch) || IS_FLAG(ch->comm, COMM_GAG)) {
      send_to_char("You can't speak.\n\r", ch);
      return;
    }
    if (is_deaf(victim)) {
      send_to_char("They can't hear you.\n\r", ch);
      return;
    }
    if (mindwarded(victim)) {
      send_to_char("It doesn't seem to work.\n\r", ch);
      return;
    }

    argument = one_argument_nouncap(argument, arg3);
    argument = one_argument_nouncap(argument, arg4);
    argument = one_argument_nouncap(argument, arg5);
    for (int i = 1; i <= HYPNO_PITY; i++) {
      if (!str_cmp(arg3, hypno_names[i]))
      pone = i;
      if (!str_cmp(arg4, hypno_names[i]))
      ptwo = i;
      if (!str_cmp(arg5, hypno_names[i]))
      pthree = i;
    }
    if (pone < 1 || ptwo < 1 || pthree < 1 || safe_strlen(argument) < 2) {
      send_to_char("Syntax: Persuade (person) (pressure one) (pressure two) (pressure three) (instruction)\n\rPossible Pressures", ch);
      for (int i = 1; i <= HYPNO_PITY; i++)
      printf_to_char(ch, ", %s", hypno_names[i]);
      send_to_char(".\n\r", ch);
      return;
    }
    villain_mod(ch, 5, "Persuade");

    ch->pcdata->persuade_target = victim;
    ch->pcdata->persuade_cooldown = 6;
    free_string(ch->pcdata->persuade_message);
    ch->pcdata->persuade_message = str_dup(argument);
    ch->pcdata->persuade_pone = pone;
    ch->pcdata->persuade_ptwo = ptwo;
    ch->pcdata->persuade_pthree = pthree;
    printf_to_char(ch, "You prepare to persuade %s with a combination of %s, %s and %s to do %s. This will occur the next time to mention the instruction in an emote or say.\n\r", PERS(victim, ch), hypno_names[pone], hypno_names[ptwo], hypno_names[pthree], argument);
    use_lifeforce(ch, 15, "Persuade.");
    return;
  }

  bool has_pact(CHAR_DATA *ch, CHAR_DATA *victim) {
    if (!higher_power(ch))
    return FALSE;
    for (int i = 0; i < 10; i++) {
      if (victim->pcdata->relationship_type[i] == REL_PACTEE && !str_cmp(victim->pcdata->relationship[i], ch->name))
      return TRUE;
    }
    return FALSE;
  }

  _DOFUN(do_brand) {
    if (event_cleanse == 1)
    return;
    CHAR_DATA *victim;
    if (is_animal(ch))
    return;
    char arg1[MSL];
    char arg2[MSL];
    char buf[MSL];

    argument = one_argument_nouncap(argument, arg1);

    if (is_helpless(ch)) {
      send_to_char("Not now.\n\r", ch);
      return;
    }
    if (!str_cmp(arg1, "incapacitate")) {
      if (in_fight(ch) || is_asleep(ch)) {
        send_to_char("Not now.\n\r", ch);
        return;
      }

      if ((victim = get_char_world(ch, argument)) == NULL || (IS_NPC(victim))) {
        if ((victim = get_char_world_pc(argument)) == NULL) {
          send_to_char("You can't find them.\n\r", ch);
          return;
        }
      }
      if (str_cmp(victim->pcdata->brander, ch->name) || victim->pcdata->branddate == 0) {
        if (!has_pact(ch, victim)) {
          send_to_char("You can't find them.\n\r", ch);
          return;
        }
      }
      if (in_world(ch) != in_world(victim) && !has_pact(ch, victim)) {
        send_to_char("You can't find them.\n\r", ch);
        return;
      }

      send_to_char("You unleash power along your branding connection to incapacitate your quary.\n\r", ch);
      printf_to_char(victim, "You feel a sharp, eletrocution like pain emenating from your %s before spreading through your entire body, you convulse and the world goes black.\n\r", name_by_location(victim->pcdata->brandlocation));
      act("$n shudders and collapses.", victim, NULL, NULL, TO_ROOM);
      dact("$n shudders and collapses.", victim, NULL, NULL, DISTANCE_MEDIUM);
      victim->pcdata->sleeping = 150;
      return;
    }
    if (!str_cmp(arg1, "phantom")) {
      argument = one_argument_nouncap(argument, arg2);
      if (safe_strlen(argument) < 2) {
        send_to_char("Syntax: brand phantom (person) electrifying/freezing/burning/whipping/striking/cutting/punching/stabbing/slapping/pinching (body location)\n\r", ch);
        return;
      }
      if ((victim = get_char_world(ch, arg2)) == NULL || (IS_NPC(victim))) {
        if ((victim = get_char_world_pc(arg2)) == NULL) {
          send_to_char("You can't find them.\n\r", ch);
          return;
        }
      }
      if (str_cmp(victim->pcdata->brander, ch->name) || victim->pcdata->branddate == 0) {
        if (!has_pact(ch, victim)) {
          send_to_char("You can't find them.\n\r", ch);
          return;
        }
      }
      if (in_world(ch) != in_world(victim) && !has_pact(ch, victim)) {
        send_to_char("You can't find them.\n\r", ch);
        return;
      }
      if (in_fight(ch) || is_helpless(ch)) {
        send_to_char("You can't find them.\n\r", ch);
        return;
      }
      char arg3[MSL];
      argument = one_argument_nouncap(argument, arg3);
      if (!str_cmp(arg3, "stabbing")) {
        printf_to_char(victim, "You feel as if you were just stabbed in your %s.", argument);
      }
      else if (!str_cmp(arg3, "slapping")) {
        printf_to_char(victim, "You feel as if you were just slapped on your %s", argument);
      }
      else if (!str_cmp(arg3, "punching")) {
        printf_to_char(victim, "You feel as if you were just punched in your %s.", argument);
      }
      else if (!str_cmp(arg3, "pinching")) {
        printf_to_char(victim, "You feel as if you were just pinched on your %s.", argument);
      }
      else if (!str_cmp(arg3, "cutting")) {
        printf_to_char(victim, "You feel as if your %s was just cut open.", argument);
      }
      else if (!str_cmp(arg3, "striking")) {
        printf_to_char(
        victim, "You feel as if you were just struck by a baseball bat on your %s", argument);
      }
      else if (!str_cmp(arg3, "whipping")) {
        printf_to_char(
        victim, "You feel as if you were just viciously whipped on your %s", argument);
      }
      else if (!str_cmp(arg3, "burning")) {
        printf_to_char(victim, "You feel as if someone is taking a blowtorch to your %s", argument);
      }
      else if (!str_cmp(arg3, "freezing")) {
        printf_to_char(
        victim, "You feel as if someone is spraying liquid nitrogen onto your %s", argument);
      }
      else if (!str_cmp(arg3, "electrifying")) {
        printf_to_char(victim, "You feel as someone just tasered your %s", argument);
      }
      else {
        send_to_char("Syntax: brand phantom (person) electrifying/freezing/burning/whipping/striking/pinching/cutting/punching/stabbing/slapping (body location)\n\r", ch);
        return;
      }

      printf_to_char(ch, "You send the sensation of %s pain coming from %s's %s through your psychic link.\n\r", arg3, PERS(victim, ch), argument);
      return;
    }
    if (!str_cmp(arg1, "listen")) {
      if (get_skill(ch, SKILL_BRANDING) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (!str_cmp(argument, "stop")) {
        ch->pcdata->brandstatus = 0;
        send_to_char("You stop listening to your branded.\n\r", ch);
        return;
      }
      if (ch->pcdata->brandstatus > 0) {
        send_to_char("You're already listening.\n\r", ch);
        return;
      }
      use_lifeforce(ch, 10, "Brand listen.");
      ch->pcdata->brandstatus = 1;
      send_to_char("You cast out your will to start listening to the lives of your branded.\n\r", ch);
      return;
    }
    if (!str_cmp(arg1, "watch")) {
      if (get_skill(ch, SKILL_BRANDING) < 1) {
        send_to_char("You don't have that ability.\n\r", ch);
        return;
      }
      if (!str_cmp(argument, "stop")) {
        ch->pcdata->brandstatus = 0;
        send_to_char("You stop watching to your branded.\n\r", ch);
        return;
      }
      if (ch->pcdata->brandstatus > 1) {
        send_to_char("You're already watching.\n\r", ch);
        return;
      }
      use_lifeforce(ch, 250, "Brand watch.");
      ch->pcdata->brandstatus = 2;
      send_to_char("You cast out your will to start watching the lives of your branded.\n\r", ch);
      return;
    }

    if (!str_cmp(arg1, "remove")) {
      if ((victim = get_char_room(ch, NULL, argument)) == NULL) {
        send_to_char("They're not here.\n\r", ch);
        return;
      }
      if (!workshop_room(ch->in_room)) {
        send_to_char("You need to be in an arcane workshop to do that.\n\r", ch);
        return;
      }
      if ((!has_trust(ch, TRUST_RESOURCES, ch->faction)) || !can_spend_resources(clan_lookup(ch->faction))) {
        send_to_char("You need to have access to your faction's resources first.\n\r", ch);
        return;
      }
      int faccost = 1500;
      int timesince = current_time - victim->pcdata->branddate;
      timesince = timesince / 3600;
      faccost -= timesince;
      faccost = UMAX(faccost, 50);

      if (victim->pcdata->branddate == 0 || is_covered(victim, victim->pcdata->brandlocation)) {
        send_to_char("You can't see any brand on them.\n\r", ch);
        return;
      }
      if(victim->pcdata->brand_timeout > 0)
      {
        send_to_char("They are too recently branded to remove.\n\r", ch);
        return;
      }
      if (faccost > 0 && clan_lookup(ch->faction)->resource < 8000 + faccost) {
        printf_to_char(ch, "You would need $%d in society resources.\n\r", 80000 + faccost * 10);
        return;
      }
      printf_to_char(
      ch, "For $%d society resources you remove the brand of %s from %s's %s\n\r", faccost * 10, victim->pcdata->brandstring, PERS(victim, ch), name_by_location(victim->pcdata->brandlocation));
      printf_to_char(
      victim, "You feel a brief burning sensation on the skin of your %s and then a second later the symbol of %s fades from view.\n\r", name_by_location(victim->pcdata->brandlocation), victim->pcdata->brandstring);
      use_resources(faccost, ch->faction, ch, "a brand removal");
      victim->pcdata->branddate = 0;
      return;
    }
    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }
    if (IS_NPC(victim)) {
      send_to_char("You can't brand NPCs.\n\r", ch);
      return;
    }

    if (get_skill(ch, SKILL_BRANDING) < 1 && victim->pcdata->destiny_feature != DEST_FEAT_BRAND) {
      send_to_char("You don't have that ability.\n\r", ch);
      return;
    }
    if (higher_power(victim)) {
      send_to_char("That seems beyond you.\n\r", ch);
      return;
    }

    if (is_ghost(ch)) {
      send_to_char("Slaying the living is no longer so simple./n/r", ch);
      return;
    }
    if (is_ghost(victim)) {
      send_to_char("Slaying a ghost is not so simple./n/r", ch);
      return;
    }
    if (!IS_NPC(victim) && victim->pcdata->trance > 0)
    victim->pcdata->trance = -20;

    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (base_lifeforce(ch) < 9000) {
      send_to_char("You're a bit week to attempt that.\n\r", ch);
      return;
    }
    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (!is_helpless(victim)) {
      send_to_char("You'd have to subdue them first.\n\r", ch);
      return;
    }
    if (room_hostile(ch->in_room)) {
      start_hostilefight(ch);
      return;
    }
    if (ch == victim) {
      send_to_char("You can't brand yourself.\n\r", ch);
      return;
    }
    if (ch->pcdata->brandcool > current_time) {
      send_to_char("You did that too recently.\n\r", ch);
      return;
    }
    int cost = 20;
    cost -= get_tier(ch) * 3;
    cost += get_tier(victim) * 3;
    argument = one_argument_nouncap(argument, arg2);
    int location = location_by_name(arg2);
    if (location == -1 || location >= COVERS_SMELL || safe_strlen(argument) < 2 || location == COVERS_HAIR || location == COVERS_EYES) {
      send_to_char("Syntax: brand (person) (location) (brand string\nValid locations: hands, lowerarms, upperarms, feet, lowerlegs, thighs, groin,  arse, lowerback, upperback, lowerchest, breasts, upperchest, neck, lowerface, forehead.\n\r", ch);
      return;
    }

    if(!str_cmp(ch->pcdata->fixation_name, victim->name) && ch->pcdata->fixation_level >= 4 && ch->pcdata->fixation_charges > 0) {
      ch->pcdata->fixation_charges--;
      victim->pcdata->brand_timeout = UMAX(current_time+(3600*24*7), ch->pcdata->fixation_timeout);
      victim->pcdata->branddate = current_time;
      free_string(victim->pcdata->brander);
      victim->pcdata->brander = str_dup(ch->name);
      free_string(victim->pcdata->brandstring);
      victim->pcdata->brandstring = str_dup(argument);
      victim->pcdata->brandlocation = location;

      sprintf(buf, "You press a hand to $N's %s, and when you lift it a brand of %s is left, freshly emblazoned into the skin.", name_by_location(location), argument);
      act(buf, ch, NULL, victim, TO_CHAR);
      sprintf(buf, "$n presses a hand to your %s for a moment and a searing pain shoots through your body as if being burned.", name_by_location(location));
      act(buf, ch, NULL, victim, TO_VICT);
      sprintf(buf, "$n presses a hand to $N's %s for a moment.", name_by_location(location));
      act(buf, ch, NULL, victim, TO_NOTVICT);
      dact(buf, ch, NULL, victim, DISTANCE_NEAR);
      return;

    }

    if (victim->faction != 0 && clan_lookup(victim->faction) != NULL && clan_lookup(victim->faction)->attributes[FACTION_UNDERSTANDING] > 0 && under_understanding(victim, ch) && victim->pcdata->destiny_feature != DEST_FEAT_BRAND) {
      sprintf(buf, "You press a hand to $N's %s, but nothing happens. You sense they are protected by %s", name_by_location(location), clan_lookup(victim->faction)->name);
      act(buf, ch, NULL, victim, TO_CHAR);
      sprintf(buf, "$n presses a hand to your %s for a moment.", name_by_location(location));
      act(buf, ch, NULL, victim, TO_VICT);
      sprintf(buf, "$n presses a hand to $N's %s for a moment.", name_by_location(location));
      act(buf, ch, NULL, victim, TO_NOTVICT);
      dact(buf, ch, NULL, victim, DISTANCE_NEAR);
      return;
    }
    if (victim->vassal != 0 && clan_lookup(victim->vassal) != NULL && clan_lookup(victim->vassal)->attributes[FACTION_UNDERSTANDING] > 0 && under_understanding(victim, ch) && victim->pcdata->destiny_feature != DEST_FEAT_BRAND) {
      sprintf(buf, "You press a hand to $N's %s, but nothing happens. You sense they are protected by %s", name_by_location(location), clan_lookup(victim->vassal)->name);
      act(buf, ch, NULL, victim, TO_CHAR);
      sprintf(buf, "$n presses a hand to your %s for a moment.", name_by_location(location));
      act(buf, ch, NULL, victim, TO_VICT);
      sprintf(buf, "$n presses a hand to $N's %s for a moment.", name_by_location(location));
      act(buf, ch, NULL, victim, TO_NOTVICT);
      dact(buf, ch, NULL, victim, DISTANCE_NEAR);
      return;
    }
    if (newbie_level(victim) < 3 && victim->pcdata->destiny_feature != DEST_FEAT_BRAND) {
      sprintf(buf, "You press a hand to $N's %s, but nothing happens. You sense they are protected by Sanctuary", name_by_location(location));
      act(buf, ch, NULL, victim, TO_CHAR);
      sprintf(buf, "$n presses a hand to your %s for a moment.", name_by_location(location));
      act(buf, ch, NULL, victim, TO_VICT);
      sprintf(buf, "$n presses a hand to $N's %s for a moment.", name_by_location(location));
      act(buf, ch, NULL, victim, TO_NOTVICT);
      dact(buf, ch, NULL, victim, DISTANCE_NEAR);
      return;
    }

    if (victim->pcdata->branddate > 0 && victim->pcdata->destiny_feature != DEST_FEAT_BRAND) {
      sprintf(buf, "You press a hand to $N's %s, but nothing happens.", name_by_location(location));
      act(buf, ch, NULL, victim, TO_CHAR);
      sprintf(buf, "$n presses a hand to your %s for a moment.", name_by_location(location));
      act(buf, ch, NULL, victim, TO_VICT);
      sprintf(buf, "$n presses a hand to $N's %s for a moment.", name_by_location(location));
      act(buf, ch, NULL, victim, TO_NOTVICT);
      dact(buf, ch, NULL, victim, DISTANCE_NEAR);
      return;
    }
    victim->pcdata->brand_timeout = 0;
    ch->pcdata->brandcool = current_time + (3600 * 24 * 21);
    victim->pcdata->branddate = current_time;
    free_string(victim->pcdata->brander);
    victim->pcdata->brander = str_dup(ch->name);
    free_string(victim->pcdata->brandstring);
    victim->pcdata->brandstring = str_dup(argument);
    victim->pcdata->brandlocation = location;

    if (get_tier(victim) <= 1)
    villain_mod(ch, 20, "Branding");
    else
    villain_mod(ch, 40, "Branding");

    for (int i = 0; i < 25; i++) {
      if (victim->pcdata->imprint_type[i] == IMPRINT_COMPULSION)
      victim->pcdata->imprint_pending[i] = 3;
      if (victim->pcdata->imprint_type[i] == IMPRINT_BODYCOMPULSION)
      victim->pcdata->imprint_pending[i] = 3;
      if (victim->pcdata->imprint_type[i] == IMPRINT_TRIGGEREDINSTRUCTION)
      victim->pcdata->imprint_pending[i] = 4;
      if (victim->pcdata->imprint_type[i] == IMPRINT_TRIGGEREDBODYINSTRUCTION)
      victim->pcdata->imprint_pending[i] = 4;
    }
    sprintf(buf, "You press a hand to $N's %s, and when you lift it a brand of %s is left, freshly emblazoned into the skin.", name_by_location(location), argument);
    act(buf, ch, NULL, victim, TO_CHAR);
    sprintf(buf, "$n presses a hand to your %s for a moment and a searing pain shoots through your body as if being burned.", name_by_location(location));
    act(buf, ch, NULL, victim, TO_VICT);
    sprintf(buf, "$n presses a hand to $N's %s for a moment.", name_by_location(location));
    act(buf, ch, NULL, victim, TO_NOTVICT);
    dact(buf, ch, NULL, victim, DISTANCE_NEAR);
  }

  _DOFUN(do_scar) {
    CHAR_DATA *victim;

    if (is_animal(ch))
    return;
    if (guestmonster(ch))
    return;
    char arg1[MSL];
    char arg2[MSL];
    char buf[MSL];

    argument = one_argument_nouncap(argument, arg1);
    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (!IS_NPC(victim) && victim->pcdata->trance > 0)
    victim->pcdata->trance = -20;

    if (is_ghost(ch)) {
      send_to_char("Slaying the living is no longer so simple./n/r", ch);
      return;
    }

    if (is_ghost(victim)) {
      send_to_char("Slaying a ghost is not so simple./n/r", ch);
      return;
    }
    if (under_understanding(victim, ch)) {
      send_to_char("Your body refuses to obey that instruction.\n\r", ch);
      return;
    }
    if (under_limited(victim, ch)) {
      send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
      return;
    }
    if (higher_power(ch) || higher_power(victim))
    return;

    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (!is_helpless(victim)) {
      send_to_char("You'd have to subdue them first.\n\r", ch);
      return;
    }
    if (room_hostile(ch->in_room)) {
      start_hostilefight(ch);
      return;
    }
    if (IS_NPC(victim)) {
      send_to_char("You can't brand NPCs.\n\r", ch);
      return;
    }
    argument = one_argument_nouncap(argument, arg2);
    int location = location_by_name(arg2);
    if (location == -1 || location >= COVERS_SMELL || safe_strlen(argument) < 2) {
      send_to_char("Syntax: scar (person) (location) (message)\nValid locations: hands, lowerarms, upperarms, feet, lowerlegs, thighs, groin,  arse, lowerback, upperback, lowerchest, breasts, upperchest, neck, lowerface, forehead, hair, eyes.\n\r", ch);
      return;
    }
    if (safe_strlen(victim->pcdata->scars[location]) > 2) {
      sprintf(buf, "%s and %s", victim->pcdata->scars[location], argument);
      free_string(victim->pcdata->scars[location]);
      victim->pcdata->scars[location] = str_dup(buf);
    }
    else {
      free_string(victim->pcdata->scars[location]);
      victim->pcdata->scars[location] = str_dup(argument);
    }
    printf_to_char(ch, "You mark %s's %s so that %s.\n\r", PERS(victim, ch), name_by_location(location), argument);
    printf_to_char(victim, "%s marks your %s so that %s.\n\r", PERS(ch, victim), name_by_location(location), argument);
    act("$n marks $N permanently.", ch, NULL, victim, TO_NOTVICT);
  }

  _DOFUN(do_maim) {
    CHAR_DATA *victim;

    if (is_animal(ch))
    return;
    if (guestmonster(ch) || higher_power(ch))
    return;
    char arg1[MSL];

    argument = one_argument_nouncap(argument, arg1);
    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (is_ghost(ch)) {
      send_to_char("Slaying the living is no longer so simple./n/r", ch);
      return;
    }

    if (is_ghost(victim)) {
      send_to_char("Slaying a ghost is not so simple./n/r", ch);
      return;
    }
    if (under_understanding(victim, ch)) {
      send_to_char("Your body refuses to obey that instruction.\n\r", ch);
      return;
    }
    if (under_limited(victim, ch)) {
      send_to_char("Your body seems unwilling to follow your commands to do that.\n\r", ch);
      return;
    }

    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (!IS_NPC(victim) && victim->pcdata->trance > 0)
    victim->pcdata->trance = -20;

    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (!is_helpless(victim)) {
      send_to_char("You'd have to subdue them first.\n\r", ch);
      return;
    }
    if (room_hostile(ch->in_room)) {
      start_hostilefight(ch);
      return;
    }
    if (IS_NPC(victim)) {
      send_to_char("You can't brand NPCs.\n\r", ch);
      return;
    }
    if (safe_strlen(argument) < 2) {
      send_to_char("Syntax: maim (person) (message)\n\r", ch);
      return;
    }
    if (is_griefer(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (higher_power(victim))
    return;
    maim_char(victim, argument);
    printf_to_char(ch, "You maim %s so that %s.\n\r", PERS(victim, ch), argument);
    printf_to_char(victim, "%s maims you so that %s.\n\r", PERS(ch, victim), argument);
    act("$n maims $N permanently.", ch, NULL, victim, TO_NOTVICT);
  }

  _DOFUN(do_turn) {
    CHAR_DATA *victim;

    char arg1[MSL];

    argument = one_argument_nouncap(argument, arg1);
    if ((victim = get_char_room(ch, NULL, arg1)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (is_ghost(ch)) {
      send_to_char("Slaying the living is no longer so simple./n/r", ch);
      return;
    }

    if (is_ghost(victim)) {
      send_to_char("Slaying a ghost is not so simple./n/r", ch);
      return;
    }
    if (!IS_NPC(victim) && victim->pcdata->trance > 0)
    victim->pcdata->trance = -20;

    if (under_understanding(victim, ch) && victim->pcdata->destiny_feature != DEST_FEAT_TURN) {
      send_to_char("Your body refuses to obey that instruction.\n\r", ch);
      return;
    }
    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (!is_helpless(victim) && victim->pcdata->destiny_feature != DEST_FEAT_TURN) {
      send_to_char("You'd have to subdue them first.\n\r", ch);
      return;
    }
    if (room_hostile(ch->in_room)) {
      start_hostilefight(ch);
      return;
    }
    if (IS_NPC(victim)) {
      send_to_char("You can't turn NPCs.\n\r", ch);
      return;
    }
    if (!is_vampire(ch) && !is_werewolf(ch)) {
      send_to_char("You need to be a vampire or werewolf to do that.\n\r", ch);
      return;
    }
    if (is_vampire(victim) || is_werewolf(victim) || victim->race == RACE_FACULTY || victim->race == RACE_WIGHT) {
      send_to_char("They can't be turned.\n\r", ch);
      return;
    }
    if (get_tier(victim) > 3) {
      send_to_char("They can't be turned.\n\r", ch);
      return;
    }
    tm *ptm;
    time_t east_time;

    east_time = current_time;
    ptm = gmtime(&east_time);
    int year = ptm->tm_year + 1900;

    if (is_vampire(ch)) {
      victim->race = RACE_NEWVAMPIRE;
      if (get_tier(victim) == 1) {
        victim->modifier = MODIFIER_NEW;
      }
      else if (get_tier(victim) == 2 && ch->skills[SKILL_MENTALDISCIPLINE] <= 0) {
        victim->modifier = 0;
      }
      else if (get_tier(victim) == 3 || (get_tier(victim) == 2 && ch->skills[SKILL_MENTALDISCIPLINE] > 0)) {
        victim->modifier = MODIFIER_STRONG;
      }
      act("$n bites $N and drains $M almost completely of blood before feeding $M from $s own wrist. $N's eyes widen and $E clutches at $S left arm for a moment before sagging back to the ground, dead.", ch, NULL, victim, TO_NOTVICT);
      act("You bite $N and drain $M almost completely of blood before feeding $M from your own wrist. $N's eyes widen and $E clutches at $S left arm for a moment before sagging back to the ground, dead.", ch, NULL, victim, TO_CHAR);
      act("$n bites you and drains you almost completely of blood before feeding you from $s own wrist. After a moment you feel a stabbing pain shooting through your chest from the left side, and then everything fades into darkness.", ch, NULL, victim, TO_VICT);
      dact("$n bites $N and drains $M almost completely of blood before feeding $M from $s own wrist. $N's eyes widen and $E clutches at $S left arm for a moment before sagging back to the ground, dead.", ch, NULL, victim, DISTANCE_NEAR);

      victim->pcdata->sire_year = year;
      victim->pcdata->sire_month = ptm->tm_mon + 1;
      victim->pcdata->sire_day = ptm->tm_mday;
      victim->pcdata->coma = current_time + (3600 * 5);
      return;
    }
    if (is_werewolf(ch)) {
      if (!is_animal(ch)) {
        send_to_char("You must transform first.\n\r", ch);
        return;
      }
      if (!IS_FLAG(victim->act, PLR_WOLFBIT))
      SET_FLAG(victim->act, PLR_WOLFBIT);
      wound_char(victim, 1);
      act("$n bites $N viciously in the same place over and over, sinking fangs into bloody flesh repeatedly.", ch, NULL, victim, TO_NOTVICT);
      act("You bite $N viciously in the same place over and over, sinking fangs into bloody flesh repeatedly.", ch, NULL, victim, TO_CHAR);
      act("$n bites you viciously in the same place over and over, sinking fangs into bloody flesh repeatedly.", ch, NULL, victim, TO_VICT);
      dact("$n bites $N viciously in the same place over and over, sinking fangs into bloody flesh repeatedly.", ch, NULL, victim, DISTANCE_NEAR);
      return;
    }
  }

  _DOFUN(do_speak) {
    if (lang_level(ch, argument) <= 0) {
      send_to_char("You don't know how to speak that.\n\r", ch);
      return;
    }
    free_string(ch->pcdata->speaking);
    ch->pcdata->speaking = str_dup(argument);
    printf_to_char(ch, "You start speaking in %s.\n\r", argument);
  }

  _DOFUN(do_path) {
    if (in_fight(ch)) {
      static char buf[200];
      sprintf(buf, "%s path", argument);
      do_function(ch, &do_move, buf);
      return;
    }
    if (get_skill(ch, SKILL_PATHING) < 4) {
      send_to_char("You don't have that skill.\n\r", ch);
      return;
    }
    if (IS_AFFECTED(ch, AFF_PATHED)) {
      send_to_char("You've done that too recently.\n\r", ch);
      return;
    }
    if (IS_FLAG(ch->act, PLR_SHROUD)) {
      send_to_char("You can't do that while in the nightmare.\n\r", ch);
      return;
    }
    if (in_fight(ch) || is_helpless(ch) || is_pinned(ch) || room_hostile(ch->in_room) || is_prisoner(ch)) {
      send_to_char("Not now.\n\r", ch);
      return;
    }
    for (int dir = 0; dir < 10; dir++) {
      if (!str_cmp(argument, dir_name[dir][0])) {
        if (ch->in_room->exit[dir] == NULL || ch->in_room->exit[dir]->u1.to_room == NULL) {
          act("$n steps forward and then explodes in a spray of blood and gore.", ch, NULL, NULL, TO_ROOM);
          act("Pain shoots through your body.", ch, NULL, NULL, TO_CHAR);
          free_string(ch->pcdata->deathcause);
          ch->pcdata->deathcause = str_dup("exploding");
          real_kill(ch, ch);
        }
        act("$n steps into thin air.", ch, NULL, NULL, TO_ROOM);
        act("You step through the air.", ch, NULL, NULL, TO_CHAR);
        ROOM_INDEX_DATA *room = ch->in_room->exit[dir]->u1.to_room;
        char_from_room(ch);
        char_to_room(ch, room);
        act("You step out on the other side.", ch, NULL, NULL, TO_CHAR);
        act("$n steps out of the air.", ch, NULL, NULL, TO_ROOM);
        WAIT_STATE(ch, PULSE_PER_SECOND * 5);
        AFFECT_DATA af;
        af.where = TO_AFFECTS;
        af.type = 0;
        af.level = 10;
        af.duration = 750;
        af.location = APPLY_NONE;
        af.modifier = 0;
        af.caster = NULL;
        af.weave = FALSE;
        af.bitvector = AFF_PATHED;
        affect_to_char(ch, &af);
        return;
      }
    }
    send_to_char("Path in what direction?\n\r", ch);
  }

  _DOFUN(do_exorcise) {
    CHAR_DATA *victim;
    if ((victim = get_char_room(ch, NULL, argument)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }

    if (is_ghost(ch)) {
      send_to_char("Slaying the living is no longer so simple./n/r", ch);
      return;
    }

    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (!is_helpless(victim)) {
      send_to_char("You'd have to subdue them first.\n\r", ch);
      return;
    }
    ch->pcdata->process = PROCESS_EXORCISE;
    ch->pcdata->process_timer = 30;
    ch->pcdata->process_target = victim;
    act("You start performing an exorcism on $N.", ch, NULL, victim, TO_CHAR);
    act("$n starts performing an exorcism on you.", ch, NULL, victim, TO_VICT);
    act("$n starts performing an exorcism on $N.", ch, NULL, victim, TO_NOTVICT);
  }

  _DOFUN(do_carefor) {
    CHAR_DATA *victim;
    if ((victim = get_char_room(ch, NULL, argument)) == NULL) {
      send_to_char("They're not here.\n\r", ch);
      return;
    }
    if (ch == victim) {
      send_to_char("That might be a little dangerous.\n\r", ch);
      return;
    }
    if (is_ghost(ch)) {
      send_to_char("Slaying the living is no longer so simple./n/r", ch);
      return;
    }

    if (is_ghost(victim)) {
      send_to_char("Slaying a ghost is not so simple./n/r", ch);
      return;
    }

    if (in_fight(ch)) {
      send_to_char("You're a bit busy.\n\r", ch);
      return;
    }
    if (is_helpless(ch)) {
      send_to_char("You can't do that.\n\r", ch);
      return;
    }
    if (!is_helpless(victim)) {
      send_to_char("They don't seem to be a prisoner.\n\r", ch);
      return;
    }
    if (get_skill(ch, SKILL_MEDICINE) < 2) {
      send_to_char("You need at least medicine 2 to do that.\n\r", ch);
      return;
    }

    victim->pcdata->prison_mult = UMAX(1, victim->pcdata->prison_mult);
    int cost = 150;
    cost *= victim->pcdata->prison_mult;
    cost = UMIN(cost, 3000);

    int discount = get_skill(ch, SKILL_MEDICINE);
    discount *= 15;
    discount = UMIN(discount, 85);

    cost = cost * (100 - discount) / 100;

    cost = UMAX(cost, 50);

    int faccost = 0;
    int cashcost = 0;
    if (has_trust(ch, TRUST_RESOURCES, ch->faction) && clan_lookup(ch->faction)->resource >= 5000 + faccost && can_spend_resources(clan_lookup(ch->faction)))
    faccost = cost / 10;
    else
    cashcost = cost * 100;

    if (ch->money < cashcost && cashcost > 0) {
      printf_to_char(ch, "You'd need at least %d dollars to do that.\n\r", cashcost / 100);
      return;
    }
    if (faccost > 0 && clan_lookup(ch->faction)->resource < 5000 + faccost) {
      printf_to_char(ch, "That costs $%d in society resources.\n\r", faccost * 10);
      return;
    }
    if (cashcost > 0) {
      printf_to_char(ch, "For %d dollars in supplies you care for %s.\n\r", cashcost / 100, PERS(victim, ch));
      ch->money -= cashcost;
    }
    else {
      printf_to_char(ch, "For $%d society resources you care for %s.\n\r", faccost * 10, PERS(victim, ch));
      use_resources(faccost, ch->faction, ch, "prisoner care");
    }
    victim->pcdata->prison_care = UMAX(victim->pcdata->prison_care, current_time);
    victim->pcdata->prison_care = UMIN(victim->pcdata->prison_care + (3600 * 12), current_time + (3600 * 20));
    victim->pcdata->prison_mult *= 3;
    save_char_obj(victim, FALSE, FALSE);
    act("You care for $N, making sure they stay physically healthy.", ch, NULL, victim, TO_CHAR);
    if (victim->desc != NULL)
    act("$n cares for you, making sure you stay physically healthy.", ch, NULL, victim, TO_VICT);
    else {
      char buf[MSL];
      sprintf(buf, "%s cares for you, making sure you stay physically healthy.", PERS(ch, victim));
      message_to_char(victim->name, buf);
    }
    act("$n cares for $N, making sure they stay physically healthy.", ch, NULL, victim, TO_NOTVICT);
  }

  void autotrain_discipline(CHAR_DATA *target, int number) {
    for (int i = 0; i < DIS_USED; i++) {
      if (discipline_table[i].vnum == number) {
        if (discipline_table[i].pc < 1) {
          return;
        }
        if (!can_train_disc(target, discipline_table[i].vnum)) {
          return;
        }
        int cost = train_disc_cost(target, discipline_table[i].vnum);

        if (cost < 1)
        return;

        if (target->spentexp + target->spentnewexp >= target->pcdata->exp_cap) {
          return;
        }

        if (cost > available_exp(target)) {
          return;
        }
        target->disciplines[discipline_table[i].vnum]++;
        charge_exp(target, cost);
        target->pcdata->time_since_train = 0;
        printf_to_char(target, "`RYour %s discipline increases!`x\n\r", discipline_table[i].name);
        if (!can_train_disc(target, discipline_table[i].vnum))
        target->pcdata->training_disc = 0;
        return;
      }
    }
  }

  void autotrain_stat(CHAR_DATA *target, int number) {
    int points, tpoints, j, orig;
    for (int i = 0; i < SKILL_USED; i++) {
      int pointer = 0;
      if (skill_table[i].vnum == number) {
        if (target->skills[skill_table[i].vnum] == 0) {
          if (skill_table[i].levels[0] == -1)
          points = skill_table[i].levels[1];
          else
          points = skill_table[i].levels[0];
        }
        else if (target->skills[skill_table[i].vnum] == -1) {
          points = 0;
        }
        else {
          for (j = 0; j < 6; j++) {
            if (target->skills[skill_table[i].vnum] == skill_table[i].levels[j])
            pointer = j;
          }
          if (pointer == 5 || (skill_table[i].levels[pointer + 1] == 0 && skill_table[i].levels[pointer] != -1)) {
            return;
          }
          j = pointer;
          points = skill_table[i].levels[j + 1];
        }

        if (target->skills[skill_table[i].vnum] == -1)
        tpoints = 1;
        else {
          orig = target->skills[skill_table[i].vnum];
          for (j = points; j > orig; j--)
          tpoints += j;
        }
        if (!has_requirements(target, skill_table[i].vnum, tpoints, FALSE)) {
          return;
        }
        int cost = train_skill_cost(target, skill_table[i].vnum, TRAINED_NATURAL);
        if (cost < 1)
        return;
        if (target->spentrpexp + target->spentnewrpexp >=
            target->pcdata->rpexp_cap) {
          return;
        }
        if (cost > available_rpexp(target)) {
          return;
        }
        target->skills[skill_table[i].vnum] = points;
        charge_rpexp(target, cost);
        printf_to_char(target, "`RYour %s stat increases!`x\n\r", skill_table[i].name);

        if (target->skills[skill_table[i].vnum] == 0) {
          if (skill_table[i].levels[0] == -1)
          points = skill_table[i].levels[1];
          else
          points = skill_table[i].levels[0];
        }
        else if (target->skills[skill_table[i].vnum] == -1) {
          points = 0;
        }
        else {
          for (j = 0; j < 6; j++) {
            if (target->skills[skill_table[i].vnum] == skill_table[i].levels[j])
            pointer = j;
          }
          if (pointer == 5 || (skill_table[i].levels[pointer + 1] == 0 && skill_table[i].levels[pointer] != -1)) {
            target->pcdata->training_stat = 0;
            return;
          }
          j = pointer;
          points = skill_table[i].levels[j + 1];
        }

        if (target->skills[skill_table[i].vnum] == -1)
        tpoints = 1;
        else {
          orig = target->skills[skill_table[i].vnum];
          for (j = points; j > orig; j--)
          tpoints += j;
        }
        if (!has_requirements(target, skill_table[i].vnum, tpoints, FALSE)) {
          target->pcdata->training_stat = 0;
        }

        return;
      }
    }
  }

  int labor_points(CHAR_DATA *ch) {
    int points = 0;
    for (int i = 0; i < MAX_CONTACTS; i++) {
      if (ch->pcdata->contact_jobs[i] == CJOB_LABOR && safe_strlen(ch->pcdata->contact_names[i]) > 2 && safe_strlen(ch->pcdata->contact_descs[i]) > 2)
      points += skillpoint(get_skill(ch, contacts_table[i]));
    }
    return points;
  }

  _DOFUN(do_financialruin) {
    if (get_skill(ch, SKILL_FINANCIALRUIN) < 1) {
      send_to_char("You don't have that ability.\n\r", ch);
      return;
    }
    if (ch->pcdata->legendary_cool > current_time) {
      send_to_char("You can't do that again yet.\n\r", ch);
      return;
    }
    struct stat sb;
    char buf[MIL];
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    CHAR_DATA *victim;
    d.original = NULL;
    if ((victim = get_char_world_pc(argument)) != NULL) // Victim is online.
    online = TRUE;
    else {
      log_string("DESCRIPTOR: Financialruin");

      if (!load_char_obj(&d, argument)) {
        printf_to_char(ch, "\n\r%s is not a character!\n\r", capitalize(argument));
        return;
      }

      sprintf(buf, "%s%s", PLAYER_DIR, capitalize(argument));
      stat(buf, &sb);
      victim = d.character;
    }

    if (IS_NPC(victim) || is_gm(victim)) {
      send_to_char("\n\rYou can't do that to NPCS!\n\r", ch);
      if (!online)
      free_char(victim);

      return;
    }
    if (higher_power(ch) && get_gmtrust(ch, victim) < 3) {
      send_to_char("You need advanced trust first.\n\r", ch);
      if (!online)
      free_char(victim);

      return;
    }

    victim->pcdata->total_money = 0;
    save_char_obj(victim, FALSE, FALSE);
    if (!online)
    free_char(victim);
    send_to_char("You ruin their finances.\n\r", ch);
    ch->pcdata->legendary_cool = current_time + (3600 * 24 * 14);
  }

  _DOFUN(do_arrangehit) {
    if (get_skill(ch, SKILL_ARRANGEHIT) < 1) {
      send_to_char("You don't have that ability.\n\r", ch);
      return;
    }
    if (ch->pcdata->legendary_cool > current_time) {
      send_to_char("You can't do that again yet.\n\r", ch);
      return;
    }
    ch->pcdata->ci_editing = 7;
    ch->pcdata->ci_stats[0] = -3;
    bust_a_prompt(ch);
    return;
  }

  _DOFUN(do_findsecrets) {
    if (get_skill(ch, SKILL_VIEWSECRETS) < 1) {
      send_to_char("You don't have that ability.\n\r", ch);
      return;
    }
    if (ch->pcdata->legendary_cool > current_time) {
      send_to_char("You can't do that again yet.\n\r", ch);
      return;
    }
    struct stat sb;
    char buf[MIL];
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    CHAR_DATA *victim;
    d.original = NULL;
    if ((victim = get_char_world_pc(argument)) != NULL) // Victim is online.
    online = TRUE;
    else {
      log_string("DESCRIPTOR: Find secrects");

      if (!load_char_obj(&d, argument)) {
        printf_to_char(ch, "%s is not a character!\n\r", capitalize(argument));
        return;
      }

      sprintf(buf, "%s%s", PLAYER_DIR, capitalize(argument));
      stat(buf, &sb);
      victim = d.character;
    }

    if (IS_NPC(victim) || is_gm(victim)) {
      send_to_char("You can't do that to NPCS!\n\r", ch);
      if (!online)
      free_char(victim);
      return;
    }

    if (higher_power(ch) && get_gmtrust(ch, victim) < 3) {
      send_to_char("You need advanced trust first.\n\r", ch);
      if (!online)
      free_char(victim);

      return;
    }

    ch->pcdata->legendary_cool = current_time + (3600 * 24 * 14);
    lookup_char(ch, victim, 5);
    if (!online)
    free_char(victim);
  }

  _DOFUN(do_butcher) {
    char arg[MAX_INPUT_LENGTH];
    OBJ_DATA *obj = NULL;

    one_argument(argument, arg);

    if (arg[0] == '\0' || !str_cmp(arg, ch->name)) {
      send_to_char("You may have some trouble doing that.\n\r", ch);
      return;
    }

    if (is_helpless(ch) || is_pinned(ch) || in_fight(ch) || room_hostile(ch->in_room) || is_ghost(ch)) {
      send_to_char("Not now.\n\r", ch);
      return;
    }
    if ((obj = get_eq_char(ch, WEAR_HOLD)) == NULL || !is_name(arg, obj->name)) {
      obj = get_obj_carry(ch, arg, ch);
    }
    if (obj == NULL) {
      obj = get_obj_list(ch, arg, ch->in_room->contents);
    }
    if (obj == NULL) {
      send_to_char("You can't find it.\n\r", ch);
      return;
    }
    if (obj->item_type != ITEM_CORPSE_NPC) {
      send_to_char("That's not a corpse.\n\r", ch);
      return;
    }
    if (obj->value[3] == 0) {
      send_to_char("That isn't a harvestable corpse.\n\r", ch);
      return;
    }
    ch->pcdata->process = PROCESS_BUTCHER;
    ch->pcdata->process_target = NULL;
    ch->pcdata->process_timer = 10;
    ch->pcdata->process_timer -= get_skill(ch, SKILL_DEMONOLOGY) * 2;
    ch->pcdata->process_timer = UMAX(ch->pcdata->process_timer, 2);
    ch->pcdata->process_subtype = ch->in_room->vnum;
    free_string(ch->pcdata->process_argumentone);
    ch->pcdata->process_argumentone = str_dup(arg);
    act("You begin to butcher the corpse.", ch, NULL, NULL, TO_CHAR);
    act("$n starts to butcher the corpse.", ch, NULL, NULL, TO_ROOM);
  }

  int execute_npc_ritual(char *argument) {
    CHAR_DATA *caster;
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    Buffer outbuf;
    char buf[MSL];
    d.original = NULL;

    if (!load_char_obj(&d, "Ritualist")) {
      return -1;
    }

    sprintf(buf, "%s%s", PLAYER_DIR, capitalize("Ritualist"));
    caster = d.character;
    if (IS_NPC(caster)) {
      if (!online)
      free_char(caster);
      return -1;
    }
    caster->pcdata->process = 0;
    caster->lifeforce = 10000;
    caster->lf_used = 0;
    caster->lf_taken = 0;
    caster->lf_sused = 0;
    do_function(caster, &do_ritual, argument);
    if (caster->pcdata->process != PROCESS_RITUAL)
    return -1;

    conclude_process(caster, PROCESS_RITUAL);
    int amount = 10000 - base_lifeforce(caster);
    return amount;
    free_char(caster);
    return -2;
  }

  void statcheck(CHAR_DATA *ch) {
    int j;
    int tablemark;
    int difference;
    for (int i = 0; i < SKILL_USED; i++) {
      if (skilltype(skill_table[i].vnum) == STYPE_COMBATFOCUS)
      continue;
      if (skilltype(skill_table[i].vnum) == STYPE_ARCANEFOCUS)
      continue;
      if (skilltype(skill_table[i].vnum) == STYPE_PROFFOCUS)
      continue;

      if (ch->skills[skill_table[i].vnum] > 0) {
        int original = ch->skills[skill_table[i].vnum];
        for (j = 0; j < 6; j++) {
          if (ch->skills[skill_table[i].vnum] == skill_table[i].levels[j]) {
            tablemark = j;
            j = 5;
          }
          else {
            tablemark = -1;
          }
        }
        if (tablemark == 0) {
          difference = skillpoint(ch->skills[skill_table[i].vnum]);
        }
        // Calculates difference between increments in skill_table
        else {
          difference = skillpoint(ch->skills[skill_table[i].vnum]) -
          skillpoint(skill_table[i].levels[tablemark - 1]);
        }
        if (tablemark == 0)
        ch->skills[skill_table[i].vnum] = 0;
        else
        ch->skills[skill_table[i].vnum] = skill_table[i].levels[tablemark - 1];

        if (has_requirements(ch, skill_table[i].vnum, ch->skills[skill_table[i].vnum], FALSE))
        ch->skills[skill_table[i].vnum] = original;
        else
        refund_rpexp(ch, BASE_STAT_COST * difference, FALSE);
      }
    }
  }
  void disccheck(CHAR_DATA *ch) {

    int i;
    int shield_total = 0;
    for (i = 0; i < DIS_USED; i++) {
      if (ch->disciplines[discipline_table[i].vnum] > 0) {
        if (discipline_table[i].range == -1)
        shield_total += ch->disciplines[discipline_table[i].vnum];
      }
    }
    for (i = 0; i < DIS_USED; i++) {
      if (ch->disciplines[discipline_table[i].vnum] > 0) {
        int value = 0;
        if (discipline_table[i].range == -1)
        value = shield_total;
        else
        value = ch->disciplines[discipline_table[i].vnum];
        int cost = value * BASE_DISC_COST;
        ch->disciplines[discipline_table[i].vnum]--;
        if (!can_train_disc(ch, discipline_table[i].vnum))
        refund_exp(ch, cost);
        else
        ch->disciplines[discipline_table[i].vnum]++;
      }
    }
  }

  _DOFUN(do_smell) {
    if (get_skill(ch, SKILL_ACUTESMELL) < 1) {
      send_to_char("You don't have an acute sense of smell.\n\r", ch);
      return;
    }
    if (ch->pcdata->sniffing == TRUE) {
      ch->pcdata->sniffing = FALSE;
      send_to_char("You stop tracking by scent.\n\r", ch);
      return;
    }
    else {
      ch->pcdata->sniffing = TRUE;
      send_to_char("You start tracking by scent.\n\r", ch);
      return;
    }
  }

  _DOFUN(do_guardmind) {
    if (base_lifeforce(ch) < 8500) {
      send_to_char("You lack the willpower to do that.\n\r", ch);
      return;
    }
    ch->pcdata->mind_guarded = 300;
    if (ch->pcdata->mind_guard_mult > 0) {
      int cost = ch->pcdata->mind_guard_mult * ch->pcdata->mind_guard_mult;
      use_lifeforce(ch, cost, "Guardmind");
    }
    ch->pcdata->mind_guard_mult++;
    send_to_char("You concentrate on guarding your mind.\n\r", ch);
    CHAR_DATA *to;
    for (CharList::iterator it = ch->in_room->people->begin();
    it != ch->in_room->people->end(); ++it) {
      to = *it;

      if (IS_NPC(to) || to->desc == NULL || to == ch)
      continue;

      if (to == ch)
      continue;

      if (get_skill(to, SKILL_ACUTEHEAR) > 0 && !is_undead(ch))
      act("You hear $N's heart start to beat a little faster.", to, NULL, ch, TO_CHAR);
    }
  }

  bool elligible_training(CHAR_DATA *ch, int skill, int type) {
    int stype = skilltype(skill);
    int level = ch->skills[skill];
    if (stype == STYPE_ABOMINATION) {
      if (type == TRAINED_SELF)
      return TRUE;
      return FALSE;
    }
    if (stype == STYPE_SUPERNATURAL || stype == STYPE_SABILITIES) {
      if (skill == SKILL_SHAPESHIFTING && type == TRAINED_ITEM)
      return FALSE;
      if (type == TRAINED_SELF || type == TRAINED_TAUGHT || type == TRAINED_ITEM || type == TRAINED_TATTOO)
      return TRUE;
      return FALSE;
    }
    if (skill == SKILL_SPLITMIND) {
      if (type == TRAINED_SELF || type == TRAINED_TAUGHT || type == TRAINED_ITEM || type == TRAINED_TATTOO)
      return TRUE;
      return FALSE;
    }
    if (stype == STYPE_CONTACTS) {
      if (type == TRAINED_FRIEND || type == TRAINED_BLACKMAIL || type == TRAINED_MINDCONTROL)
      return TRUE;
      return FALSE;
    }
    if (stype == STYPE_PHYSICAL) {
      if (level <= 2) {
        if (type == TRAINED_NATURAL)
        return TRUE;
        return FALSE;
      }
      if (type == TRAINED_SELF || type == TRAINED_ITEM || type == TRAINED_TATTOO || type == TRAINED_IMPLANT)
      return TRUE;
      return FALSE;
    }
    if (skill == SKILL_STEALTH) {
      if (type == TRAINED_NATURAL || type == TRAINED_TAUGHT)
      return TRUE;
    }
    if (stype == STYPE_SKILLS) {
      if (level <= 2) {
        if (type == TRAINED_NATURAL || type == TRAINED_TAUGHT)
        return TRUE;
        return FALSE;
      }
      if (type == TRAINED_TOOL)
      return TRUE;
      return FALSE;
    }
    if (stype == STYPE_ABILITIES) {
      if (type == TRAINED_SELF || type == TRAINED_TAUGHT)
      return TRUE;
      return FALSE;
    }
    if (skill == SKILL_WEALTH) {
      if (type == TRAINED_JOBLEGAL || type == TRAINED_JOBBLACKMAIL || type == TRAINED_JOBMINDCONTROL || type == TRAINED_THEFT || type == TRAINED_INHERIT)
      return TRUE;
      return FALSE;
    }
    if (skill == SKILL_GAMES && type == TRAINED_FAE)
    return TRUE;
    if (skill == SKILL_ART || skill == SKILL_ART2 || skill == SKILL_ART3 || skill == SKILL_LANGUAGE2 || skill == SKILL_LANGUAGE3 || skill == SKILL_LANGUAGE4 || skill == SKILL_LANGUAGE5) {
      if (type == TRAINED_SELF || type == TRAINED_TAUGHT || type == TRAINED_DEMON || type == TRAINED_FAE)
      return TRUE;
      return FALSE;
    }
    if (skill == SKILL_DEMONOLOGY || skill == SKILL_RITUALISM || skill == SKILL_INCANTATION) {
      if (type == TRAINED_SELF || type == TRAINED_TAUGHT || type == TRAINED_DEMON || type == TRAINED_FAE || type == TRAINED_BOOK)
      return TRUE;
      return FALSE;
    }
    if (skill == SKILL_EDUCATION) {
      if (type == TRAINED_EDUFRAUD || type == TRAINED_EDUBRIBE || type == TRAINED_EDULEGIT || type == TRAINED_DEMON)
      return TRUE;
      return FALSE;
    }
    if (type == TRAINED_NATURAL)
    return TRUE;
    return FALSE;
  }

  void train_stat(CHAR_DATA *target, int stat, int method, char *string) {
    int i, j, points, tpoints, orig;
    CHAR_DATA *ch = target;
    for (i = 0; i < SKILL_USED; i++) {
      int pointer = 0;
      if (skill_table[i].vnum == stat) {
        if (target->skills[skill_table[i].vnum] == 0) {
          if (skill_table[i].levels[0] == -1)
          points = skill_table[i].levels[1];
          else
          points = skill_table[i].levels[0];
        }
        else if (target->skills[skill_table[i].vnum] == -1) {
          points = 0;
        }
        else {
          for (j = 0; j < 6; j++) {
            if (target->skills[skill_table[i].vnum] == skill_table[i].levels[j])
            pointer = j;
          }
          if (pointer == 5 || (skill_table[i].levels[pointer + 1] == 0 && skill_table[i].levels[pointer] != -1)) {
            send_to_char("You can't raise it that high.\n\r", ch);
            return;
          }
          j = pointer;
          points = skill_table[i].levels[j + 1];
        }

        if (target->skills[skill_table[i].vnum] == -1) {
          tpoints = 1;
          orig = -1;
        }
        else {
          orig = target->skills[skill_table[i].vnum];
          for (j = points; j > orig; j--)
          tpoints += j;
        }

        if (!has_requirements(target, skill_table[i].vnum, tpoints, TRUE)) {
          send_to_char("You don't meet the requirements to raise that.\n\r", target);
          return;
        }

        if (skilltype(skill_table[i].vnum) == STYPE_ARCANEFOCUS || skilltype(skill_table[i].vnum) == STYPE_COMBATFOCUS || skilltype(skill_table[i].vnum) == STYPE_PROFFOCUS) {
          bool thisfound = FALSE;
          bool otherfound = FALSE;
          for (int x = 0; x < 10; x++) {
            if (target->pcdata->previous_focus_vnum[x] > 100 && target->pcdata->previous_focus_vnum[x] < 200 && target->pcdata->previous_focus_level[x] < 10 && target->pcdata->previous_focus_level[x] >
                target->skills[target->pcdata->previous_focus_vnum[x]])
            otherfound = TRUE;
            if (target->pcdata->previous_focus_vnum[x] == skill_table[i].vnum)
            thisfound = TRUE;
          }

          if (otherfound == TRUE && thisfound == FALSE) {
            send_to_char("You have to train the focus you previously had first.\n\r", ch);
            return;
          }
        }

        if (IS_IMMORTAL(ch)) {
          target->skills[skill_table[i].vnum] = points;
          printf_to_char(ch, "You train %s.\n\r", skill_table[i].name);
          return;
        }

        int cost = train_skill_cost(target, skill_table[i].vnum, method);
        if (cost < 1)
        return;

        if (target->spentrpexp + target->spentnewrpexp >=
            target->pcdata->rpexp_cap && !IS_FLAG(target->act, PLR_GUEST)) {
          send_to_char("You're already at your  rpxp cap.\n\r", ch);
          return;
        }

        if (cost > available_rpexp(target)) {
          printf_to_char(ch, "You'd need %d rpxp to train that.\n\r", cost);
          return;
        }

        for (int x = 0; x < 300; x++) {
          if (target->pcdata->stat_log_cost[x] == 0) {
            target->pcdata->stat_log_stat[x] = skill_table[i].vnum;
            target->pcdata->stat_log_from[x] = orig;
            target->pcdata->stat_log_to[x] = points;
            target->pcdata->stat_log_cost[x] = cost;
            target->pcdata->stat_log_method[x] = method;
            free_string(target->pcdata->stat_log_string[x]);
            target->pcdata->stat_log_string[x] = str_dup(from_color(string));
            x = 300;
          }
        }
        target->skills[skill_table[i].vnum] = points;
        charge_rpexp(target, cost);
        printf_to_char(ch, "You train %s.\n\r", skill_table[i].name);
        ch->pcdata->training_stage = 0;
        ch->pcdata->training_stat = 0;
        ch->pcdata->training_type = 0;
        return;
      }
    }
  }

  void process_training_argument(CHAR_DATA *ch, char *argument) {
    int stage = ch->pcdata->training_stage;
    int stat = ch->pcdata->training_stat;
    int type = ch->pcdata->training_type;
    if (stage == 1) {
      if (!str_cmp(argument, "self-mastered") && elligible_training(ch, stat, TRAINED_SELF)) {
        train_stat(ch, stat, TRAINED_SELF, "");
        ch->pcdata->training_stage = 0;
      }
      else if (!str_cmp(argument, "item") && elligible_training(ch, stat, TRAINED_ITEM)) {
        send_to_char("Enter the string that will identify the item, this must be contained in the item's short description. Or type cancel to abort\n\r", ch);
        ch->pcdata->training_type = TRAINED_ITEM;
        ch->pcdata->training_stage++;
      }
      else if (!str_cmp(argument, "taught") && elligible_training(ch, stat, TRAINED_TAUGHT)) {
        if (ch->in_room == NULL || ch->in_room->vnum < 300) {
          send_to_char("You cannot be taught before entering the game.\n\r", ch);
          return;
        }
        send_to_char("Please specify your teacher. Or type cancel to abort.\n\r", ch);
        ch->pcdata->training_type = TRAINED_TAUGHT;
        ch->pcdata->training_stage++;
      }
      else if (!str_cmp(argument, "friendship") && elligible_training(ch, stat, TRAINED_FRIEND)) {
        train_stat(ch, stat, TRAINED_FRIEND, "");
        ch->pcdata->training_stage = 0;
      }
      else if (!str_cmp(argument, "blackmail") && elligible_training(ch, stat, TRAINED_BLACKMAIL)) {
        train_stat(ch, stat, TRAINED_BLACKMAIL, "");
        ch->pcdata->training_stage = 0;
      }
      else if (!str_cmp(argument, "mind control") && elligible_training(ch, stat, TRAINED_MINDCONTROL)) {
        train_stat(ch, stat, TRAINED_MINDCONTROL, "");
        ch->pcdata->training_stage = 0;
      }
      else if (!str_cmp(argument, "tool") && elligible_training(ch, stat, TRAINED_TOOL)) {
        send_to_char("Enter the string that will identify the tool, this must be contained in the item's short description. Or type cancel to abort\n\r", ch);
        ch->pcdata->training_type = TRAINED_TOOL;
        ch->pcdata->training_stage++;
      }
      else if (!str_cmp(argument, "legitimate job") && elligible_training(ch, stat, TRAINED_JOBLEGAL)) {
        train_stat(ch, stat, TRAINED_JOBLEGAL, "");
        ch->pcdata->training_stage = 0;
      }
      else if (!str_cmp(argument, "blackmail acquired job") && elligible_training(ch, stat, TRAINED_JOBBLACKMAIL)) {
        train_stat(ch, stat, TRAINED_JOBBLACKMAIL, "");
        ch->pcdata->training_stage = 0;
      }
      else if (!str_cmp(argument, "mind control acquired job") && elligible_training(ch, stat, TRAINED_JOBMINDCONTROL)) {
        train_stat(ch, stat, TRAINED_JOBMINDCONTROL, "");
        ch->pcdata->training_stage = 0;
      }
      else if (!str_cmp(argument, "theft") && elligible_training(ch, stat, TRAINED_THEFT)) {
        train_stat(ch, stat, TRAINED_THEFT, "");
        ch->pcdata->training_stage = 0;
      }
      else if (!str_cmp(argument, "inheritance") && elligible_training(ch, stat, TRAINED_INHERIT)) {
        train_stat(ch, stat, TRAINED_INHERIT, "");
        ch->pcdata->training_stage = 0;
      }
      else if (!str_cmp(argument, "demonic pact") && elligible_training(ch, stat, TRAINED_DEMON)) {
        send_to_char("Enter a short description of the terms of the pact. Or type cancel to abort.\n\r", ch);
        ch->pcdata->training_type = TRAINED_DEMON;
        ch->pcdata->training_stage++;
      }
      else if (!str_cmp(argument, "fae bargain") && elligible_training(ch, stat, TRAINED_FAE)) {
        send_to_char("Enter a short description of the terms of the bargain. Or type cancel to abort.\n\r", ch);
        ch->pcdata->training_type = TRAINED_FAE;
        ch->pcdata->training_stage++;
      }
      else if (!str_cmp(argument, "book") && elligible_training(ch, stat, TRAINED_BOOK)) {
        send_to_char("Enter the string that will identify the book, this must be contained in the item's short description. Or type cancel to abort\n\r", ch);
        ch->pcdata->training_type = TRAINED_BOOK;
        ch->pcdata->training_stage++;
      }
      else if (!str_cmp(argument, "legitimately") && elligible_training(ch, stat, TRAINED_EDULEGIT)) {
        train_stat(ch, stat, TRAINED_EDULEGIT, "");
        ch->pcdata->training_stage = 0;
      }
      else if (!str_cmp(argument, "bribery") && elligible_training(ch, stat, TRAINED_EDUBRIBE)) {
        train_stat(ch, stat, TRAINED_EDUBRIBE, "");
        ch->pcdata->training_stage = 0;
      }
      else if (!str_cmp(argument, "fraud") && elligible_training(ch, stat, TRAINED_EDUFRAUD)) {
        train_stat(ch, stat, TRAINED_EDUFRAUD, "");
        ch->pcdata->training_stage = 0;
      }
      else if (!str_cmp(argument, "natural") && elligible_training(ch, stat, TRAINED_NATURAL)) {
        train_stat(ch, stat, TRAINED_NATURAL, "");
        ch->pcdata->training_stage = 0;
      }
      else if (!str_cmp(argument, "implant") && elligible_training(ch, stat, TRAINED_IMPLANT)) {
        train_stat(ch, stat, TRAINED_IMPLANT, "");
        ch->pcdata->training_stage = 0;
      }
      else if (!str_cmp(argument, "tattoo") && elligible_training(ch, stat, TRAINED_TATTOO)) {
        send_to_char("Enter the location of the tattoo. Or type cancel to abort.\n\r", ch);
        ch->pcdata->training_type = TRAINED_TATTOO;
        ch->pcdata->training_stage++;
      }
      else {
        send_to_char("Invalid entry, training canceled.\n\r", ch);
        ch->pcdata->training_stage = 0;
      }
    }
    else if (stage == 2) {
      if (type == TRAINED_TATTOO) {
        int location = location_by_name(argument);
        if (location == -1 || location >= 16 || safe_strlen(argument) < 2) {
          send_to_char("Invalid entry, training canceled.\n\r", ch);
          ch->pcdata->training_stage = 0;
          return;
        }
        for (int i = 0; i < 300; i++) {
          if (ch->pcdata->stat_log_method[i] == TRAINED_TATTOO + location && ch->pcdata->stat_log_stat[i] != stat) {
            send_to_char("You already have a mystical tattoo in that location.\n\r", ch);
            ch->pcdata->training_stage = 0;
            return;
          }
        }
        ch->pcdata->training_stage++;
        ch->pcdata->training_type = TRAINED_TATTOO + location;
        send_to_char("Location chosen, enter a short description of the tattoo. Or type cancel to abort\n\r", ch);
      }
      else if (type == TRAINED_BOOK) {
        if (!str_cmp(argument, "cancel")) {
          send_to_char("Training canceled.\n\r", ch);
          ch->pcdata->training_stage = 0;
          return;
        }
        if (safe_strlen(from_color(argument)) < 10) {
          send_to_char("Book name must be at least 10 characters.\n\r", ch);
          ch->pcdata->training_stage = 0;
          return;
        }
        train_stat(ch, stat, type, argument);
      }
      else if (type == TRAINED_DEMON) {
        if (!str_cmp(argument, "cancel")) {
          send_to_char("Training canceled.\n\r", ch);
          ch->pcdata->training_stage = 0;
          return;
        }
        if (safe_strlen(from_color(argument)) < 20) {
          send_to_char("Deal must be at least 20 characters.\n\r", ch);
          ch->pcdata->training_stage = 0;
          return;
        }
        train_stat(ch, stat, type, argument);
      }
      else if (type == TRAINED_FAE) {
        if (!str_cmp(argument, "cancel")) {
          send_to_char("Training canceled.\n\r", ch);
          ch->pcdata->training_stage = 0;
          return;
        }
        if (safe_strlen(from_color(argument)) < 20) {
          send_to_char("Bargain must be at least 20 characters.\n\r", ch);
          ch->pcdata->training_stage = 0;
          return;
        }
        train_stat(ch, stat, type, argument);
      }
      else if (type == TRAINED_TOOL) {
        if (!str_cmp(argument, "cancel")) {
          send_to_char("Training canceled.\n\r", ch);
          ch->pcdata->training_stage = 0;
          return;
        }
        if (safe_strlen(from_color(argument)) < 10) {
          send_to_char("Tool name must be at least 10 characters.\n\r", ch);
          ch->pcdata->training_stage = 0;
          return;
        }
        for (int i = 0; i < 300; i++) {
          if (ch->pcdata->stat_log_method[i] == TRAINED_TOOL && ch->pcdata->stat_log_stat[i] != stat && (strcasestr(from_color(argument), ch->pcdata->stat_log_string[i]) !=
                NULL || strcasestr(ch->pcdata->stat_log_string[i], from_color(argument)) !=
                NULL)) {
            send_to_char("You already have a tool like that for other things.\n\r", ch);
            ch->pcdata->training_stage = 0;
            return;
          }
        }
        train_stat(ch, stat, type, argument);
      }
      else if (type == TRAINED_ITEM) {
        if (!str_cmp(argument, "cancel")) {
          send_to_char("Training canceled.\n\r", ch);
          ch->pcdata->training_stage = 0;
          return;
        }
        if (safe_strlen(from_color(argument)) < 10) {
          send_to_char("Item name must be at least 10 characters.\n\r", ch);
          ch->pcdata->training_stage = 0;
          return;
        }
        for (int i = 0; i < 300; i++) {
          if (ch->pcdata->stat_log_method[i] == TRAINED_ITEM && ch->pcdata->stat_log_stat[i] != stat && (strcasestr(from_color(argument), ch->pcdata->stat_log_string[i]) !=
                NULL || strcasestr(ch->pcdata->stat_log_string[i], from_color(argument)) !=
                NULL)) {
            send_to_char("You already have an item like that for other things.\n\r", ch);
            ch->pcdata->training_stage = 0;
            return;
          }
        }
        train_stat(ch, stat, type, argument);
      }
      else if (type == TRAINED_TAUGHT) {
        CHAR_DATA *victim;
        if (!str_cmp(argument, "cancel")) {
          send_to_char("Training canceled.\n\r", ch);
          ch->pcdata->training_stage = 0;
          return;
        }
        if ((victim = get_char_room(ch, NULL, argument)) == NULL) {
          send_to_char("They're not here, training aborted\n\r", ch);
          ch->pcdata->training_stage = 0;
          return;
        }
        if (IS_NPC(victim) || same_player(ch, victim) || is_gm(victim)) {
          send_to_char("They're not here, training aborted.\n\r", ch);
          ch->pcdata->training_stage = 0;
          return;
        }
        ch->pcdata->training_stage++;
        victim->pcdata->training_stage = 100;
        send_to_char("Awaiting approval.\n\r", ch);
        printf_to_char(victim, "%s would like you to teach them %s, type yes to agree or no to disagree.\n\r", PERS(ch, victim), skill_table[skillpointer(stat)].name);
      }
      else
      ch->pcdata->training_stage = 0;
    }
    else if (stage == 3) {
      if (type >= TRAINED_TATTOO) {
        if (!str_cmp(argument, "cancel")) {
          send_to_char("Training canceled.\n\r", ch);
          ch->pcdata->training_stage = 0;
          return;
        }

        if (safe_strlen(from_color(argument)) < 10) {
          send_to_char("Description must be at least 10 characters.\n\r", ch);
          ch->pcdata->training_stage = 0;
          return;
        }
        train_stat(ch, stat, type, argument);
      }
      else {
        ch->pcdata->training_stage = 0;
        send_to_char("Teaching aborted.\n\r", ch);
      }
    }
    else if (stage == 100) {
      if (!str_cmp(argument, "yes") || !str_cmp(argument, "y")) {
        CHAR_DATA *to;
        for (CharList::iterator it = ch->in_room->people->begin();
        it != ch->in_room->people->end(); ++it) {
          to = *it;
          if (IS_NPC(to) || to->desc == NULL || to == ch)
          continue;
          if (to->pcdata->training_stage == 3 && to->pcdata->training_type == TRAINED_TAUGHT) {
            if (ch->skills[to->pcdata->training_stat] >
                to->skills[to->pcdata->training_stat]) {
              train_stat(to, to->pcdata->training_stat, TRAINED_TAUGHT, ch->name);
              act("$N teaches you.", to, NULL, ch, TO_CHAR);
              act("You teach $n", to, NULL, ch, TO_VICT);
              ch->pcdata->training_stage = 0;
              to->pcdata->training_stage = 0;
              use_lifeforce(ch, 500, "Teaching.");
            }
            else {
              act("$N tries to teach you but you don't learn anything.", to, NULL, ch, TO_CHAR);
              act("You teach $n.", to, NULL, ch, TO_VICT);
              ch->pcdata->training_stage = 0;
              to->pcdata->training_stage = 0;
              use_lifeforce(ch, 500, "Teaching.");
            }
          }
        }
      }
      else {
        CHAR_DATA *to;
        for (CharList::iterator it = ch->in_room->people->begin();
        it != ch->in_room->people->end(); ++it) {
          to = *it;
          if (IS_NPC(to) || to->desc == NULL || to == ch)
          continue;
          if (to->pcdata->training_stage == 3 && to->pcdata->training_type == TRAINED_TAUGHT) {
            to->pcdata->training_stage = 0;
          }
        }
        ch->pcdata->training_stage = 0;
        act("You decline to teach.", ch, NULL, NULL, TO_CHAR);
        act("$n declines to teach.", ch, NULL, NULL, TO_ROOM);
      }
    }
    else {
      ch->pcdata->training_stage = 0;
      send_to_char("Training aborted.\n\r", ch);
    }
  }

  void deactivate_stat(CHAR_DATA *ch, int stat) {
    for (int i = 0; i < 10; i++) {
      if (ch->pcdata->deactivated_stats[i] == stat) {
        return;
      }
    }
    for (int i = 0; i < 10; i++) {
      if (ch->pcdata->deactivated_stats[i] == 0) {
        ch->pcdata->deactivated_stats[i] = stat;
        printf_to_char(ch, "You lose the ability to make use of %s.\n\r", skill_table[skillpointer(stat)].name);
        return;
      }
    }
  }

  void activate_stat(CHAR_DATA *ch, int stat) {
    for (int i = 0; i < 10; i++) {
      if (ch->pcdata->deactivated_stats[i] == stat) {
        ch->pcdata->deactivated_stats[i] = 0;
        printf_to_char(ch, "You regain the ability to make use of %s.\n\r", skill_table[skillpointer(stat)].name);
        return;
      }
    }
  }

  void activate_stat_silent(CHAR_DATA *ch, int stat) {
    for (int i = 0; i < 10; i++) {
      if (ch->pcdata->deactivated_stats[i] == stat) {
        ch->pcdata->deactivated_stats[i] = 0;
        return;
      }
    }
  }

  void stat_active_update(CHAR_DATA *ch) {
    OBJ_DATA *obj;
    for (int i = 0; i < 300; i++) {
      if (ch->pcdata->stat_log_to[i] < ch->skills[ch->pcdata->stat_log_stat[i]])
      continue;
      if (ch->pcdata->stat_log_to[i] > ch->skills[ch->pcdata->stat_log_stat[i]])
      continue;

      if (ch->pcdata->stat_log_method[i] != TRAINED_ITEM && ch->pcdata->stat_log_method[i] != TRAINED_TOOL && ch->pcdata->stat_log_method[i] != TRAINED_BOOK && ch->pcdata->stat_log_method[i] != TRAINED_IMPLANT)
      activate_stat_silent(ch, ch->pcdata->stat_log_stat[i]);

      if (ch->pcdata->stat_log_method[i] == TRAINED_ITEM) {
        bool found = FALSE;
        for (int iWear = 0; iWear < MAX_WEAR; iWear++) {
          if ((obj = get_eq_char(ch, iWear)) != NULL) {
            if (strcasestr(obj->short_descr, ch->pcdata->stat_log_string[i]) !=
                NULL)
            found = TRUE;
          }
        }
        if (found == FALSE) {
          deactivate_stat(ch, ch->pcdata->stat_log_stat[i]);
        }
        else
        activate_stat(ch, ch->pcdata->stat_log_stat[i]);
      }
      if (ch->pcdata->stat_log_method[i] == TRAINED_TOOL) {
        bool found = FALSE;
        for (obj = ch->carrying; obj != NULL; obj = obj->next_content) {
          if (!IS_SET(obj->extra_flags, ITEM_WARDROBE)) {
            if (strcasestr(obj->short_descr, ch->pcdata->stat_log_string[i]) !=
                NULL)
            found = TRUE;
          }
        }
        if (found == FALSE) {
          deactivate_stat(ch, ch->pcdata->stat_log_stat[i]);
        }
        else
        activate_stat(ch, ch->pcdata->stat_log_stat[i]);
      }
      if (ch->pcdata->stat_log_method[i] == TRAINED_BOOK) {
        bool found = FALSE;
        OBJ_DATA *obj_next;
        for (obj = ch->carrying; obj != NULL; obj = obj_next) {
          obj_next = obj->next_content;
          if (!IS_SET(obj->extra_flags, ITEM_WARDROBE)) {
            if (strcasestr(obj->short_descr, ch->pcdata->stat_log_string[i]) !=
                NULL) {
              found = TRUE;
            }
            else {
            }
          }
        }
        if (found == FALSE) {
          deactivate_stat(ch, ch->pcdata->stat_log_stat[i]);
        }
        else
        activate_stat(ch, ch->pcdata->stat_log_stat[i]);
      }
      if (ch->pcdata->stat_log_method[i] == TRAINED_IMPLANT) {
        if (IS_AFFECTED(ch, AFF_NOTECH) || (in_haven(ch->in_room) && is_town_blackout()))
        deactivate_stat(ch, ch->pcdata->stat_log_stat[i]);
        else
        activate_stat(ch, ch->pcdata->stat_log_stat[i]);
      }
    }
  }

  void stat_explain(CHAR_DATA *ch, CHAR_DATA *target, int stat) {
    int max = -1;
    int point = -1;
    for (int i = 0; i < 300; i++) {
      if (target->pcdata->stat_log_stat[i] == stat && target->pcdata->stat_log_to[i] > max) {
        point = i;
        max = target->pcdata->stat_log_to[i];
      }
    }
    if (point == -1)
    return;
    int type = target->pcdata->stat_log_method[point];
    if (type == TRAINED_SELF)
    printf_to_char(ch, "It was self mastered.\n\r");
    if (type == TRAINED_ITEM)
    printf_to_char(ch, "It requires %s as a focus.\n\r", target->pcdata->stat_log_string[point]);
    if (type == TRAINED_TAUGHT)
    printf_to_char(ch, "It was taught to them by %s.\n\r", target->pcdata->stat_log_string[point]);
    if (type == TRAINED_FRIEND)
    printf_to_char(ch, "It was acquired through friendship.\n\r");
    if (type == TRAINED_BLACKMAIL)
    printf_to_char(ch, "It was acquired through blackmail.\n\r");
    if (type == TRAINED_MINDCONTROL)
    printf_to_char(ch, "It was acquired through mind control.\n\r");
    if (type == TRAINED_TOOL)
    printf_to_char(ch, "It requires %s as a tool.\n\r", target->pcdata->stat_log_string[point]);
    if (type == TRAINED_JOBLEGAL)
    printf_to_char(ch, "It was acquired from a legal job.\n\r");
    if (type == TRAINED_JOBBLACKMAIL)
    printf_to_char(
    ch, "It was acquired from a job obtained through blackmail.\n\r");
    if (type == TRAINED_JOBMINDCONTROL)
    printf_to_char(
    ch, "It was acquired from a job obtained through mind control.\n\r");
    if (type == TRAINED_THEFT)
    printf_to_char(ch, "It was acquired through theft.\n\r");
    if (type == TRAINED_INHERIT)
    printf_to_char(ch, "It was acquired from an inheritance.\n\r");
    if (type == TRAINED_DEMON)
    printf_to_char(ch, "It was acquired through a demonic pact, of terms %s.\n\r", target->pcdata->stat_log_string[point]);
    if (type == TRAINED_FAE)
    printf_to_char(ch, "It was acquired through a fae bargain, of terms %s.\n\r", target->pcdata->stat_log_string[point]);
    if (type == TRAINED_BOOK)
    printf_to_char(ch, "It requires a book like %s.\n\r", target->pcdata->stat_log_string[point]);
    if (type == TRAINED_EDUFRAUD)
    printf_to_char(ch, "It was acquired through fraud.\n\r");
    if (type == TRAINED_EDUBRIBE)
    printf_to_char(ch, "It was acquired through bribery.\n\r");
    if (type == TRAINED_EDULEGIT)
    printf_to_char(ch, "It was acquired legitimately.\n\r");
    if (type == TRAINED_NATURAL)
    printf_to_char(ch, "It was acquired naturally.\n\r");
    if (type == TRAINED_IMPLANT)
    printf_to_char(ch, "It was acquired through a cybernetic implant.\n\r");
    if (type >= TRAINED_TATTOO)
    printf_to_char(ch, "It was acquired through a tattoo of %s.\n\r", target->pcdata->stat_log_string[point]);
  }

  int stat_cost_mod(CHAR_DATA *ch, int method) {
    int base = 100;
    if (method == TRAINED_ITEM)
    base -= 30;
    if (method == TRAINED_TAUGHT)
    base -= 10;
    if (method == TRAINED_BLACKMAIL)
    base -= 25;
    if (method == TRAINED_MINDCONTROL)
    base -= 25;
    if (method == TRAINED_TOOL)
    base -= 30;
    if (method == TRAINED_JOBBLACKMAIL)
    base -= 20;
    if (method == TRAINED_JOBMINDCONTROL)
    base -= 20;
    if (method == TRAINED_THEFT)
    base -= 10;
    if (method == TRAINED_DEMON)
    base -= 25;
    if (method == TRAINED_FAE)
    base -= 25;
    if (method == TRAINED_BOOK)
    base -= 30;
    if (method == TRAINED_EDUFRAUD)
    base -= 20;
    if (method == TRAINED_EDUBRIBE)
    base -= 20;
    if (method == TRAINED_IMPLANT)
    base -= 20;
    if (method >= TRAINED_TATTOO)
    base -= 20;

    if (ch->in_room != NULL && ch->in_room->vnum > 40 && ch->in_room->vnum < 100) {
      base = UMAX(70, base - 20);
    }
    return base;
  }

  int commit_cost(CHAR_DATA *committer, char *vicname) {
    struct stat sb;
    char buf[MSL];
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    CHAR_DATA *victim;
    d.original = NULL;
    if ((victim = get_char_world_pc(vicname)) != NULL) // Victim is online.
    online = TRUE;
    else {
      if (!load_char_obj(&d, vicname)) {
        return FALSE;
      }

      sprintf(buf, "%s%s", PLAYER_DIR, capitalize(vicname));
      stat(buf, &sb);
      victim = d.character;
    }
    int tier = get_tier(victim);
    int cost = 100;
    if (tier == 1)
    cost = 2500;
    if (tier == 2)
    cost = 10000;
    if (tier == 3)
    cost = 20000;
    if (tier == 4)
    cost = 30000;
    if (tier == 5)
    cost = 40000;

    cost /= 2;

    if (victim->modifier == MODIFIER_CHEMICAL)
    cost /= 2;

    if (victim->race == RACE_DREAMCHILD || victim->race == RACE_WILDLING || victim->race == RACE_TIMESWEPT || victim->race == RACE_ELSEBORN)
    cost /= 2;

    if (victim->faction == 0)
    cost /= 10;

    if (victim->played / 3600 < 20)
    cost /= 5;

    if (victim->pcdata->deluded_duration > current_time) {
      for (int v = victim->pcdata->deluded_cost / 5; v > 0; v--)
      cost = cost * 2 / 3;
    }

    if (is_weakness(committer, victim))
    cost /= 3;
    else if (has_weakness(committer, victim))
    cost *= 3;

    if (IS_FLAG(victim->comm, COMM_MANDRAKE))
    cost /= 2;

    if (IS_FLAG(committer->act, PLR_TYRANT))
    cost /= 40;

    if (!online)
    free_char(victim);

    return cost;
  }

  void offline_potion(char *name, int vnum) {
    struct stat sb;
    char buf[MSL];
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    CHAR_DATA *victim;
    d.original = NULL;
    OBJ_DATA *obj;
    if ((victim = get_char_world_pc(name)) != NULL) // Victim is online.
    online = TRUE;
    else {
      if (!load_char_obj(&d, name)) {
        return;
      }

      sprintf(buf, "%s%s", PLAYER_DIR, capitalize(name));
      stat(buf, &sb);
      victim = d.character;
    }
    obj = create_object(get_obj_index(vnum), 0);
    obj_to_char(obj, victim);
    obj->value[4] = current_time + (3600 * 24 * 10);
    obj = create_object(get_obj_index(vnum), 0);
    obj_to_char(obj, victim);
    obj->value[4] = current_time + (3600 * 24 * 10);
    if (!online) {
      sprintf(buf, "%s\n%s", victim->pcdata->messages, "You receive a small package containing two potions.");
      free_string(victim->pcdata->messages);
      victim->pcdata->messages = str_dup(buf);
    }
    else
    send_to_char("Someone discreetly hands you a package containing two small potions.\n\r", victim);
    save_char_obj(victim, FALSE, FALSE);
    if (!online)
    free_char(victim);
  }

  bool valid_psychic_target(char *name) {
    struct stat sb;
    char buf[MSL];
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    CHAR_DATA *victim;
    d.original = NULL;
    if ((victim = get_char_world_pc(name)) != NULL) // Victim is online.
    online = TRUE;
    else {
      if (!load_char_obj(&d, name)) {
        return FALSE;
      }

      sprintf(buf, "%s%s", PLAYER_DIR, capitalize(name));
      stat(buf, &sb);
      victim = d.character;
    }
    if (cardinal(victim) && victim->pcdata->psychic_proof < current_time) {
      if (!online)
      free_char(victim);
      return TRUE;
    }
    if (IS_FLAG(victim->act, PLR_TYRANT) && victim->pcdata->psychic_proof < current_time) {
      if (!online)
      free_char(victim);
      return TRUE;
    }

    if (!online)
    free_char(victim);
    return FALSE;
  }
  int psychic_soldiers(char *name) {
    struct stat sb;
    char buf[MSL];
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    CHAR_DATA *victim;
    d.original = NULL;
    if ((victim = get_char_world_pc(name)) != NULL) // Victim is online.
    online = TRUE;
    else {
      if (!load_char_obj(&d, name)) {
        return 0;
      }

      sprintf(buf, "%s%s", PLAYER_DIR, capitalize(name));
      stat(buf, &sb);
      victim = d.character;
    }
    int val = 0;
    if (cardinal(victim) || IS_FLAG(victim->act, PLR_TYRANT)) {
      if (victim->pcdata->psychic_attempts == 0)
      val = 12;
      else if (victim->pcdata->psychic_attempts == 1)
      val = 6;
      else if (victim->pcdata->psychic_attempts == 2)
      val = 3;
      else if (victim->pcdata->psychic_attempts == 3)
      val = 1;
    }
    if (!online)
    free_char(victim);
    return val;
  }

  _DOFUN(do_deluded) {
    struct stat sb;
    char buf[MSL];
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    CHAR_DATA *victim;
    d.original = NULL;
    char arg1[MSL];
    char arg2[MSL];
    char arg3[MSL];
    argument = one_argument(argument, arg1);
    argument = one_argument(argument, arg2);
    argument = one_argument(argument, arg3);
    int amount = atoi(arg2);
    int days = atoi(arg3);
    if (amount <= 0 || amount >= 50 || days <= 0 || days > 200 || safe_strlen(argument) < 2) {
      send_to_char("Syntax: Deluded (character) (lf debuff) (days) (reason)\n\r", ch);
      return;
    }

    if ((victim = get_char_world_pc(arg1)) != NULL) // Victim is online.
    online = TRUE;
    else {
      if (!load_char_obj(&d, arg1)) {
        return;
      }

      sprintf(buf, "%s%s", PLAYER_DIR, capitalize(arg1));
      stat(buf, &sb);
      victim = d.character;
    }

    victim->pcdata->deluded_duration = current_time + (3600 * 24 * days);
    victim->pcdata->deluded_cost = amount;
    free_string(victim->pcdata->deluded_reason);
    victim->pcdata->deluded_reason = str_dup(argument);
    send_to_char("Done.\n\r", ch);
    save_char_obj(victim, FALSE, FALSE);
    if (!online)
    free_char(victim);
    else
    do_function(victim, &do_imprint, "");
  }

  void weakness_update(CHAR_DATA *ch, char *vicname) {
    struct stat sb;
    char buf[MSL];
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    CHAR_DATA *victim;
    d.original = NULL;
    ch->pcdata->weakness_status = WEAKNESS_HAS;
    sprintf(buf, "WEAKNESS: %s: %s", ch->name, vicname);
    log_string(buf);
    if ((victim = get_char_world_pc(vicname)) != NULL) // Victim is online.
    online = TRUE;
    else {
      if (!load_char_obj(&d, vicname)) {
        ch->pcdata->weakness_status = 0;
        return;
      }

      sprintf(buf, "%s%s", PLAYER_DIR, capitalize(vicname));
      stat(buf, &sb);
      victim = d.character;
    }
    if (victim->pcdata->lastnotalone < current_time - (3600 * 24 * 7)) {
      ch->pcdata->weakness_status = 0;
      if (!online)
      free_char(victim);
      return;
    }
    if (IS_FLAG(victim->act, PLR_DEAD)) {
      ch->pcdata->weakness_status = 0;
      if (!online)
      free_char(victim);
      return;
    }
    if (higher_power(victim)) {
      ch->pcdata->weakness_status = 0;
      if (!online)
      free_char(victim);
      return;
    }

    if (ch->pcdata->overworked > 0) {
      ch->pcdata->weakness_status = 0;
      if (!online)
      free_char(victim);
      return;
    }

    if (!clinic_patient(victim) && institute_room(victim->in_room) && !is_helpless(victim) && victim->wounds == 0 && victim->recent_moved <= -300) {
      ch->pcdata->weakness_status = 0;
      if (!online)
      free_char(victim);
      return;
    }
    int mindays = 80;
    if (get_tier(victim) < 2)
    mindays /= 4;
    if (victim->pcdata->attract[ATTRACT_PROM] > 100)
    mindays /= 2;
    if (same_player(ch, victim))
    mindays /= 2;

    //    int daysnotalone = (current_time -
    //    victim->pcdata->lastnotalone)/3600/24/7;

    if (victim->pcdata->lastnotalone <
        current_time - (3600 * 24 * mindays / 10)) {
      ch->pcdata->weakness_status = 0;
      if (!online)
      free_char(victim);
      return;
    }

    if (ch->in_room != victim->in_room) {
      if (ch->lf_taken < victim->lf_taken / 2)
      ch->lf_taken = victim->lf_taken / 2;
      if (victim->wounds == 1)
      ch->pcdata->weakness_status = WEAKNESS_MILD; // -10
      if (IS_FLAG(victim->comm, COMM_DREAMSNARED))
      ch->pcdata->weakness_status = WEAKNESS_DREAMSNARED; // -10
      if (clinic_patient(victim))
      ch->pcdata->weakness_status = WEAKNESS_COMMITTED; //-15
      if (is_helpless(victim))
      ch->pcdata->weakness_status = WEAKNESS_PRISONER; // -20
      if (victim->wounds == 2)
      ch->pcdata->weakness_status = WEAKNESS_SEVERE; // -20
      if (victim->wounds == 3)
      ch->pcdata->weakness_status = WEAKNESS_CRITICAL; // -30
    }

    if (!online)
    free_char(victim);
  }

  bool has_employees(ACCOUNT_TYPE *account) {
    struct stat sb;
    char buf[MSL];
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    CHAR_DATA *victim;
    d.original = NULL;
    for (int i = 0; i < 25; i++) {
      if (safe_strlen(account->characters[i]) > 2 && account->char_stasis[i] == 0) {
        online = FALSE;
        if ((victim = get_char_world_pc(account->characters[i])) !=
            NULL) // Victim is online.
        online = TRUE;
        else {
          if (!load_char_obj(&d, account->characters[i])) {
            continue;
          }

          sprintf(buf, "%s%s", PLAYER_DIR, capitalize(account->characters[i]));
          stat(buf, &sb);
          victim = d.character;
        }
        if (victim->pcdata->job_type_one == JOB_EMPLOYEE) {
          if (!online)
          free_char(victim);
          return TRUE;
        }
        if (!online)
        free_char(victim);
      }
    }
    return FALSE;
  }

  void wipe_char(char *name) {
    if (!str_cmp(name, "Daed") || !str_cmp(name, "Discordance") || !str_cmp(name, "Discordancer") || !str_cmp(name, "Ouroboros") || !str_cmp(name, "Tyr") || !str_cmp(name, "GroundObjects") || !str_cmp(name, "Ritualist"))
    return;

    struct stat sb;
    char buf[MSL];
    DESCRIPTOR_DATA d;
    CHAR_DATA *ch;
    bool online = FALSE;
    d.original = NULL;
    if ((ch = get_char_world_pc(name)) != NULL) // Victim is online.
    online = TRUE;
    else {
      if (!load_char_obj(&d, name)) {
        return;
      }

      sprintf(buf, "%s%s", PLAYER_DIR, capitalize(name));
      stat(buf, &sb);
      ch = d.character;
    }
    if (ch->pcdata->account != NULL) {
      ch->pcdata->account->pkarmaspent -= ch->spentpkarma;
      ch->pcdata->account->pkarmaspent =
      UMAX(ch->pcdata->account->pkarmaspent, 0);

      if (ch->spentexp > 350000) {
        ch->spentexp -= 350000;
        ch->pcdata->account->xp += 350000;
        ch->pcdata->account->xp += ch->spentexp * 8 / 10;
      }
      else
      ch->pcdata->account->xp += ch->spentexp;
      if (ch->spentrpexp > 350000) {
        ch->spentrpexp -= 350000;
        ch->pcdata->account->rpxp += 350000;
        ch->pcdata->account->rpxp += ch->spentrpexp * 8 / 10;
      }
      else
      ch->pcdata->account->rpxp += ch->spentrpexp;
      ch->pcdata->account->karmabank += ch->spentkarma;
      ch->pcdata->account->rpxp += ch->pcdata->dexp / 5;

      for (int i = 0; i < 25; i++) {
        if (!str_cmp(ch->pcdata->account->characters[i], ch->name)) {
          free_string(ch->pcdata->account->characters[i]);
          ch->pcdata->account->characters[i] = str_dup("");
          save_account(ch->pcdata->account, FALSE);
        }
      }
    }
    else
    bug("No account char.", 0);
    if (online)
    send_to_char("Bye.\n\r", ch);
    char strsave[MAX_INPUT_LENGTH];
    sprintf(strsave, "%s%s", PLAYER_DIR, capitalize(ch->name));
    room_purge(ch);
    save_char_obj(ch, FALSE, FALSE);
    extract_char(ch, TRUE);
    unlink(strsave);
  }

  void clear_account(char *name) {
    char strsave[MAX_INPUT_LENGTH];
    ACCOUNT_TYPE *account;
    FILE *fp;
    account = new_account();
    free_string(account->name);
    account->name = str_dup(name);

    sprintf(strsave, "%s%s", ACCOUNT_DIR, capitalize(name));
    if ((fp = fopen(strsave, "r")) != NULL) {
      fread_account(account, fp);
      fclose(fp);
    }
    else {
      return;
    }
    for (int i = 0; i < 25; i++) {
      free_string(account->characters[i]);
      account->characters[i] = str_dup("");
      account->char_stasis[i] = 0;
    }
    save_account(account, FALSE);
  }
  void clear_kaccount(char *name) {
    char strsave[MAX_INPUT_LENGTH];
    ACCOUNT_TYPE *account;
    FILE *fp;
    account = new_account();
    free_string(account->name);
    account->name = str_dup(name);

    sprintf(strsave, "%s%s", ACCOUNT_DIR, capitalize(name));
    if ((fp = fopen(strsave, "r")) != NULL) {
      fread_account(account, fp);
      fclose(fp);
    }
    else {
      return;
    }
    account->pkarmaspent = 0;
    save_account(account, FALSE);
  }

  void wipe_account(char *name) {
    char strsave[MAX_INPUT_LENGTH];
    ACCOUNT_TYPE *account;
    FILE *fp;
    account = new_account();
    free_string(account->name);
    account->name = str_dup(name);

    sprintf(strsave, "%s%s", ACCOUNT_DIR, capitalize(name));
    if ((fp = fopen(strsave, "r")) != NULL) {
      fread_account(account, fp);
      fclose(fp);
    }
    else {
      return;
    }
    account->paycooldown = 0;
    account->socialcooldown = 0;
    account->unrewarded_donation = 0;
    account->hightiercooldown = 0;
    account->factioncooldown = 0;
    account->roster_cool = 0;
    account->prey_cool = 0;
    account->last_scheme = 0;
    account->encounter_karma = 0;
    account->adventure_karma = 0;
    account->mystery_karma = 0;
    account->ambiant_karma = 0;
    account->monster_karma = 0;
    account->misc_karma = 0;
    account->scheme_karma = 0;
    account->offworld_karma = 0;
    account->other_karma = 0;
    account->storyidea_cooldown = 0;
    account->encounter_cooldown = 0;
    account->target_encounter_cooldown = 0;
    account->award_karma = 0;
    account->awards = 0;
    account->award_progress = 0;
    account->villain_cooldown = 0;
    account->villain_score = 0;
    account->villain_mod = 0;
    free_string(account->sr_history);
    account->sr_history = str_dup("");
    account->sr_aexp = 0;
    free_string(account->lastfacchar);
    account->lastfacchar = str_dup("");
    free_string(account->lasttierchar);
    account->lasttierchar = str_dup("");
    account->daily_pvp_exp = 0;
    account->last_infuse_date = 0;
    account->karmaearned = 0;
    account->karma = account->karma + account->karmabank + account->pkarma / 2;
    account->pkarma = UMIN(account->karma / 3, 25000);
    account->karma = UMIN(account->karma / 5, 12500);
    account->karmaearned = account->karma;
    account->other_karma = account->karma;
    account->pkarmaspent = 0;
    account->karmabank = 0;
    account->newcharcount = 4;
    account->maxhours = 0;
    account->focusedchar = 0;
    account->focusedcount = 0;
    free_string(account->pastcharacters);
    account->pastcharacters = str_dup("");
    free_string(account->sr_history);
    account->sr_history = str_dup("");
    account->xp = UMIN(account->xp / 5, 125000);
    account->rpxp = UMIN(account->rpxp / 5, 125000);

    save_account(account, FALSE);
    if (account->xp < 100 && account->rpxp < 100 && account->karma < 100)
    unlink(strsave);
  }

  _DOFUN(do_pwipe) {
    FILE *fp;
    if ((fp = fopen("../player/playerlist", "r")) != NULL) {
      for (;;) {
        char *word = fread_word(fp);
        if (word != NULL && safe_strlen(word) > 0) {
          if (!str_cmp(word, "#END")) {
            fclose(fp);
            send_to_char("Done.\n\r", ch);
            return;
          }
          wipe_char(word);
        }
      }
      fclose(fp);
    }
    else {
      send_to_char("Unable to open player/playerlist.\n\r", ch);
    }
  }

  _DOFUN(do_awipe) {
    FILE *fp;

    if ((fp = fopen("../accounts/playerlist", "r")) != NULL) {
      for (;;) {
        char *word = fread_word(fp);
        if (word != NULL && safe_strlen(word) > 0) {
          if (!str_cmp(word, "#END")) {
            fclose(fp);
            send_to_char("Done.\n\r", ch);
            return;
          }
          char buf[MSL];
          sprintf(buf, "Wiping %s", word);
          bug(buf, 0);
          wipe_account(word);
          //clear_kaccount(word);
        }
      }
      fclose(fp);
    }
    else {
      send_to_char("Unable to open accounts/playerlist.\n\r", ch);
    }
  }

  bool account_allies(CHAR_DATA *ch, CHAR_DATA *victim) {
    struct stat sb;
    char buf[MSL];
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    CHAR_DATA *lookup;
    d.original = NULL;
    int chfactions[10];
    int vicfactions[10];
    for (int i = 0; i < 10; i++) {
      chfactions[i] = 0;
      vicfactions[i] = 0;
    }
    ACCOUNT_TYPE *vicaccount;
    if (victim->pcdata->account == NULL) {
      vicaccount = reload_account(victim->pcdata->account_name);
    }
    else
    vicaccount = victim->pcdata->account;

    if (vicaccount == NULL) {
      return FALSE;
    }
    ACCOUNT_TYPE *chaccount;
    if (ch->pcdata->account == NULL) {
      chaccount = reload_account(ch->pcdata->account_name);
    }
    else
    chaccount = ch->pcdata->account;

    if (chaccount == NULL) {
      return FALSE;
    }
    for (int i = 0; i < 25; i++) {
      if (safe_strlen(chaccount->characters[i]) > 2 && chaccount->char_stasis[i] == 0) {
        online = FALSE;
        if ((lookup = get_char_world_pc(chaccount->characters[i])) !=
            NULL) // Victim is online.
        online = TRUE;
        else {
          if (!load_char_obj(&d, chaccount->characters[i])) {
            continue;
          }

          sprintf(buf, "%s%s", PLAYER_DIR, capitalize(chaccount->characters[i]));
          stat(buf, &sb);
          lookup = d.character;
        }
        if (lookup->faction != 0) {
          for (int x = 0; x < 10; x++) {
            if (chfactions[x] == 0) {
              chfactions[x] = lookup->faction;
              x = 10;
            }
          }
        }
        if (!online)
        free_char(lookup);
      }
    }

    for (int i = 0; i < 25; i++) {
      if (safe_strlen(vicaccount->characters[i]) > 2 && vicaccount->char_stasis[i] == 0) {
        online = FALSE;
        if ((lookup = get_char_world_pc(vicaccount->characters[i])) !=
            NULL) // Victim is online.
        online = TRUE;
        else {
          if (!load_char_obj(&d, vicaccount->characters[i])) {
            continue;
          }

          sprintf(buf, "%s%s", PLAYER_DIR, capitalize(vicaccount->characters[i]));
          stat(buf, &sb);
          lookup = d.character;
        }
        if (lookup->faction != 0) {
          for (int x = 0; x < 10; x++) {
            if (vicfactions[x] == 0) {
              vicfactions[x] = lookup->faction;
              x = 10;
            }
          }
        }
        if (!online)
        free_char(lookup);
      }
    }
    for (int i = 0; i < 10; i++) {
      for (int j = 0; j < 10; j++) {
        if (chfactions[i] == vicfactions[j])
        return TRUE;
      }
    }
    return FALSE;
  }

  bool stolen_object(CHAR_DATA *ch, OBJ_DATA *obj) {
    EXTRA_DESCR_DATA *ed;
    for (ed = obj->extra_descr; ed; ed = ed->next) {
      if (is_name("+owner", ed->keyword)) {
        if (safe_strlen(ed->description) > 2 && str_cmp(ed->description, ch->name))
        return TRUE;
      }
    }
    return FALSE;
  }

  bool my_object(CHAR_DATA *ch, OBJ_DATA *obj) {
    EXTRA_DESCR_DATA *ed;
    for (ed = obj->extra_descr; ed; ed = ed->next) {
      if (is_name("+owner", ed->keyword)) {
        if (safe_strlen(ed->description) > 2 && !str_cmp(ed->description, ch->name))
        return FALSE;
      }
    }
    return TRUE;
  }

  void return_object(OBJ_DATA *obj) {
    struct stat sb;
    char buf[MSL];
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    CHAR_DATA *victim;
    d.original = NULL;
    EXTRA_DESCR_DATA *ed;
    for (ed = obj->extra_descr; ed; ed = ed->next) {
      if (is_name("+owner", ed->keyword)) {
        online = FALSE;
        if ((victim = get_char_world_pc(ed->description)) !=
            NULL) // Victim is online.
        online = TRUE;
        else {
          if (!load_char_obj(&d, ed->description)) {
            continue;
          }
          sprintf(buf, "%s%s", PLAYER_DIR, capitalize(ed->description));
          stat(buf, &sb);
          victim = d.character;
        }
        if (IS_NPC(victim)) {
          extract_obj(obj);
          return;
        }
        if (obj->carried_by == victim) {
          extract_obj(obj);
          return;
        }
        if (obj->carried_by != NULL)
        obj_from_char(obj);
        obj_to_char(obj, victim);
        obj->stash_room = 0;
        if (!IS_SET(obj->extra_flags, ITEM_WARDROBE))
        SET_BIT(obj->extra_flags, ITEM_WARDROBE);
        if (IS_SET(obj->extra_flags, ITEM_NORESALE) && victim->pcdata->total_credit >= obj->cost / 5)
        victim->pcdata->total_credit -= obj->cost / 5;
        else
        victim->pcdata->total_money -= obj->cost / 5;
        char buf[MSL];
        char vname[MSL];
        sprintf(vname, "%s", victim->name);
        sprintf(buf, "%s is returned to you for $%d.", obj->description, obj->cost / 500);
        save_char_obj(victim, FALSE, FALSE);
        if (!online)
        free_char(victim);
        message_to_char(vname, buf);
        return;
      }
    }
    extract_obj(obj);
  }
  
  void stolen_update(OBJ_DATA *obj) {
    if (obj->carried_by == NULL)
    return;

    if (IS_NPC(obj->carried_by))
    return;

    CHAR_DATA *ch = obj->carried_by;

    if (is_helpless(ch) || is_pinned(ch) || is_ghost(ch) || locked_room(ch->in_room, ch))
    return;

    EXTRA_DESCR_DATA *ed;
    for (ed = obj->extra_descr; ed; ed = ed->next) {
      if (is_name("+owner", ed->keyword)) {
        if (!str_cmp(ed->description, ch->name)) {
          free_string(ed->description);
          ed->description = str_dup("");
        }
      }
    }
  }

  void steal_object(OBJ_DATA *obj, CHAR_DATA *ch) {
    EXTRA_DESCR_DATA *ed;
    for (ed = obj->extra_descr; ed; ed = ed->next) {
      if (is_name("+owner", ed->keyword))
      break;
    }

    if (!ed) {
      ed = new_extra_descr();
      ed->keyword = str_dup("+owner");
      ed->next = obj->extra_descr;
      obj->extra_descr = ed;
      free_string(obj->extra_descr->description);
      obj->extra_descr->description = str_dup(ch->name);
    }
    else {
      free_string(ed->description);
      ed->description = str_dup(ch->name);
    }
  }

  bool active_character(char *cname) {
    for (vector<WEEKLY_TYPE *>::iterator it = WeeklyVect.begin();
    it != WeeklyVect.end(); ++it) {
      if ((*it)->valid == FALSE)
      continue;
      if(!str_cmp(cname, (*it)->charname))
      return TRUE;
    }

    log_string("Active Check");
    struct stat sb;
    char buf[MSL];
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    CHAR_DATA *victim;
    d.original = NULL;
    online = FALSE;
    if ((victim = get_char_world_pc(cname)) != NULL) // Victim is online.
    online = TRUE;
    else {
      if (!load_char_obj(&d, cname)) {
        return FALSE;
      }
      sprintf(buf, "%s%s", PLAYER_DIR, capitalize(cname));
      stat(buf, &sb);
      victim = d.character;
    }
    if (IS_NPC(victim))
    return FALSE;
    if (victim->pcdata->lastnotalone < (current_time - (3600 * 24 * 7))) {
      if (!online)
      free_char(victim);
      return FALSE;
    }
    if (!online)
    free_char(victim);
    return TRUE;
  }
  void inactive_disrepect(char *cname) {
    struct stat sb;
    char buf[MSL];
    DESCRIPTOR_DATA d;
    bool online = FALSE;
    CHAR_DATA *victim;
    d.original = NULL;
    online = FALSE;
    if ((victim = get_char_world_pc(cname)) != NULL) // Victim is online.
    online = TRUE;
    else {
      if (!load_char_obj(&d, cname)) {
        return;
      }
      sprintf(buf, "%s%s", PLAYER_DIR, capitalize(cname));
      stat(buf, &sb);
      victim = d.character;
    }
    if (IS_NPC(victim))
    return;

    FACTION_TYPE *facone = clan_lookup(victim->fcore);
    if (facone != NULL) {
      if (!str_cmp(facone->leader, victim->name)) {
        facone->leaderesteem = facone->leaderesteem * 47 / 50;
      }
      for (int i = 0; i < 100; i++) {
        if (!str_cmp(facone->member_names[i], victim->name))
        facone->member_esteem[i] = facone->member_esteem[i] * 47 / 50;
      }
      victim->esteem_faction = victim->esteem_faction * 47 / 50;
    }

    facone = clan_lookup(victim->fcult);
    if (facone != NULL) {
      if (!str_cmp(facone->leader, victim->name)) {
        facone->leaderesteem = facone->leaderesteem * 47 / 50;
      }
      for (int i = 0; i < 100; i++) {
        if (!str_cmp(facone->member_names[i], victim->name))
        facone->member_esteem[i] = facone->member_esteem[i] * 47 / 50;
      }
      victim->esteem_cult = victim->esteem_cult * 47 / 50;
    }

    facone = clan_lookup(victim->fsect);
    if (facone != NULL) {
      if (!str_cmp(facone->leader, victim->name)) {
        facone->leaderesteem = facone->leaderesteem * 47 / 50;
      }
      for (int i = 0; i < 100; i++) {
        if (!str_cmp(facone->member_names[i], victim->name))
        facone->member_esteem[i] = facone->member_esteem[i] * 47 / 50;
      }
      victim->esteem_sect = victim->esteem_sect * 47 / 50;
    }

    save_char_obj(victim, FALSE, FALSE);
    if (!online)
    free_char(victim);
  }

  _DOFUN(do_eidilon) {
    char arg1[MSL];
    argument = one_argument_nouncap(argument, arg1);
    if (ch->pcdata->ci_editing == 18 || ch->pcdata->ci_editing == 19) {
      ch->pcdata->ci_absorb = 1;
      FACTION_TYPE *cult = clan_lookup(ch->fcult);
      FACTION_TYPE *sect = clan_lookup(ch->fsect);
      if(cult != NULL and !str_cmp(cult->eidilon, arg1))
      {
        free_string(ch->pcdata->ci_short);
        ch->pcdata->ci_short = str_dup(cult->eidilon);
        send_to_char("Done.\n\r", ch);
        return;
      }
      if(sect != NULL and !str_cmp(sect->eidilon, arg1))
      {
        free_string(ch->pcdata->ci_short);
        ch->pcdata->ci_short = str_dup(sect->eidilon);
        send_to_char("Done.\n\r", ch);
        return;
      }
      send_to_char("You aren't in a cult or a sect.\n\r", ch);
      return;
    }
    if(ch->pcdata->ci_editing == 23)
    {
      ch->pcdata->ci_absorb = 1;
      for (vector<FACTION_TYPE *>::iterator it = FacVect.begin();
      it != FacVect.end(); ++it) {

        if(!str_cmp(arg1, (*it)->eidilon))
        {
          if(is_name(ch->name, (*it)->eidilon_players) || has_trust(ch, TRUST_SPIRIT, (*it)->vnum) || is_name(nosr_name(ch->name), (*it)->eidilon_players))
          {
            free_string(ch->pcdata->ci_myselfdelayed);
            ch->pcdata->ci_myselfdelayed = str_dup((*it)->eidilon);
            send_to_char("Done.\n\r", ch);
            return;

          }
          for (int i = 0; i < 100; i++) {
            if(!str_cmp(ch->name, (*it)->member_names[i]) || !str_cmp(nosr_name(ch->name), (*it)->member_names[i]))
            {
              free_string(ch->pcdata->ci_myselfdelayed);
              ch->pcdata->ci_myselfdelayed = str_dup((*it)->eidilon);
              send_to_char("Done.\n\r", ch);
              return;
            }
          }

        }
      }
      FACTION_TYPE *cult = clan_lookup(ch->fcult);
      FACTION_TYPE *sect = clan_lookup(ch->fsect);
      if(cult != NULL and !str_cmp(cult->eidilon, arg1))
      {
        free_string(ch->pcdata->ci_myselfdelayed);
        ch->pcdata->ci_myselfdelayed = str_dup(cult->eidilon);
        send_to_char("Done.\n\r", ch);
        return;
      }
      if(sect != NULL and !str_cmp(sect->eidilon, arg1))
      {
        free_string(ch->pcdata->ci_myselfdelayed);
        ch->pcdata->ci_myselfdelayed = str_dup(sect->eidilon);
        send_to_char("Done.\n\r", ch);
        return;
      }
      send_to_char("You aren't in a cult or a sect.\n\r", ch);
      return;
    }
  }

  _DOFUN(do_base) {
    if (ch->pcdata->ci_editing == 18) {
      ch->pcdata->ci_absorb = 1;
      ch->pcdata->ci_discipline = number_range(ENCOUNTER_ONE, ENCOUNTER_MAX);
      printf_to_char(ch, "New Base encounter: %s\n\r", encounter_prompt(ch, ch->pcdata->ci_discipline).c_str());
      return;
    }
  }

  ANNIVERSARY_TYPE * get_anniversary_today()
  {
    time_t east_time;
    east_time = current_time;
    tm *ptm;
    ptm = gmtime(&east_time);
    time_t ann_time;
    tm *atm;

    ANNIVERSARY_TYPE *ann = NULL;

    for (vector<ANNIVERSARY_TYPE *>::iterator it = AnniversaryVect.begin();
    it != AnniversaryVect.end(); ++it) {
      ann_time = (*it)->happen_at;
      atm = gmtime(&ann_time);
      if(ptm->tm_year > atm->tm_year && ptm->tm_mon == atm->tm_mon && ptm->tm_mday == atm->tm_mday )
      {
        ann = *it;
        break;
      }
      if(ptm->tm_year == atm->tm_year && ptm->tm_mon == atm->tm_mon + 1 && ptm->tm_mday == atm->tm_mday )
      {
        ann = *it;
        break;
      }
      if(ptm->tm_year == atm->tm_year && ptm->tm_mon == atm->tm_mon + 3 && ptm->tm_mday == atm->tm_mday )
      {
        ann = *it;
        break;
      }
      if(ptm->tm_year == atm->tm_year && ptm->tm_mon == atm->tm_mon + 6 && ptm->tm_mday == atm->tm_mday )
      {
        ann = *it;
        break;
      }
      if(ptm->tm_year == atm->tm_year  + 1 && ptm->tm_mon == atm->tm_mon - 11 && ptm->tm_mday == atm->tm_mday )
      {
        ann = *it;
        break;
      }
      if(ptm->tm_year == atm->tm_year  + 1 && ptm->tm_mon == atm->tm_mon - 9 && ptm->tm_mday == atm->tm_mday )
      {
        ann = *it;
        break;
      }
      if(ptm->tm_year == atm->tm_year  + 1 && ptm->tm_mon == atm->tm_mon - 6 && ptm->tm_mday == atm->tm_mday )
      {
        ann = *it;
        break;
      }
    }

    if(ann != NULL)
    return ann;

    return NULL;

  }


#if defined(__cplusplus)
}
#endif
